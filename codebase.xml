This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-01-31T05:39:10.492Z

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

- Line numbers have been added to the beginning of each line.
</notes>

<additional_info>

For more information about Repomix, visit: https://github.com/yamadashy/repomix
</additional_info>

</file_summary>

<repository_structure>
android/app/app.properties
android/app/build.gradle
android/app/proguard-rules.pro
android/app/src/debug/AndroidManifest.xml
android/app/src/main/AndroidManifest.xml
android/app/src/main/java/io/flutter/plugins/GeneratedPluginRegistrant.java
android/app/src/main/kotlin/com/mrw1986/fftcg_companion_app/MainActivity.kt
android/app/src/main/res/drawable-v21/launch_background.xml
android/app/src/main/res/drawable/launch_background.xml
android/app/src/main/res/mipmap-anydpi-v26/ic_launcher.xml
android/app/src/main/res/values-night/styles.xml
android/app/src/main/res/values/styles.xml
android/app/src/main/res/xml/backup_rules.xml
android/app/src/main/res/xml/network_security_config.xml
android/app/src/profile/AndroidManifest.xml
android/build.gradle
android/gradle.properties
android/gradle/wrapper/gradle-wrapper.properties
android/settings.gradle
firebase.json
flutter_launcher_icons.yaml
lib/core/logging/talker_service.dart
lib/core/models/sync_status.dart
lib/core/presentation/widgets/app_bar_widget.dart
lib/core/providers/app_providers.dart
lib/core/providers/root_route_history_notifier.dart
lib/core/routing/app_router.dart
lib/core/services/background_sync_service.dart
lib/core/services/connectivity_service.dart
lib/core/services/hive_service.dart
lib/core/services/preferences_service.dart
lib/core/services/sync_service.dart
lib/core/state/app_state.dart
lib/core/theme/app_theme.dart
lib/core/utils/breakpoints.dart
lib/core/utils/responsive_utils.dart
lib/features/auth/enums/auth_status.dart
lib/features/auth/models/auth_exception.dart
lib/features/auth/presentation/auth_wrapper.dart
lib/features/auth/presentation/screens/account_linking_screen.dart
lib/features/auth/presentation/screens/login_screen.dart
lib/features/auth/presentation/screens/registration_screen.dart
lib/features/auth/presentation/widgets/account_exists_dialog.dart
lib/features/auth/presentation/widgets/auth_button.dart
lib/features/auth/presentation/widgets/auth_text_field.dart
lib/features/auth/presentation/widgets/email_verification_dialog.dart
lib/features/auth/providers/auth_notifier.dart
lib/features/auth/providers/auth_providers.dart
lib/features/auth/providers/auth_state.dart
lib/features/auth/repositories/auth_repository.dart
lib/features/auth/services/auth_service.dart
lib/features/cards/models/card_extended_data.dart
lib/features/cards/models/card_filter_options.dart
lib/features/cards/models/card_image_metadata.dart
lib/features/cards/models/favorite_card.dart
lib/features/cards/models/fftcg_card.dart
lib/features/cards/models/price_model.dart
lib/features/cards/presentation/screens/card_detail_screen.dart
lib/features/cards/presentation/screens/cards_screen.dart
lib/features/cards/presentation/widgets/card_grid_item.dart
lib/features/cards/presentation/widgets/card_list_item.dart
lib/features/cards/presentation/widgets/filter_bottom_sheet.dart
lib/features/cards/presentation/widgets/search_bar_widget.dart
lib/features/cards/presentation/widgets/sort_menu_button.dart
lib/features/cards/providers/card_notifier.dart
lib/features/cards/providers/card_providers.dart
lib/features/cards/providers/card_state.dart
lib/features/cards/providers/favorites_provider.dart
lib/features/cards/repositories/card_repository.dart
lib/features/cards/services/card_cache_service.dart
lib/features/cards/services/favorites_service.dart
lib/features/collection/presentation/screens/collection_screen.dart
lib/features/decks/presentation/screens/decks_screen.dart
lib/features/profile/models/collection_stats.dart
lib/features/profile/models/deck_stats.dart
lib/features/profile/models/user_stats.dart
lib/features/profile/presentation/screens/profile_screen.dart
lib/features/profile/presentation/widgets/collection_stats.dart
lib/features/profile/presentation/widgets/deck_stats.dart
lib/features/profile/presentation/widgets/profile_header.dart
lib/features/profile/providers/user_stats_provider.dart
lib/features/scanner/presentation/screens/scanner_screen.dart
lib/features/settings/presentation/screens/logs_viewer_screen.dart
lib/features/settings/presentation/screens/settings_screen.dart
lib/features/settings/presentation/widgets/color_picker.dart
lib/features/settings/presentation/widgets/settings_switch_tile.dart
lib/features/settings/presentation/widgets/theme_selector.dart
lib/features/settings/providers/settings_providers.dart
lib/main.dart
lib/models/card_model.dart
lib/models/user_model.dart
lib/services/app_check_service.dart
lib/services/firebase_service.dart
lib/services/firestore_service.dart
lib/services/image_url_service.dart
lib/utils/result.dart
lib/utils/retry.dart
pubspec.yaml
</repository_structure>

<repository_files>
This section contains the contents of the repository's files.

<file path="android/app/app.properties">
1: appAuthRedirectScheme=com.mrw1986.fftcg_companion_app
</file>

<file path="android/app/build.gradle">
 1: plugins {
 2:     id "com.android.application"
 3:     id "kotlin-android"
 4:     id "dev.flutter.flutter-gradle-plugin"
 5:     id "com.google.gms.google-services"
 6:     id "com.google.firebase.crashlytics"
 7: }
 8: 
 9: def flutterVersionCode = project.hasProperty('flutter.versionCode') ? project.getProperty('flutter.versionCode') : '1'
10: def flutterVersionName = project.hasProperty('flutter.versionName') ? project.getProperty('flutter.versionName') : '1.0'
11: 
12: android {
13:     namespace "com.mrw1986.fftcg_companion_app"
14:     compileSdkVersion flutter.compileSdkVersion
15:     ndkVersion = "27.0.12077973"
16:     buildFeatures.buildConfig = true
17: 
18:     compileOptions {
19:         sourceCompatibility JavaVersion.VERSION_1_8
20:         targetCompatibility JavaVersion.VERSION_1_8
21:     }
22: 
23:     kotlinOptions {
24:         jvmTarget = '1.8'
25:     }
26: 
27:     sourceSets {
28:         main.java.srcDirs += 'src/main/kotlin'
29:     }
30: 
31:     defaultConfig {
32:     applicationId "com.mrw1986.fftcg_companion_app"
33:     minSdkVersion 23  // Changed from 21 to 23
34:     targetSdkVersion 34
35:     versionCode flutterVersionCode.toInteger()
36:     versionName flutterVersionName
37:     multiDexEnabled true
38:     
39:     manifestPlaceholders = [
40:         'applicationName': "io.flutter.app.FlutterApplication",
41:         'appAuthRedirectScheme': 'com.mrw1986.fftcg_companion_app'
42:     ]
43: }
44: 
45:     buildTypes {
46:         release {
47:             signingConfig signingConfigs.debug
48:             minifyEnabled true
49:             shrinkResources true
50:             proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
51:             
52:             manifestPlaceholders = [
53:                 applicationName: "io.flutter.app.FlutterApplication",
54:                 appName: "FFTCG Companion"
55:             ]
56:         }
57:         debug {
58:             minifyEnabled false
59:             shrinkResources false
60:             manifestPlaceholders = [
61:                 applicationName: "io.flutter.app.FlutterApplication",
62:                 appName: "FFTCG Companion Debug"
63:             ]
64:         }
65:     }
66: }
67: 
68: flutter {
69:     source '../..'
70: }
71: 
72: dependencies {
73:     implementation platform('com.google.firebase:firebase-bom:32.7.2')
74:     implementation 'com.google.firebase:firebase-analytics'
75:     implementation 'com.google.firebase:firebase-auth'
76:     implementation 'com.google.firebase:firebase-firestore'    
77:     implementation 'com.google.android.gms:play-services-base:18.2.0'
78:     implementation 'com.google.android.gms:play-services-auth:20.7.0'
79:     implementation 'com.google.firebase:firebase-appcheck-playintegrity'
80:     implementation 'androidx.multidex:multidex:2.0.1'
81:     implementation 'com.google.firebase:firebase-appcheck-debug'
82:     implementation 'com.google.firebase:firebase-appcheck-playintegrity'
83: }
</file>

<file path="android/app/proguard-rules.pro">
 1: # android/app/proguard-rules.pro
 2: -keep class io.flutter.app.** { *; }
 3: -keep class io.flutter.plugin.**  { *; }
 4: -keep class io.flutter.util.**  { *; }
 5: -keep class io.flutter.view.**  { *; }
 6: -keep class io.flutter.**  { *; }
 7: -keep class io.flutter.plugins.**  { *; }
 8: -keep class com.google.firebase.** { *; }
 9: 
10: # Firebase Authentication
11: -keepattributes Signature
12: -keepattributes *Annotation*
13: -keepattributes EnclosingMethod
14: -keepattributes InnerClasses
15: 
16: # Firebase Firestore
17: -keep class com.google.firebase.firestore.** { *; }
18: -keep class com.google.firebase.firestore.model.** { *; }
19: 
20: # Hive
21: -keep class * extends com.google.protobuf.GeneratedMessageLite { *; }
22: -keep class * extends io.hive.** { *; }
23: 
24: # Workmanager
25: -keep class androidx.work.** { *; }
26: 
27: # Google Sign In
28: -keep class com.google.android.gms.auth.** { *; }
29: 
30: # Shared Preferences
31: -keep class androidx.datastore.* { *; }
32: -keep class * extends androidx.datastore.preferences.* { *; }
</file>

<file path="android/app/src/debug/AndroidManifest.xml">
1: <manifest xmlns:android="http://schemas.android.com/apk/res/android">
2:     <!-- The INTERNET permission is required for development. Specifically,
3:          the Flutter tool needs it to communicate with the running application
4:          to allow setting breakpoints, to provide hot reload, etc.
5:     -->
6:     <uses-permission android:name="android.permission.INTERNET"/>
7: </manifest>
</file>

<file path="android/app/src/main/AndroidManifest.xml">
 1: <manifest xmlns:android="http://schemas.android.com/apk/res/android">
 2:     <uses-permission android:name="android.permission.INTERNET"/>
 3:     <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
 4:     <uses-permission android:name="android.permission.WAKE_LOCK"/>
 5:     <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/>
 6:     <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE"/>
 7: 
 8:     <queries>
 9:         <intent>
10:             <action android:name="android.intent.action.VIEW" />
11:             <data android:mimeType="*/*" />
12:         </intent>
13:     </queries>
14: 
15:     <application
16:         android:name="${applicationName}"
17:         android:label="FFTCG Companion"
18:         android:icon="@mipmap/ic_launcher"
19:         android:allowBackup="true"
20:         android:fullBackupContent="@xml/backup_rules"
21:         android:networkSecurityConfig="@xml/network_security_config"
22:         android:enableOnBackInvokedCallback="true">
23: 
24:         <meta-data
25:             android:name="com.google.android.gms.version"
26:             android:value="@integer/google_play_services_version" />
27: 
28:         <meta-data
29:             android:name="firebase_performance_logcat_enabled"
30:             android:value="true" />
31: 
32:         <meta-data
33:             android:name="firebase_app_check_debug_token"
34:             android:value="053827d5-b30e-4de5-962f-d20af395002c"/>
35: 
36:         <meta-data
37:             android:name="firebase_performance_collection_enabled"
38:             android:value="true" />
39:             
40:         <meta-data
41:             android:name="firebase_performance_collection_deactivated"
42:             android:value="false" />
43: 
44:         <activity
45:             android:name=".MainActivity"
46:             android:exported="true"
47:             android:launchMode="singleTop"
48:             android:theme="@style/LaunchTheme"
49:             android:configChanges="orientation|keyboardHidden|keyboard|screenSize|smallestScreenSize|locale|layoutDirection|fontScale|screenLayout|density|uiMode"
50:             android:hardwareAccelerated="true"
51:             android:windowSoftInputMode="adjustResize">
52:             <meta-data
53:               android:name="io.flutter.embedding.android.NormalTheme"
54:               android:resource="@style/NormalTheme"
55:               />
56:             <intent-filter>
57:                 <action android:name="android.intent.action.MAIN"/>
58:                 <category android:name="android.intent.category.LAUNCHER"/>
59:             </intent-filter>
60:         </activity>
61: 
62:         <meta-data
63:             android:name="flutterEmbedding"
64:             android:value="2" />
65: 
66:         <activity 
67:             android:name="com.google.android.gms.auth.api.signin.internal.SignInHubActivity"
68:             android:windowSoftInputMode="stateAlwaysHidden|adjustPan"
69:             android:exported="false" />
70: 
71:         <activity
72:             android:name="com.google.android.gms.auth.api.signin.internal.SignInRedirectActivity"
73:             android:exported="true"
74:             android:excludeFromRecents="true"
75:             android:launchMode="singleTask">
76:             <intent-filter>
77:                 <action android:name="android.intent.action.VIEW"/>
78:                 <category android:name="android.intent.category.DEFAULT"/>
79:                 <category android:name="android.intent.category.BROWSABLE"/>
80:                 <data
81:                     android:scheme="com.mrw1986.fftcg_companion_app"
82:                     android:host="oauth2redirect"/>
83:             </intent-filter>
84:         </activity>
85:     </application>
86: </manifest>
</file>

<file path="android/app/src/main/java/io/flutter/plugins/GeneratedPluginRegistrant.java">
 1: package io.flutter.plugins;
 2: 
 3: import androidx.annotation.Keep;
 4: import androidx.annotation.NonNull;
 5: import io.flutter.Log;
 6: 
 7: import io.flutter.embedding.engine.FlutterEngine;
 8: 
 9: /**
10:  * Generated file. Do not edit.
11:  * This file is generated by the Flutter tool based on the
12:  * plugins that support the Android platform.
13:  */
14: @Keep
15: public final class GeneratedPluginRegistrant {
16:   private static final String TAG = "GeneratedPluginRegistrant";
17:   public static void registerWith(@NonNull FlutterEngine flutterEngine) {
18:     try {
19:       flutterEngine.getPlugins().add(new io.flutter.plugins.firebase.firestore.FlutterFirebaseFirestorePlugin());
20:     } catch (Exception e) {
21:       Log.e(TAG, "Error registering plugin cloud_firestore, io.flutter.plugins.firebase.firestore.FlutterFirebaseFirestorePlugin", e);
22:     }
23:     try {
24:       flutterEngine.getPlugins().add(new dev.fluttercommunity.plus.connectivity.ConnectivityPlugin());
25:     } catch (Exception e) {
26:       Log.e(TAG, "Error registering plugin connectivity_plus, dev.fluttercommunity.plus.connectivity.ConnectivityPlugin", e);
27:     }
28:     try {
29:       flutterEngine.getPlugins().add(new dev.fluttercommunity.plus.device_info.DeviceInfoPlusPlugin());
30:     } catch (Exception e) {
31:       Log.e(TAG, "Error registering plugin device_info_plus, dev.fluttercommunity.plus.device_info.DeviceInfoPlusPlugin", e);
32:     }
33:     try {
34:       flutterEngine.getPlugins().add(new io.flutter.plugins.firebase.appcheck.FlutterFirebaseAppCheckPlugin());
35:     } catch (Exception e) {
36:       Log.e(TAG, "Error registering plugin firebase_app_check, io.flutter.plugins.firebase.appcheck.FlutterFirebaseAppCheckPlugin", e);
37:     }
38:     try {
39:       flutterEngine.getPlugins().add(new io.flutter.plugins.firebase.auth.FlutterFirebaseAuthPlugin());
40:     } catch (Exception e) {
41:       Log.e(TAG, "Error registering plugin firebase_auth, io.flutter.plugins.firebase.auth.FlutterFirebaseAuthPlugin", e);
42:     }
43:     try {
44:       flutterEngine.getPlugins().add(new io.flutter.plugins.firebase.core.FlutterFirebaseCorePlugin());
45:     } catch (Exception e) {
46:       Log.e(TAG, "Error registering plugin firebase_core, io.flutter.plugins.firebase.core.FlutterFirebaseCorePlugin", e);
47:     }
48:     try {
49:       flutterEngine.getPlugins().add(new io.flutter.plugins.firebase.crashlytics.FlutterFirebaseCrashlyticsPlugin());
50:     } catch (Exception e) {
51:       Log.e(TAG, "Error registering plugin firebase_crashlytics, io.flutter.plugins.firebase.crashlytics.FlutterFirebaseCrashlyticsPlugin", e);
52:     }
53:     try {
54:       flutterEngine.getPlugins().add(new com.baseflow.googleapiavailability.GoogleApiAvailabilityPlugin());
55:     } catch (Exception e) {
56:       Log.e(TAG, "Error registering plugin google_api_availability_android, com.baseflow.googleapiavailability.GoogleApiAvailabilityPlugin", e);
57:     }
58:     try {
59:       flutterEngine.getPlugins().add(new io.flutter.plugins.googlesignin.GoogleSignInPlugin());
60:     } catch (Exception e) {
61:       Log.e(TAG, "Error registering plugin google_sign_in_android, io.flutter.plugins.googlesignin.GoogleSignInPlugin", e);
62:     }
63:     try {
64:       flutterEngine.getPlugins().add(new io.flutter.plugins.pathprovider.PathProviderPlugin());
65:     } catch (Exception e) {
66:       Log.e(TAG, "Error registering plugin path_provider_android, io.flutter.plugins.pathprovider.PathProviderPlugin", e);
67:     }
68:     try {
69:       flutterEngine.getPlugins().add(new dev.fluttercommunity.plus.share.SharePlusPlugin());
70:     } catch (Exception e) {
71:       Log.e(TAG, "Error registering plugin share_plus, dev.fluttercommunity.plus.share.SharePlusPlugin", e);
72:     }
73:     try {
74:       flutterEngine.getPlugins().add(new io.flutter.plugins.sharedpreferences.SharedPreferencesPlugin());
75:     } catch (Exception e) {
76:       Log.e(TAG, "Error registering plugin shared_preferences_android, io.flutter.plugins.sharedpreferences.SharedPreferencesPlugin", e);
77:     }
78:     try {
79:       flutterEngine.getPlugins().add(new com.tekartik.sqflite.SqflitePlugin());
80:     } catch (Exception e) {
81:       Log.e(TAG, "Error registering plugin sqflite_android, com.tekartik.sqflite.SqflitePlugin", e);
82:     }
83:     try {
84:       flutterEngine.getPlugins().add(new dev.fluttercommunity.workmanager.WorkmanagerPlugin());
85:     } catch (Exception e) {
86:       Log.e(TAG, "Error registering plugin workmanager, dev.fluttercommunity.workmanager.WorkmanagerPlugin", e);
87:     }
88:   }
89: }
</file>

<file path="android/app/src/main/kotlin/com/mrw1986/fftcg_companion_app/MainActivity.kt">
 1: package com.mrw1986.fftcg_companion_app
 2: 
 3: import android.os.Bundle
 4: import android.window.OnBackInvokedCallback
 5: import android.window.OnBackInvokedDispatcher
 6: import androidx.core.view.WindowCompat
 7: import io.flutter.embedding.android.FlutterActivity
 8: import io.flutter.embedding.engine.FlutterEngine
 9: import io.flutter.plugin.common.MethodChannel
10: 
11: class MainActivity: FlutterActivity() {
12:     private val CHANNEL = "com.mrw1986.fftcg_companion_app/back_handler"
13:     private var methodChannel: MethodChannel? = null
14: 
15:     override fun onCreate(savedInstanceState: Bundle?) {
16:         super.onCreate(savedInstanceState)
17:         WindowCompat.setDecorFitsSystemWindows(window, false)
18: 
19:         if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.TIRAMISU) {
20:             onBackInvokedDispatcher.registerOnBackInvokedCallback(
21:                 OnBackInvokedDispatcher.PRIORITY_DEFAULT
22:             ) {
23:                 methodChannel?.invokeMethod("handleBackPress", null)
24:             }
25:         }
26:     }
27: 
28:     override fun configureFlutterEngine(flutterEngine: FlutterEngine) {
29:         super.configureFlutterEngine(flutterEngine)
30:         
31:         methodChannel = MethodChannel(flutterEngine.dartExecutor.binaryMessenger, CHANNEL)
32:         methodChannel?.setMethodCallHandler { call, result ->
33:             when (call.method) {
34:                 "enablePredictiveBack" -> {
35:                     // Enable animations and other back gesture features
36:                     result.success(null)
37:                 }
38:                 else -> result.notImplemented()
39:             }
40:         }
41:     }
42: }
</file>

<file path="android/app/src/main/res/drawable-v21/launch_background.xml">
 1: <?xml version="1.0" encoding="utf-8"?>
 2: <!-- Modify this file to customize your launch splash screen -->
 3: <layer-list xmlns:android="http://schemas.android.com/apk/res/android">
 4:     <item android:drawable="?android:colorBackground" />
 5: 
 6:     <!-- You can insert your own image assets here -->
 7:     <!-- <item>
 8:         <bitmap
 9:             android:gravity="center"
10:             android:src="@mipmap/launch_image" />
11:     </item> -->
12: </layer-list>
</file>

<file path="android/app/src/main/res/drawable/launch_background.xml">
 1: <?xml version="1.0" encoding="utf-8"?>
 2: <!-- Modify this file to customize your launch splash screen -->
 3: <layer-list xmlns:android="http://schemas.android.com/apk/res/android">
 4:     <item android:drawable="@android:color/white" />
 5: 
 6:     <!-- You can insert your own image assets here -->
 7:     <!-- <item>
 8:         <bitmap
 9:             android:gravity="center"
10:             android:src="@mipmap/launch_image" />
11:     </item> -->
12: </layer-list>
</file>

<file path="android/app/src/main/res/mipmap-anydpi-v26/ic_launcher.xml">
1: <?xml version="1.0" encoding="utf-8"?>
2: <adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
3: </adaptive-icon>
</file>

<file path="android/app/src/main/res/values-night/styles.xml">
 1: <?xml version="1.0" encoding="utf-8"?>
 2: <resources>
 3:     <!-- Theme applied to the Android Window while the process is starting when the OS's Dark Mode setting is on -->
 4:     <style name="LaunchTheme" parent="@android:style/Theme.Black.NoTitleBar">
 5:         <!-- Show a splash screen on the activity. Automatically removed when
 6:              the Flutter engine draws its first frame -->
 7:         <item name="android:windowBackground">@drawable/launch_background</item>
 8:     </style>
 9:     <!-- Theme applied to the Android Window as soon as the process has started.
10:          This theme determines the color of the Android Window while your
11:          Flutter UI initializes, as well as behind your Flutter UI while its
12:          running.
13: 
14:          This Theme is only used starting with V2 of Flutter's Android embedding. -->
15:     <style name="NormalTheme" parent="@android:style/Theme.Black.NoTitleBar">
16:         <item name="android:windowBackground">?android:colorBackground</item>
17:     </style>
18: </resources>
</file>

<file path="android/app/src/main/res/values/styles.xml">
 1: <?xml version="1.0" encoding="utf-8"?>
 2: <resources>
 3:     <!-- Theme applied to the Android Window while the process is starting when the OS's Dark Mode setting is off -->
 4:     <style name="LaunchTheme" parent="@android:style/Theme.Light.NoTitleBar">
 5:         <!-- Show a splash screen on the activity. Automatically removed when
 6:              the Flutter engine draws its first frame -->
 7:         <item name="android:windowBackground">@drawable/launch_background</item>
 8:     </style>
 9:     <!-- Theme applied to the Android Window as soon as the process has started.
10:          This theme determines the color of the Android Window while your
11:          Flutter UI initializes, as well as behind your Flutter UI while its
12:          running.
13: 
14:          This Theme is only used starting with V2 of Flutter's Android embedding. -->
15:     <style name="NormalTheme" parent="@android:style/Theme.Light.NoTitleBar">
16:         <item name="android:windowBackground">?android:colorBackground</item>
17:     </style>
18: </resources>
</file>

<file path="android/app/src/main/res/xml/backup_rules.xml">
1: <?xml version="1.0" encoding="utf-8"?>
2: <full-backup-content>
3:     <exclude domain="sharedpref" path="WebView.xml"/>
4:     <exclude domain="database" path="google_app_measurement.db"/>
5:     <exclude domain="database" path="google_app_measurement_local.db"/>
6:     <exclude domain="root" path="gcm_key"/>
7:     <include domain="sharedpref" path="."/>
8:     <exclude domain="sharedpref" path="device.xml"/>
9: </full-backup-content>
</file>

<file path="android/app/src/main/res/xml/network_security_config.xml">
 1: <?xml version="1.0" encoding="utf-8"?>
 2: <network-security-config>
 3:     <debug-overrides>
 4:         <trust-anchors>
 5:             <certificates src="system" />
 6:             <certificates src="user" />
 7:         </trust-anchors>
 8:     </debug-overrides>
 9:     
10:     <base-config cleartextTrafficPermitted="false">
11:         <trust-anchors>
12:             <certificates src="system" />
13:         </trust-anchors>
14:     </base-config>
15:     
16:     <domain-config>
17:         <domain includeSubdomains="true">googleapis.com</domain>
18:         <domain includeSubdomains="true">firebaseio.com</domain>
19:         <domain includeSubdomains="true">firebaseappcheck.googleapis.com</domain>
20:         <domain includeSubdomains="true">firebase.googleapis.com</domain>
21:         <domain includeSubdomains="true">firestore.googleapis.com</domain>
22:         <domain includeSubdomains="true">google.com</domain>
23:         <trust-anchors>
24:             <certificates src="system" />
25:         </trust-anchors>
26:         <pin-set expiration="2025-12-31">
27:             <!-- Google's PKI -->
28:             <pin digest="SHA-256">YZPgTZ+woNCCCIW3LH2CxQeLzB/1m42QcCTBSdgayjs=</pin>
29:             <!-- Backup pin -->
30:             <pin digest="SHA-256">sx8gDxNyVB6VjzNvA0M9S1OKYk1cOiKjhGIQm8TZ4Cs=</pin>
31:         </pin-set>
32:     </domain-config>
33: </network-security-config>
</file>

<file path="android/app/src/profile/AndroidManifest.xml">
1: <manifest xmlns:android="http://schemas.android.com/apk/res/android">
2:     <!-- The INTERNET permission is required for development. Specifically,
3:          the Flutter tool needs it to communicate with the running application
4:          to allow setting breakpoints, to provide hot reload, etc.
5:     -->
6:     <uses-permission android:name="android.permission.INTERNET"/>
7: </manifest>
</file>

<file path="android/build.gradle">
 1: allprojects {
 2:     repositories {
 3:         google()
 4:         mavenCentral()
 5:     }
 6: }
 7: 
 8: rootProject.buildDir = '../build'
 9: subprojects {
10:     project.buildDir = "${rootProject.buildDir}/${project.name}"
11: }
12: subprojects {
13:     project.evaluationDependsOn(':app')
14: }
15: 
16: tasks.register("clean", Delete) {
17:     delete rootProject.buildDir
18: }
</file>

<file path="android/gradle.properties">
 1: # android/gradle.properties
 2: org.gradle.jvmargs=-Xmx4096m -XX:MaxMetaspaceSize=512m -XX:+HeapDumpOnOutOfMemoryError -Dfile.encoding=UTF-8
 3: org.gradle.parallel=true
 4: org.gradle.daemon=true
 5: org.gradle.caching=true
 6: android.useAndroidX=true
 7: android.enableJetifier=true
 8: android.nonTransitiveRClass=true
 9: android.nonFinalResIds=false
10: android.enableBuildConfigAsBytecode=true
</file>

<file path="android/gradle/wrapper/gradle-wrapper.properties">
1: distributionBase=GRADLE_USER_HOME
2: distributionPath=wrapper/dists
3: distributionUrl=https\://services.gradle.org/distributions/gradle-8.10.2-all.zip
4: networkTimeout=10000
5: validateDistributionUrl=true
6: zipStoreBase=GRADLE_USER_HOME
7: zipStorePath=wrapper/dists
</file>

<file path="android/settings.gradle">
 1: pluginManagement {
 2:     def flutterSdkPath = {
 3:         def properties = new Properties()
 4:         file("local.properties").withInputStream { properties.load(it) }
 5:         def flutterSdkPath = properties.getProperty("flutter.sdk")
 6:         assert flutterSdkPath != null, "flutter.sdk not set in local.properties"
 7:         return flutterSdkPath
 8:     }()
 9: 
10:     includeBuild("$flutterSdkPath/packages/flutter_tools/gradle")
11: 
12:     repositories {
13:         google()
14:         mavenCentral()
15:         gradlePluginPortal()
16:     }
17: }
18: 
19: plugins {
20:     id "dev.flutter.flutter-plugin-loader" version "1.0.0"
21:     id "com.android.application" version "8.7.0" apply false
22:     id "com.android.library" version "8.7.0" apply false
23:     id "org.jetbrains.kotlin.android" version "1.9.22" apply false
24:     id "com.google.gms.google-services" version "4.4.2" apply false
25:     id "com.google.firebase.crashlytics" version "2.9.9" apply false
26: }
27: 
28: dependencyResolutionManagement {
29:     repositoriesMode.set(RepositoriesMode.PREFER_PROJECT)
30:     repositories {
31:         google()
32:         mavenCentral()
33:     }
34: }
35: 
36: rootProject.name = "android"
37: include ":app"
</file>

<file path="firebase.json">
 1: {
 2:   "flutter": {
 3:     "platforms": {
 4:       "android": {
 5:         "default": {
 6:           "projectId": "fftcg-sync-service",
 7:           "appId": "1:161248420888:android:4e38e135739ad9427d4f6d",
 8:           "fileOutput": "android/app/google-services.json"
 9:         }
10:       },
11:       "dart": {
12:         "lib/firebase_options.dart": {
13:           "projectId": "fftcg-sync-service",
14:           "configurations": {
15:             "android": "1:161248420888:android:4e38e135739ad9427d4f6d",
16:             "ios": "1:161248420888:ios:69b3e0c02770910c7d4f6d"
17:           }
18:         }
19:       }
20:     }
21:   }
22: }
</file>

<file path="flutter_launcher_icons.yaml">
 1: # flutter pub run flutter_launcher_icons
 2: flutter_launcher_icons:
 3:   android: true
 4:   ios: true
 5:   image_path: "assets/icons/fftcg_card_icon.png"
 6:   min_sdk_android: 23  # Using the higher value from card yaml as it matches your app's actual minSdkVersion
 7:   remove_alpha_ios: true
 8:   background_color: "#1A1A1A"  # Dark background color from card yaml
 9:   
10:   # Disable generation for other platforms as they're not currently used
11:   web:
12:     generate: false
13:   windows:
14:     generate: false
15:   macos:
16:     generate: false
17:   linux:
18:     generate: false
</file>

<file path="lib/core/logging/talker_service.dart">
 1: import 'package:flutter/foundation.dart';
 2: import 'package:flutter_riverpod/flutter_riverpod.dart';
 3: import 'package:talker_flutter/talker_flutter.dart';
 4: import 'package:talker_riverpod_logger/talker_riverpod_logger.dart';
 5: 
 6: class TalkerService {
 7:   static final TalkerService _instance = TalkerService._internal();
 8:   late final Talker _talker;
 9: 
10:   Talker get talker => _talker;
11: 
12:   factory TalkerService() {
13:     return _instance;
14:   }
15: 
16:   TalkerService._internal() {
17:     _initialize();
18:   }
19: 
20:   void _initialize() {
21:     _talker = TalkerFlutter.init(
22:       settings: TalkerSettings(
23:         enabled: true,
24:         useConsoleLogs: true,
25:         maxHistoryItems: 1000,
26:         useHistory: true,
27:       ),
28:     );
29: 
30:     if (kDebugMode) {
31:       _talker.debug('Talker initialized in debug mode');
32:     }
33:   }
34: 
35:   void info(String message) => _talker.info(message);
36:   void warning(String message) => _talker.warning(message);
37:   void severe(String message, [Object? error, StackTrace? stackTrace]) {
38:     _talker.error(message, error, stackTrace);
39:   }
40: 
41:   void debug(String message) => _talker.debug(message);
42:   // Change success to info with a "[SUCCESS]" prefix
43:   void success(String message) => _talker.info('[SUCCESS] $message');
44: 
45:   void handle(Object error, [StackTrace? stack, String? message]) {
46:     _talker.handle(error, stack, message);
47:   }
48: 
49:   void exception(String message, Exception exception,
50:       [StackTrace? stackTrace]) {
51:     _talker.error(
52:         'Exception: $message', exception, stackTrace ?? StackTrace.current);
53:   }
54: 
55:   List<TalkerData> get history => _talker.history;
56: 
57:   Future<void> clearLogs() async {
58:     _talker.cleanHistory();
59:   }
60: 
61:   ProviderObserver get riverpodObserver =>
62:       TalkerRiverpodObserver(talker: _talker);
63: }
64: 
65: final talkerServiceProvider = Provider<TalkerService>((ref) {
66:   return TalkerService();
67: });
</file>

<file path="lib/core/models/sync_status.dart">
 1: import 'package:hive/hive.dart';
 2: 
 3: part 'sync_status.g.dart';
 4: 
 5: @HiveType(typeId: 0)
 6: enum SyncStatus {
 7:   @HiveField(0)
 8:   synced,
 9: 
10:   @HiveField(1)
11:   pending,
12: 
13:   @HiveField(2)
14:   error
15: }
</file>

<file path="lib/core/presentation/widgets/app_bar_widget.dart">
 1: // lib/core/presentation/widgets/app_bar_widget.dart
 2: import 'package:flutter/material.dart';
 3: 
 4: class CommonAppBar extends StatelessWidget implements PreferredSizeWidget {
 5:   final String title;
 6:   final List<Widget>? actions;
 7:   final PreferredSizeWidget? bottom;
 8: 
 9:   const CommonAppBar({
10:     super.key,
11:     required this.title,
12:     this.actions,
13:     this.bottom,
14:   });
15: 
16:   @override
17:   Widget build(BuildContext context) {
18:     return AppBar(
19:       title: Text(title),
20:       actions: actions,
21:       bottom: bottom,
22:     );
23:   }
24: 
25:   @override
26:   Size get preferredSize => Size.fromHeight(
27:         kToolbarHeight + (bottom?.preferredSize.height ?? 0.0),
28:       );
29: }
</file>

<file path="lib/core/providers/app_providers.dart">
  1: import 'package:firebase_core/firebase_core.dart';
  2: import 'package:flutter_riverpod/flutter_riverpod.dart';
  3: import '../logging/talker_service.dart';
  4: import '../services/connectivity_service.dart';
  5: import '../services/sync_service.dart';
  6: import '/firebase_options.dart';
  7: 
  8: final loggerProvider = Provider<TalkerService>((ref) {
  9:   return TalkerService();
 10: });
 11: 
 12: final initializationProvider = FutureProvider<bool>((ref) async {
 13:   final talker = ref.watch(loggerProvider);
 14: 
 15:   try {
 16:     talker.info('Initializing Firebase');
 17:     await Firebase.initializeApp(
 18:       options: DefaultFirebaseOptions.currentPlatform,
 19:     );
 20: 
 21:     talker.info('Performing initial sync');
 22:     await ref.read(syncServiceProvider).syncPendingChanges();
 23: 
 24:     talker.info('App initialization completed successfully');
 25:     return true;
 26:   } catch (e, stack) {
 27:     talker.severe('App initialization failed', e, stack);
 28:     return false;
 29:   }
 30: });
 31: 
 32: final connectivityStatusProvider = StreamProvider<bool>((ref) async* {
 33:   final logger = ref.watch(loggerProvider);
 34:   final connectivityService = ref.watch(connectivityServiceProvider);
 35:   
 36:   try {
 37:     await for (final status in connectivityService.connectivityStream) {
 38:       logger.info('Connectivity status changed: $status');
 39:       yield status;
 40:     }
 41:   } catch (e, stack) {
 42:     logger.severe('Error monitoring connectivity', e, stack);
 43:     yield false;
 44:   }
 45: });
 46: 
 47: final appStateProvider = StateNotifierProvider<AppStateNotifier, AppState>((ref) {
 48:   return AppStateNotifier(ref);
 49: });
 50: 
 51: class AppState {
 52:   final bool isInitialized;
 53:   final bool? _isOnline; // Make the field private
 54:   final String? error;
 55: 
 56:   const AppState({
 57:     this.isInitialized = false,
 58:     bool? isOnline, // Change parameter name
 59:     this.error,
 60:   }) : _isOnline = isOnline; // Initialize private field
 61: 
 62:   // Add a public getter
 63:   bool? get isOnline => _isOnline;
 64: 
 65:   AppState copyWith({
 66:     bool? isInitialized,
 67:     bool? isOnline,
 68:     String? error,
 69:   }) {
 70:     return AppState(
 71:       isInitialized: isInitialized ?? this.isInitialized,
 72:       isOnline: isOnline ?? _isOnline, // Use private field
 73:       error: error ?? this.error,
 74:     );
 75:   }
 76: }
 77: 
 78: class AppStateNotifier extends StateNotifier<AppState> {
 79:   final Ref _ref;
 80:   final TalkerService _logger;
 81: 
 82:   AppStateNotifier(this._ref)
 83:       : _logger = TalkerService(),
 84:         super(const AppState()) {
 85:     _initialize();
 86:   }
 87: 
 88:   Future<void> _initialize() async {
 89:     try {
 90:       final initializationStatus = await _ref.read(initializationProvider.future);
 91:       
 92:       if (!initializationStatus) {
 93:         state = state.copyWith(
 94:           error: 'Failed to initialize app',
 95:         );
 96:         return;
 97:       }
 98: 
 99:       // Start listening to connectivity
100:       _ref.listen(connectivityStatusProvider, (previous, next) {
101:         next.whenData((isOnline) {
102:           state = state.copyWith(isOnline: isOnline);
103:           if (isOnline) {
104:             _ref.read(syncServiceProvider).syncPendingChanges();
105:           }
106:         });
107:       });
108: 
109:       state = state.copyWith(
110:         isInitialized: true,
111:         error: null,
112:       );
113: 
114:       _logger.info('App state initialized successfully');
115:     } catch (e, stack) {
116:       _logger.severe('Error initializing app state', e, stack);
117:       state = state.copyWith(
118:         error: 'Failed to initialize app: ${e.toString()}',
119:       );
120:     }
121:   }
122: 
123:   Future<void> retryInitialization() async {
124:     state = const AppState();
125:     await _initialize();
126:   }
127: }
</file>

<file path="lib/core/providers/root_route_history_notifier.dart">
 1: import 'package:flutter_riverpod/flutter_riverpod.dart';
 2: 
 3: class RootRouteHistoryNotifier extends StateNotifier<List<int>> {
 4:   RootRouteHistoryNotifier() : super([0]);
 5: 
 6:   void addHistory(int index) {
 7:     // Only add to history if it's different from current
 8:     if (state.isEmpty || state.last != index) {
 9:       state = [...state, index];
10:     }
11:   }
12: 
13:   void removeLastHistory() {
14:     if (state.length > 1) {
15:       state = state.sublist(0, state.length - 1);
16:     }
17:   }
18: 
19:   void clearHistory() {
20:     state = [0];
21:   }
22: 
23:   int get currentIndex => state.last;
24:   bool get canGoBack => state.length > 1;
25: }
26: 
27: final rootRouteHistoryProvider =
28:     StateNotifierProvider<RootRouteHistoryNotifier, List<int>>(
29:         (ref) => RootRouteHistoryNotifier());
</file>

<file path="lib/core/routing/app_router.dart">
  1: // lib/core/routing/app_router.dart
  2: 
  3: import 'package:flutter/material.dart';
  4: import 'package:go_router/go_router.dart';
  5: import 'package:flutter_riverpod/flutter_riverpod.dart';
  6: import 'package:talker_flutter/talker_flutter.dart';
  7: import '../../features/auth/presentation/auth_wrapper.dart';
  8: import '../../features/auth/presentation/screens/login_screen.dart';
  9: import '../../features/auth/presentation/screens/registration_screen.dart';
 10: import '../../features/cards/presentation/screens/cards_screen.dart';
 11: import '../../features/cards/presentation/screens/card_detail_screen.dart';
 12: import '../../features/collection/presentation/screens/collection_screen.dart';
 13: import '../../features/decks/presentation/screens/decks_screen.dart';
 14: import '../../features/scanner/presentation/screens/scanner_screen.dart';
 15: import '../../features/profile/presentation/screens/profile_screen.dart';
 16: import '../../features/settings/presentation/screens/settings_screen.dart';
 17: import '../../features/auth/providers/auth_providers.dart';
 18: import '../../features/auth/enums/auth_status.dart';
 19: import '../../features/cards/models/fftcg_card.dart';
 20: import '../../features/settings/providers/settings_providers.dart';
 21: import '../logging/talker_service.dart';
 22: 
 23: final _rootNavigatorKey = GlobalKey<NavigatorState>(debugLabel: 'root');
 24: final _shellNavigatorKey = GlobalKey<NavigatorState>(debugLabel: 'shell');
 25: 
 26: class NavigationDestinationItem {
 27:   final Key key;
 28:   final Widget icon;
 29:   final Widget? selectedIcon;
 30:   final String label;
 31: 
 32:   const NavigationDestinationItem({
 33:     required this.key,
 34:     required this.icon,
 35:     this.selectedIcon,
 36:     required this.label,
 37:   });
 38: 
 39:   NavigationDestination toNavigationDestination() {
 40:     return NavigationDestination(
 41:       key: key,
 42:       icon: icon,
 43:       selectedIcon: selectedIcon ?? icon,
 44:       label: label,
 45:     );
 46:   }
 47: }
 48: 
 49: class ScaffoldWithNavBar extends ConsumerWidget {
 50:   final Widget child;
 51: 
 52:   const ScaffoldWithNavBar({
 53:     super.key,
 54:     required this.child,
 55:   });
 56: 
 57:   static const List<NavigationDestinationItem> _destinations = [
 58:     NavigationDestinationItem(
 59:       key: Key('nav_cards'), // Changed from ValueKey('cards')
 60:       icon: Icon(Icons.grid_view),
 61:       label: 'Cards',
 62:     ),
 63:     NavigationDestinationItem(
 64:       key: Key('nav_collection'), // Changed from ValueKey('collection')
 65:       icon: Icon(Icons.collections_bookmark),
 66:       label: 'Collection',
 67:     ),
 68:     NavigationDestinationItem(
 69:       key: Key('nav_decks'), // Changed from ValueKey('decks')
 70:       icon: Icon(Icons.style),
 71:       label: 'Decks',
 72:     ),
 73:     NavigationDestinationItem(
 74:       key: Key('nav_scanner'), // Changed from ValueKey('scanner')
 75:       icon: Icon(Icons.camera_alt),
 76:       label: 'Scanner',
 77:     ),
 78:     NavigationDestinationItem(
 79:       key: Key('nav_profile'), // Changed from ValueKey('profile')
 80:       icon: Icon(Icons.person),
 81:       label: 'Profile',
 82:     ),
 83:   ];
 84: 
 85:   Widget _getTitle(BuildContext context) {
 86:     final location = GoRouterState.of(context).uri.path;
 87:     switch (location) {
 88:       case '/':
 89:         return const Text('Cards');
 90:       case '/collection':
 91:         return const Text('Collection');
 92:       case '/decks':
 93:         return const Text('Decks');
 94:       case '/scanner':
 95:         return const Text('Scanner');
 96:       case '/profile':
 97:         return const Text('Profile');
 98:       case '/settings':
 99:         return const Text('Settings');
100:       default:
101:         return const Text('FFTCG Companion');
102:     }
103:   }
104: 
105:   @override
106:   Widget build(BuildContext context, WidgetRef ref) {
107:     final location = GoRouterState.of(context).uri.path;
108:     final themeColor = ref.watch(themeColorProvider);
109:     final isSettingsScreen = location == '/settings';
110: 
111:     final hideSettings = [
112:       '/settings/logs',
113:       '/auth/link',
114:     ].any((path) => location.startsWith(path));
115: 
116:     final isDeepLinkedScreen = location.startsWith('/settings/logs') ||
117:         location.startsWith('/auth/link');
118: 
119:     String getRootRoute() {
120:       final selectedIndex = _calculateSelectedIndex(context);
121:       switch (selectedIndex) {
122:         case 0:
123:           return '/';
124:         case 1:
125:           return '/collection';
126:         case 2:
127:           return '/decks';
128:         case 3:
129:           return '/scanner';
130:         case 4:
131:           return '/profile';
132:         default:
133:           return '/';
134:       }
135:     }
136: 
137:     return Scaffold(
138:       appBar: AppBar(
139:         title: _getTitle(context),
140:         actions: [
141:           if (!hideSettings && !isSettingsScreen)
142:             IconButton(
143:               icon: const Icon(Icons.settings),
144:               onPressed: () => context.push('/settings'),
145:             ),
146:           if (isSettingsScreen || isDeepLinkedScreen)
147:             IconButton(
148:               icon: const Icon(Icons.close),
149:               onPressed: () => context.go(getRootRoute()),
150:             ),
151:         ],
152:       ),
153:       body: child,
154:       bottomNavigationBar: NavigationBar(
155:         backgroundColor: Theme.of(context).brightness == Brightness.dark
156:             ? Color.alphaBlend(
157:                 themeColor.withAlpha(26), Theme.of(context).colorScheme.surface)
158:             : Theme.of(context).colorScheme.surface,
159:         indicatorColor: themeColor.withAlpha(128),
160:         destinations: _destinations
161:             .map((item) => item.toNavigationDestination())
162:             .toList(),
163:         selectedIndex: _calculateSelectedIndex(context),
164:         onDestinationSelected: (index) => _onItemTapped(index, context),
165:       ),
166:     );
167:   }
168: 
169:   static int _calculateSelectedIndex(BuildContext context) {
170:     final location = GoRouterState.of(context).uri.path;
171: 
172:     if (location == '/settings') {
173:       final router = GoRouter.of(context);
174:       final routes = router.routerDelegate.currentConfiguration.matches;
175: 
176:       for (var i = routes.length - 1; i >= 0; i--) {
177:         final route = routes[i].matchedLocation;
178:         if (route != '/settings') {
179:           return _getIndexForLocation(route);
180:         }
181:       }
182:     }
183: 
184:     return _getIndexForLocation(location);
185:   }
186: 
187:   static int _getIndexForLocation(String location) {
188:     if (location == '/') return 0;
189:     if (location.startsWith('/collection')) return 1;
190:     if (location.startsWith('/decks')) return 2;
191:     if (location.startsWith('/scanner')) return 3;
192:     if (location.startsWith('/profile')) return 4;
193:     return 0;
194:   }
195: 
196:   void _onItemTapped(int index, BuildContext context) {
197:     final location = GoRouterState.of(context).uri.path;
198: 
199:     if (location == '/settings') {
200:       context.pop();
201:     }
202: 
203:     switch (index) {
204:       case 0:
205:         context.go('/');
206:         break;
207:       case 1:
208:         context.go('/collection');
209:         break;
210:       case 2:
211:         context.go('/decks');
212:         break;
213:       case 3:
214:         context.go('/scanner');
215:         break;
216:       case 4:
217:         context.go('/profile');
218:         break;
219:     }
220:   }
221: }
222: 
223: final routerProvider = Provider<GoRouter>((ref) {
224:   final authState = ref.watch(authNotifierProvider);
225:   final talker = ref.watch(talkerServiceProvider);
226: 
227:   return GoRouter(
228:     navigatorKey: _rootNavigatorKey,
229:     initialLocation: '/',
230:     debugLogDiagnostics: true,
231:     observers: [TalkerRouteObserver(talker.talker)],
232:     redirect: (context, state) {
233:       final isAuthenticated = authState.status == AuthStatus.authenticated ||
234:           authState.status == AuthStatus.guest;
235:       final isAuthRoute = state.matchedLocation.startsWith('/auth/');
236: 
237:       if (!isAuthenticated && !isAuthRoute) {
238:         return '/auth/login';
239:       }
240: 
241:       if (isAuthenticated && isAuthRoute) {
242:         return '/';
243:       }
244: 
245:       return null;
246:     },
247:     routes: [
248:       // Auth routes with fade transition
249:       GoRoute(
250:         path: '/auth/login',
251:         name: 'login',
252:         pageBuilder: (context, state) => CustomTransitionPage(
253:           key: state.pageKey,
254:           child: const LoginScreen(),
255:           transitionDuration: const Duration(milliseconds: 200),
256:           reverseTransitionDuration: const Duration(milliseconds: 200),
257:           transitionsBuilder: (context, animation, secondaryAnimation, child) {
258:             return FadeTransition(opacity: animation, child: child);
259:           },
260:         ),
261:       ),
262:       GoRoute(
263:         path: '/auth/register',
264:         name: 'register',
265:         pageBuilder: (context, state) => CustomTransitionPage(
266:           key: state.pageKey,
267:           child: const RegistrationScreen(),
268:           transitionDuration: const Duration(milliseconds: 200),
269:           reverseTransitionDuration: const Duration(milliseconds: 200),
270:           transitionsBuilder: (context, animation, secondaryAnimation, child) {
271:             return FadeTransition(opacity: animation, child: child);
272:           },
273:         ),
274:       ),
275: 
276:       // Main app shell
277:       ShellRoute(
278:         navigatorKey: _shellNavigatorKey,
279:         builder: (context, state, child) {
280:           return AuthWrapper(
281:             child: ScaffoldWithNavBar(child: child),
282:           );
283:         },
284:         routes: [
285:           GoRoute(
286:             path: '/',
287:             name: 'home',
288:             pageBuilder: (context, state) => CustomTransitionPage(
289:               key: state.pageKey,
290:               child: const CardsScreen(),
291:               transitionDuration: const Duration(milliseconds: 200),
292:               reverseTransitionDuration: const Duration(milliseconds: 200),
293:               transitionsBuilder:
294:                   (context, animation, secondaryAnimation, child) {
295:                 return SlideTransition(
296:                   position: animation.drive(
297:                     Tween(
298:                       begin: const Offset(1.0, 0.0),
299:                       end: Offset.zero,
300:                     ).chain(CurveTween(curve: Curves.easeOut)),
301:                   ),
302:                   child: child,
303:                 );
304:               },
305:             ),
306:             routes: [
307:               GoRoute(
308:                 path: 'card/:cardId',
309:                 name: 'cardDetail',
310:                 pageBuilder: (context, state) {
311:                   final card = state.extra as FFTCGCard?;
312:                   return CustomTransitionPage(
313:                     key: state.pageKey,
314:                     child: card != null
315:                         ? CardDetailScreen(card: card)
316:                         : const Scaffold(
317:                             body: Center(child: Text('Card not found')),
318:                           ),
319:                     transitionDuration: const Duration(milliseconds: 200),
320:                     reverseTransitionDuration:
321:                         const Duration(milliseconds: 200),
322:                     transitionsBuilder:
323:                         (context, animation, secondaryAnimation, child) {
324:                       return FadeTransition(
325:                         opacity: animation,
326:                         child: ScaleTransition(
327:                           scale: animation.drive(
328:                             Tween(begin: 0.95, end: 1.0)
329:                                 .chain(CurveTween(curve: Curves.easeOutCubic)),
330:                           ),
331:                           child: child,
332:                         ),
333:                       );
334:                     },
335:                   );
336:                 },
337:               ),
338:             ],
339:           ),
340:           GoRoute(
341:             path: '/collection',
342:             name: 'collection',
343:             pageBuilder: (context, state) => CustomTransitionPage(
344:               key: state.pageKey,
345:               child: const CollectionScreen(),
346:               transitionDuration: const Duration(milliseconds: 200),
347:               reverseTransitionDuration: const Duration(milliseconds: 200),
348:               transitionsBuilder:
349:                   (context, animation, secondaryAnimation, child) {
350:                 return SlideTransition(
351:                   position: animation.drive(
352:                     Tween(
353:                       begin: const Offset(1.0, 0.0),
354:                       end: Offset.zero,
355:                     ).chain(CurveTween(curve: Curves.easeOut)),
356:                   ),
357:                   child: child,
358:                 );
359:               },
360:             ),
361:           ),
362:           GoRoute(
363:             path: '/decks',
364:             name: 'decks',
365:             pageBuilder: (context, state) => CustomTransitionPage(
366:               key: state.pageKey,
367:               child: const DecksScreen(),
368:               transitionDuration: const Duration(milliseconds: 200),
369:               reverseTransitionDuration: const Duration(milliseconds: 200),
370:               transitionsBuilder:
371:                   (context, animation, secondaryAnimation, child) {
372:                 return SlideTransition(
373:                   position: animation.drive(
374:                     Tween(
375:                       begin: const Offset(1.0, 0.0),
376:                       end: Offset.zero,
377:                     ).chain(CurveTween(curve: Curves.easeOut)),
378:                   ),
379:                   child: child,
380:                 );
381:               },
382:             ),
383:           ),
384:           GoRoute(
385:             path: '/scanner',
386:             name: 'scanner',
387:             pageBuilder: (context, state) => CustomTransitionPage(
388:               key: state.pageKey,
389:               child: const ScannerScreen(),
390:               transitionDuration: const Duration(milliseconds: 200),
391:               reverseTransitionDuration: const Duration(milliseconds: 200),
392:               transitionsBuilder:
393:                   (context, animation, secondaryAnimation, child) {
394:                 return SlideTransition(
395:                   position: animation.drive(
396:                     Tween(
397:                       begin: const Offset(1.0, 0.0),
398:                       end: Offset.zero,
399:                     ).chain(CurveTween(curve: Curves.easeOut)),
400:                   ),
401:                   child: child,
402:                 );
403:               },
404:             ),
405:           ),
406:           GoRoute(
407:             path: '/profile',
408:             name: 'profile',
409:             pageBuilder: (context, state) => CustomTransitionPage(
410:               key: state.pageKey,
411:               child: ProfileScreen(
412:                 handleLogout: () async {
413:                   await ref.read(authNotifierProvider.notifier).signOut();
414:                   if (context.mounted) {
415:                     context.go('/auth/login');
416:                   }
417:                 },
418:               ),
419:               transitionDuration: const Duration(milliseconds: 200),
420:               reverseTransitionDuration: const Duration(milliseconds: 200),
421:               transitionsBuilder:
422:                   (context, animation, secondaryAnimation, child) {
423:                 return SlideTransition(
424:                   position: animation.drive(
425:                     Tween(
426:                       begin: const Offset(1.0, 0.0),
427:                       end: Offset.zero,
428:                     ).chain(CurveTween(curve: Curves.easeOut)),
429:                   ),
430:                   child: child,
431:                 );
432:               },
433:             ),
434:           ),
435:           GoRoute(
436:             path: '/settings',
437:             name: 'settings',
438:             pageBuilder: (context, state) => CustomTransitionPage(
439:               key: state.pageKey,
440:               child: SettingsScreen(
441:                 handleLogout: () async {
442:                   await ref.read(authNotifierProvider.notifier).signOut();
443:                   if (context.mounted) {
444:                     context.go('/auth/login');
445:                   }
446:                 },
447:               ),
448:               transitionDuration: const Duration(milliseconds: 300),
449:               reverseTransitionDuration: const Duration(milliseconds: 300),
450:               transitionsBuilder:
451:                   (context, animation, secondaryAnimation, child) {
452:                 return SlideTransition(
453:                   position: animation.drive(
454:                     Tween(
455:                       begin: const Offset(0.0, 1.0),
456:                       end: Offset.zero,
457:                     ).chain(CurveTween(curve: Curves.easeOut)),
458:                   ),
459:                   child: child,
460:                 );
461:               },
462:             ),
463:           ),
464:         ],
465:       ),
466:     ],
467:     errorBuilder: (context, state) => Scaffold(
468:       body: Center(
469:         child: Text('Error: ${state.error}'),
470:       ),
471:     ),
472:   );
473: });
</file>

<file path="lib/core/services/background_sync_service.dart">
  1: // lib/core/services/background_sync_service.dart
  2: 
  3: import 'package:workmanager/workmanager.dart';
  4: import '../logging/talker_service.dart';
  5: import 'sync_service.dart';
  6: import 'package:flutter_riverpod/flutter_riverpod.dart';
  7: 
  8: const backgroundSyncTask = 'backgroundSync';
  9: const periodicSyncTask = 'periodicSync';
 10: 
 11: @pragma('vm:entry-point')
 12: void callbackDispatcher() {
 13:   Workmanager().executeTask((task, inputData) async {
 14:     final talker = TalkerService();
 15:     try {
 16:       switch (task) {
 17:         case backgroundSyncTask:
 18:           final container = ProviderContainer();
 19:           final syncService = container.read(syncServiceProvider);
 20:           await syncService.syncPendingChanges();
 21:           break;
 22:         case periodicSyncTask:
 23:           final container = ProviderContainer();
 24:           final syncService = container.read(syncServiceProvider);
 25:           await syncService.syncPendingChanges();
 26:           break;
 27:       }
 28:       return true;
 29:     } catch (e, stackTrace) {
 30:       talker.severe('Background sync failed', e, stackTrace);
 31:       return false;
 32:     }
 33:   });
 34: }
 35: 
 36: class BackgroundSyncService {
 37:   final TalkerService _talker;
 38:   static const Duration _minimumSyncInterval = Duration(minutes: 15);
 39:   static const Duration _periodicSyncInterval = Duration(hours: 1);
 40: 
 41:   BackgroundSyncService({TalkerService? talker})
 42:       : _talker = talker ?? TalkerService();
 43: 
 44:   Future<void> initialize() async {
 45:     try {
 46:       await Workmanager().initialize(
 47:         callbackDispatcher,
 48:         isInDebugMode: false,
 49:       );
 50:       _talker.info('Background sync service initialized');
 51:     } catch (e, stackTrace) {
 52:       _talker.severe('Failed to initialize background sync', e, stackTrace);
 53:       rethrow;
 54:     }
 55:   }
 56: 
 57:   Future<void> scheduleSync({bool force = false}) async {
 58:     try {
 59:       await Workmanager().registerOneOffTask(
 60:         backgroundSyncTask,
 61:         backgroundSyncTask,
 62:         initialDelay: force ? Duration.zero : _minimumSyncInterval,
 63:         constraints: Constraints(
 64:           networkType: NetworkType.connected,
 65:           requiresBatteryNotLow: true,
 66:         ),
 67:         existingWorkPolicy: ExistingWorkPolicy.replace,
 68:       );
 69:       _talker.info('Background sync scheduled');
 70:     } catch (e, stackTrace) {
 71:       _talker.severe('Failed to schedule background sync', e, stackTrace);
 72:       rethrow;
 73:     }
 74:   }
 75: 
 76:   Future<void> enablePeriodicSync() async {
 77:     try {
 78:       await Workmanager().registerPeriodicTask(
 79:         periodicSyncTask,
 80:         periodicSyncTask,
 81:         frequency: _periodicSyncInterval,
 82:         constraints: Constraints(
 83:           networkType: NetworkType.connected,
 84:           requiresBatteryNotLow: true,
 85:         ),
 86:         existingWorkPolicy: ExistingWorkPolicy.keep,
 87:       );
 88:       _talker.info('Periodic sync enabled');
 89:     } catch (e, stackTrace) {
 90:       _talker.severe('Failed to enable periodic sync', e, stackTrace);
 91:       rethrow;
 92:     }
 93:   }
 94: 
 95:   Future<void> disablePeriodicSync() async {
 96:     try {
 97:       await Workmanager().cancelByUniqueName(periodicSyncTask);
 98:       _talker.info('Periodic sync disabled');
 99:     } catch (e, stackTrace) {
100:       _talker.severe('Failed to disable periodic sync', e, stackTrace);
101:       rethrow;
102:     }
103:   }
104: 
105:   Future<void> cancelAllSync() async {
106:     try {
107:       await Workmanager().cancelAll();
108:       _talker.info('All sync tasks cancelled');
109:     } catch (e, stackTrace) {
110:       _talker.severe('Failed to cancel sync tasks', e, stackTrace);
111:       rethrow;
112:     }
113:   }
114: }
115: 
116: // Provider
117: final backgroundSyncServiceProvider = Provider<BackgroundSyncService>((ref) {
118:   return BackgroundSyncService();
119: });
</file>

<file path="lib/core/services/connectivity_service.dart">
  1: import 'dart:async';
  2: import 'package:connectivity_plus/connectivity_plus.dart';
  3: import 'package:internet_connection_checker/internet_connection_checker.dart';
  4: import 'package:flutter_riverpod/flutter_riverpod.dart';
  5: import '../logging/talker_service.dart';
  6: 
  7: final connectivityServiceProvider = Provider<ConnectivityService>((ref) {
  8:   return ConnectivityService();
  9: });
 10: 
 11: class ConnectivityService {
 12:   final Connectivity _connectivity = Connectivity();
 13:   InternetConnectionChecker _connectionChecker = InternetConnectionChecker();
 14:   final TalkerService _talker = TalkerService();
 15: 
 16:   final _connectivityController = StreamController<bool>.broadcast();
 17:   bool _lastKnownStatus = false;
 18: 
 19:   ConnectivityService() {
 20:     _initializeConnectivityStream();
 21:   }
 22: 
 23:   void _initializeConnectivityStream() {
 24:     _connectivity.onConnectivityChanged.listen((result) async {
 25:       await _checkAndUpdateConnectivity(result);
 26:     });
 27: 
 28:     _connectivity.checkConnectivity().then((result) async {
 29:       await _checkAndUpdateConnectivity(result);
 30:     });
 31:   }
 32: 
 33:   Future<void> _checkAndUpdateConnectivity(
 34:       List<ConnectivityResult> results) async {
 35:     try {
 36:       bool hasConnection = false;
 37: 
 38:       if (!results.contains(ConnectivityResult.none)) {
 39:         hasConnection = await _connectionChecker.hasConnection;
 40:       }
 41: 
 42:       if (hasConnection != _lastKnownStatus) {
 43:         _lastKnownStatus = hasConnection;
 44:         _connectivityController.add(hasConnection);
 45:         _talker.info(
 46:             'Connectivity status changed: ${hasConnection ? 'online' : 'offline'}');
 47:       }
 48:     } catch (e, stackTrace) {
 49:       _talker.severe('Error checking connectivity', e, stackTrace);
 50:       if (_lastKnownStatus) {
 51:         _lastKnownStatus = false;
 52:         _connectivityController.add(false);
 53:       }
 54:     }
 55:   }
 56: 
 57:   /// Stream of connectivity status changes
 58:   Stream<bool> get connectivityStream => _connectivityController.stream;
 59: 
 60:   /// Current connectivity status
 61:   Future<bool> get isConnected async {
 62:     try {
 63:       final results = await _connectivity.checkConnectivity();
 64:       if (results.contains(ConnectivityResult.none)) {
 65:         return false;
 66:       }
 67:       return await _connectionChecker.hasConnection;
 68:     } catch (e, stackTrace) {
 69:       _talker.severe('Error checking current connectivity', e, stackTrace);
 70:       return false;
 71:     }
 72:   }
 73: 
 74:   /// Check if we have a stable connection
 75:   Future<bool> hasStableConnection() async {
 76:     try {
 77:       // Check internet connection
 78:       final hasConnection = await _connectionChecker.hasConnection;
 79:       if (!hasConnection) return false;
 80: 
 81:       // Check specific host reachability
 82:       final hostReachable = await _connectionChecker.isHostReachable(
 83:         AddressCheckOptions(
 84:           hostname: 'google.com',
 85:           port: 443,
 86:           timeout: const Duration(seconds: 3),
 87:         ),
 88:       );
 89: 
 90:       return hostReachable.isSuccess;
 91:     } catch (e, stackTrace) {
 92:       _talker.severe('Error checking stable connection', e, stackTrace);
 93:       return false;
 94:     }
 95:   }
 96: 
 97:   /// Configuration for connection checker
 98:   Future<void> configureConnectionChecker({
 99:     Duration? checkInterval,
100:     Duration? timeout,
101:     List<AddressCheckOptions>? addresses,
102:   }) async {
103:     try {
104:       if (checkInterval != null || timeout != null || addresses != null) {
105:         // Create a new instance with updated configuration
106:         _connectionChecker = InternetConnectionChecker.createInstance(
107:           checkInterval: checkInterval ?? _connectionChecker.checkInterval,
108:           checkTimeout: timeout ?? _connectionChecker.checkTimeout,
109:           addresses: addresses ?? _connectionChecker.addresses,
110:         );
111:         _talker.info('Connection checker configured successfully');
112:       }
113:     } catch (e, stackTrace) {
114:       _talker.severe('Error configuring connection checker', e, stackTrace);
115:     }
116:   }
117: 
118:   /// Get detailed connection status
119:   Future<ConnectionStatus> getDetailedConnectionStatus() async {
120:     try {
121:       final results = await _connectivity.checkConnectivity();
122:       final hasConnection = await _connectionChecker.hasConnection;
123: 
124:       return ConnectionStatus(
125:         isConnected: hasConnection,
126:         connectionTypes: results,
127:         lastChecked: DateTime.now(),
128:       );
129:     } catch (e, stackTrace) {
130:       _talker.severe('Error getting detailed connection status', e, stackTrace);
131:       return ConnectionStatus(
132:         isConnected: false,
133:         connectionTypes: [],
134:         lastChecked: DateTime.now(),
135:         error: e.toString(),
136:       );
137:     }
138:   }
139: 
140:   void dispose() {
141:     _connectivityController.close();
142:   }
143: }
144: 
145: class ConnectionStatus {
146:   final bool isConnected;
147:   final List<ConnectivityResult> connectionTypes;
148:   final DateTime lastChecked;
149:   final String? error;
150: 
151:   ConnectionStatus({
152:     required this.isConnected,
153:     required this.connectionTypes,
154:     required this.lastChecked,
155:     this.error,
156:   });
157: 
158:   bool get hasWifi => connectionTypes.contains(ConnectivityResult.wifi);
159:   bool get hasMobile => connectionTypes.contains(ConnectivityResult.mobile);
160:   bool get hasEthernet => connectionTypes.contains(ConnectivityResult.ethernet);
161:   bool get hasVPN => connectionTypes.contains(ConnectivityResult.vpn);
162:   bool get hasError => error != null;
163: 
164:   @override
165:   String toString() {
166:     return 'ConnectionStatus(isConnected: $isConnected, types: $connectionTypes, lastChecked: $lastChecked, error: $error)';
167:   }
168: }
169: 
170: // Provider for detailed connection status
171: final connectionStatusProvider = StreamProvider<ConnectionStatus>((ref) async* {
172:   final connectivityService = ref.watch(connectivityServiceProvider);
173: 
174:   // Initial status
175:   yield await connectivityService.getDetailedConnectionStatus();
176: 
177:   // Stream of updates
178:   await for (final _ in connectivityService.connectivityStream) {
179:     yield await connectivityService.getDetailedConnectionStatus();
180:   }
181: });
182: 
183: // Provider for simple connection status
184: final isConnectedProvider = StreamProvider<bool>((ref) {
185:   final connectivityService = ref.watch(connectivityServiceProvider);
186:   return connectivityService.connectivityStream;
187: });
</file>

<file path="lib/core/services/hive_service.dart">
  1: // lib/core/services/hive_service.dart
  2: 
  3: import 'package:hive_flutter/hive_flutter.dart';
  4: import '../logging/talker_service.dart';
  5: import '../../features/cards/models/fftcg_card.dart';
  6: import '../../features/cards/models/card_extended_data.dart';
  7: import '../../features/cards/models/card_image_metadata.dart';
  8: import '../models/sync_status.dart';
  9: 
 10: class HiveService {
 11:   static const String cardsBoxName = 'cards';
 12:   static const String userBoxName = 'user';
 13:   static const String syncStatusBoxName = 'sync_status';
 14: 
 15:   final TalkerService _talker;
 16:   bool _isInitialized = false;
 17: 
 18:   // Add public getter for initialization state
 19:   bool get isInitialized => _isInitialized;
 20: 
 21:   HiveService({TalkerService? talker}) : _talker = talker ?? TalkerService();
 22: 
 23:   Future<void> initialize() async {
 24:     if (_isInitialized) {
 25:       _talker.info('Hive already initialized');
 26:       return;
 27:     }
 28: 
 29:     try {
 30:       await Hive.initFlutter();
 31: 
 32:       // Register adapters if not already registered
 33:       if (!Hive.isAdapterRegistered(0)) {
 34:         Hive.registerAdapter(SyncStatusAdapter());
 35:       }
 36:       if (!Hive.isAdapterRegistered(1)) {
 37:         Hive.registerAdapter(FFTCGCardAdapter());
 38:       }
 39:       if (!Hive.isAdapterRegistered(2)) {
 40:         Hive.registerAdapter(CardExtendedDataAdapter());
 41:       }
 42:       if (!Hive.isAdapterRegistered(3)) {
 43:         Hive.registerAdapter(CardImageMetadataAdapter());
 44:       }
 45: 
 46:       // Open boxes with retry logic
 47:       await _openBoxesWithRetry();
 48: 
 49:       _isInitialized = true;
 50:       _talker.info('Hive initialized successfully');
 51:     } catch (e, stackTrace) {
 52:       _talker.severe('Failed to initialize Hive', e, stackTrace);
 53:       _isInitialized = false;
 54:       rethrow;
 55:     }
 56:   }
 57: 
 58:   Future<void> _openBoxesWithRetry({int maxRetries = 3}) async {
 59:     int attempts = 0;
 60:     while (attempts < maxRetries) {
 61:       try {
 62:         await Future.wait([
 63:           Hive.openBox<FFTCGCard>(cardsBoxName),
 64:           Hive.openBox(userBoxName),
 65:           Hive.openBox(syncStatusBoxName),
 66:         ]);
 67:         return;
 68:       } catch (e) {
 69:         attempts++;
 70:         if (attempts >= maxRetries) {
 71:           rethrow;
 72:         }
 73:         _talker
 74:             .warning('Retrying box opening attempt $attempts of $maxRetries');
 75:         await Future.delayed(Duration(milliseconds: 500 * attempts));
 76:       }
 77:     }
 78:   }
 79: 
 80:   Future<void> closeBoxes() async {
 81:     if (!_isInitialized) return;
 82: 
 83:     try {
 84:       await Future.wait([
 85:         Hive.box<FFTCGCard>(cardsBoxName).close(),
 86:         Hive.box(userBoxName).close(),
 87:         Hive.box(syncStatusBoxName).close(),
 88:       ]);
 89:       _isInitialized = false;
 90:       _talker.info('Hive boxes closed successfully');
 91:     } catch (e, stackTrace) {
 92:       _talker.severe('Error closing Hive boxes', e, stackTrace);
 93:       rethrow;
 94:     }
 95:   }
 96: 
 97:   Box<FFTCGCard> getCardsBox() {
 98:     _verifyInitialization();
 99:     return Hive.box<FFTCGCard>(cardsBoxName);
100:   }
101: 
102:   Box getUserBox() {
103:     _verifyInitialization();
104:     return Hive.box(userBoxName);
105:   }
106: 
107:   Box getSyncStatusBox() {
108:     _verifyInitialization();
109:     return Hive.box(syncStatusBoxName);
110:   }
111: 
112:   void _verifyInitialization() {
113:     if (!_isInitialized) {
114:       _talker.severe('Attempting to access Hive before initialization');
115:       throw StateError('HiveService must be initialized before use');
116:     }
117:   }
118: 
119:   Future<void> clearAll() async {
120:     _verifyInitialization();
121:     try {
122:       await Future.wait([
123:         getCardsBox().clear(),
124:         getUserBox().clear(),
125:         getSyncStatusBox().clear(),
126:       ]);
127:       _talker.info('All Hive boxes cleared successfully');
128:     } catch (e, stackTrace) {
129:       _talker.severe('Error clearing Hive boxes', e, stackTrace);
130:       rethrow;
131:     }
132:   }
133: 
134:   Future<void> deleteBoxes() async {
135:     try {
136:       await closeBoxes();
137:       await Future.wait([
138:         Hive.deleteBoxFromDisk(cardsBoxName),
139:         Hive.deleteBoxFromDisk(userBoxName),
140:         Hive.deleteBoxFromDisk(syncStatusBoxName),
141:       ]);
142:       _talker.info('All Hive boxes deleted successfully');
143:     } catch (e, stackTrace) {
144:       _talker.severe('Error deleting Hive boxes', e, stackTrace);
145:       rethrow;
146:     }
147:   }
148: 
149:   Future<void> saveCard(FFTCGCard card) async {
150:     _verifyInitialization();
151:     try {
152:       final box = getCardsBox();
153:       await box.put(card.cardNumber, card);
154:       _talker.info('Card saved successfully: ${card.cardNumber}');
155:     } catch (e, stackTrace) {
156:       _talker.severe('Error saving card', e, stackTrace);
157:       rethrow;
158:     }
159:   }
160: 
161:   Future<void> saveCards(List<FFTCGCard> cards) async {
162:     _verifyInitialization();
163:     try {
164:       final box = getCardsBox();
165:       final cardsMap = {for (var card in cards) card.cardNumber: card};
166:       await box.putAll(cardsMap);
167:       _talker.info('${cards.length} cards saved successfully');
168:     } catch (e, stackTrace) {
169:       _talker.severe('Error saving cards', e, stackTrace);
170:       rethrow;
171:     }
172:   }
173: 
174:   FFTCGCard? getCard(String cardNumber) {
175:     _verifyInitialization();
176:     try {
177:       final box = getCardsBox();
178:       return box.get(cardNumber);
179:     } catch (e, stackTrace) {
180:       _talker.severe('Error getting card', e, stackTrace);
181:       rethrow;
182:     }
183:   }
184: 
185:   List<FFTCGCard> getAllCards() {
186:     _verifyInitialization();
187:     try {
188:       final box = getCardsBox();
189:       return box.values.toList();
190:     } catch (e, stackTrace) {
191:       _talker.severe('Error getting all cards', e, stackTrace);
192:       rethrow;
193:     }
194:   }
195: 
196:   Future<void> deleteCard(String cardNumber) async {
197:     _verifyInitialization();
198:     try {
199:       final box = getCardsBox();
200:       await box.delete(cardNumber);
201:       _talker.info('Card deleted successfully: $cardNumber');
202:     } catch (e, stackTrace) {
203:       _talker.severe('Error deleting card', e, stackTrace);
204:       rethrow;
205:     }
206:   }
207: 
208:   Future<bool> isBoxEmpty(String boxName) async {
209:     _verifyInitialization();
210:     try {
211:       final box = Hive.box(boxName);
212:       return box.isEmpty;
213:     } catch (e, stackTrace) {
214:       _talker.severe('Error checking if box is empty', e, stackTrace);
215:       rethrow;
216:     }
217:   }
218: 
219:   Future<void> compactBoxes() async {
220:     _verifyInitialization();
221:     try {
222:       await Future.wait([
223:         getCardsBox().compact(),
224:         getUserBox().compact(),
225:         getSyncStatusBox().compact(),
226:       ]);
227:       _talker.info('Boxes compacted successfully');
228:     } catch (e, stackTrace) {
229:       _talker.severe('Error compacting boxes', e, stackTrace);
230:       rethrow;
231:     }
232:   }
233: }
</file>

<file path="lib/core/services/preferences_service.dart">
 1: // lib/core/services/preferences_service.dart
 2: import 'package:shared_preferences/shared_preferences.dart';
 3: 
 4: class PreferencesService {
 5:   static Future<bool> setValue<T>(String key, T value) async {
 6:     try {
 7:       final prefs = await SharedPreferences.getInstance();
 8: 
 9:       if (value is String) {
10:         return await prefs.setString(key, value);
11:       } else if (value is int) {
12:         return await prefs.setInt(key, value);
13:       } else if (value is bool) {
14:         return await prefs.setBool(key, value);
15:       } else if (value is double) {
16:         return await prefs.setDouble(key, value);
17:       } else if (value is List<String>) {
18:         return await prefs.setStringList(key, value);
19:       }
20:       return false;
21:     } catch (e) {
22:       // Log error and return false
23:       return false;
24:     }
25:   }
26: 
27:   static Future<T?> getValue<T>(String key) async {
28:     try {
29:       final prefs = await SharedPreferences.getInstance();
30:       return prefs.get(key) as T?;
31:     } catch (e) {
32:       // Log error and return null
33:       return null;
34:     }
35:   }
36: }
</file>

<file path="lib/core/services/sync_service.dart">
  1: import 'dart:async';
  2: import 'package:cloud_firestore/cloud_firestore.dart';
  3: import 'package:flutter_riverpod/flutter_riverpod.dart';
  4: import 'package:shared_preferences/shared_preferences.dart';
  5: import '../logging/talker_service.dart';
  6: import '../models/sync_status.dart';
  7: import 'hive_service.dart';
  8: import '../../features/cards/models/fftcg_card.dart';
  9: import '../../features/auth/providers/auth_providers.dart';
 10: import '../../features/auth/services/auth_service.dart';
 11: import 'connectivity_service.dart';
 12: 
 13: class SyncResult {
 14:   final bool success;
 15:   final String? error;
 16:   final int itemsSynced;
 17:   final DateTime timestamp;
 18: 
 19:   SyncResult({
 20:     required this.success,
 21:     this.error,
 22:     this.itemsSynced = 0,
 23:     DateTime? timestamp,
 24:   }) : timestamp = timestamp ?? DateTime.now();
 25: }
 26: 
 27: class SyncService {
 28:   final HiveService _hiveService;
 29:   final TalkerService _talker;
 30:   final Ref _ref;
 31:   final FirebaseFirestore _firestore;
 32:   final AuthService _authService;
 33:   final ConnectivityService _connectivityService;
 34: 
 35:   Timer? _syncTimer;
 36:   bool _isSyncing = false;
 37: 
 38:   static const int _batchSize = 500;
 39:   static const String _lastSyncKey = 'last_sync_timestamp';
 40: 
 41:   SyncService({
 42:     required HiveService hiveService,
 43:     required Ref ref,
 44:     FirebaseFirestore? firestore,
 45:     TalkerService? talker,
 46:     AuthService? authService,
 47:     ConnectivityService? connectivityService,
 48:   })  : _hiveService = hiveService,
 49:         _ref = ref,
 50:         _firestore = firestore ?? FirebaseFirestore.instance,
 51:         _talker = talker ?? TalkerService(),
 52:         _authService = authService ?? AuthService(),
 53:         _connectivityService = connectivityService ?? ConnectivityService();
 54: 
 55:   void dispose() {
 56:     stopPeriodicSync();
 57:   }
 58: 
 59:   void startPeriodicSync() {
 60:     _syncTimer?.cancel();
 61:     _syncTimer = Timer.periodic(
 62:       const Duration(minutes: 15),
 63:       (_) => syncPendingChanges(),
 64:     );
 65:     _talker.info('Started periodic sync');
 66:   }
 67: 
 68:   void stopPeriodicSync() {
 69:     _syncTimer?.cancel();
 70:     _syncTimer = null;
 71:     _talker.info('Stopped periodic sync');
 72:   }
 73: 
 74:   Future<SyncResult> syncPendingChanges() async {
 75:     if (_isSyncing) {
 76:       return SyncResult(
 77:         success: false,
 78:         error: 'Sync already in progress',
 79:       );
 80:     }
 81: 
 82:     _isSyncing = true;
 83:     _talker.info('Starting sync of pending changes');
 84: 
 85:     try {
 86:       if (!await _connectivityService.hasStableConnection()) {
 87:         return SyncResult(
 88:           success: false,
 89:           error: 'No stable connection available',
 90:         );
 91:       }
 92: 
 93:       final isGuest = await _authService.isGuestSession();
 94:       if (isGuest) {
 95:         _talker.info('Skipping sync for guest user');
 96:         return SyncResult(
 97:           success: true,
 98:           error: 'Guest user, sync skipped',
 99:         );
100:       }
101: 
102:       final user = _ref.read(currentUserProvider);
103:       if (user == null) {
104:         return SyncResult(
105:           success: false,
106:           error: 'No user logged in',
107:         );
108:       }
109: 
110:       final pendingCards = _hiveService
111:           .getAllCards()
112:           .where((card) => card.syncStatus == SyncStatus.pending)
113:           .toList();
114: 
115:       _talker.info('Found ${pendingCards.length} cards pending sync');
116: 
117:       if (pendingCards.isEmpty) {
118:         return SyncResult(success: true);
119:       }
120: 
121:       // Process in batches
122:       int totalSynced = 0;
123:       for (var i = 0; i < pendingCards.length; i += _batchSize) {
124:         final end = (i + _batchSize < pendingCards.length)
125:             ? i + _batchSize
126:             : pendingCards.length;
127:         final currentBatch = pendingCards.sublist(i, end);
128: 
129:         await _syncBatch(user.id, currentBatch);
130:         totalSynced += currentBatch.length;
131:       }
132: 
133:       await _updateLastSyncTime();
134:       _talker.info('Sync completed successfully');
135: 
136:       return SyncResult(
137:         success: true,
138:         itemsSynced: totalSynced,
139:       );
140:     } catch (e, stackTrace) {
141:       _talker.severe('Error during sync', e, stackTrace);
142:       return SyncResult(
143:         success: false,
144:         error: e.toString(),
145:       );
146:     } finally {
147:       _isSyncing = false;
148:     }
149:   }
150: 
151:   Future<void> _syncBatch(String userId, List<FFTCGCard> cards) async {
152:     final batch = _firestore.batch();
153:     final userCardsCollection =
154:         _firestore.collection('users').doc(userId).collection('cards');
155: 
156:     for (final card in cards) {
157:       final docRef = userCardsCollection.doc(card.cardNumber);
158:       batch.set(
159:         docRef,
160:         {
161:           ...card.toMap(),
162:           'lastModified': FieldValue.serverTimestamp(),
163:           'syncStatus': 'synced',
164:         },
165:         SetOptions(merge: true),
166:       );
167:     }
168: 
169:     await batch.commit();
170:     await _updateLocalSyncStatus(cards);
171:   }
172: 
173:   Future<void> _updateLocalSyncStatus(List<FFTCGCard> cards) async {
174:     for (final card in cards) {
175:       card.markSynced();
176:       await _hiveService.saveCard(card);
177:     }
178:   }
179: 
180:   Future<void> revertFailedConversion(String userId) async {
181:     try {
182:       _talker.info('Starting conversion revert for user: $userId');
183: 
184:       await _firestore
185:           .collection('users')
186:           .doc(userId)
187:           .collection('cards')
188:           .get()
189:           .then((snapshot) {
190:         for (var doc in snapshot.docs) {
191:           doc.reference.delete();
192:         }
193:       });
194: 
195:       final localCards = _hiveService.getAllCards();
196:       for (final card in localCards) {
197:         card.markForSync();
198:         await _hiveService.saveCard(card);
199:       }
200: 
201:       _talker.info('Conversion revert completed successfully');
202:     } catch (e, stackTrace) {
203:       _talker.severe('Error reverting conversion', e, stackTrace);
204:       rethrow;
205:     }
206:   }
207: 
208:   Future<bool> isDataSynced() async {
209:     try {
210:       final localCards = _hiveService.getAllCards();
211:       return !localCards.any((card) =>
212:           card.syncStatus == SyncStatus.pending ||
213:           card.syncStatus == SyncStatus.error);
214:     } catch (e, stackTrace) {
215:       _talker.severe('Error checking sync status', e, stackTrace);
216:       return false;
217:     }
218:   }
219: 
220:   Future<void> resetSyncStatus() async {
221:     try {
222:       final localCards = _hiveService.getAllCards();
223:       for (final card in localCards) {
224:         card.markForSync();
225:         await _hiveService.saveCard(card);
226:       }
227:       _talker.info('Reset sync status for all cards');
228:     } catch (e, stackTrace) {
229:       _talker.severe('Error resetting sync status', e, stackTrace);
230:       rethrow;
231:     }
232:   }
233: 
234:   int getCardCount() {
235:     try {
236:       return _hiveService.getAllCards().length;
237:     } catch (e, stackTrace) {
238:       _talker.severe('Error getting card count', e, stackTrace);
239:       return 0;
240:     }
241:   }
242: 
243:   Future<DateTime?> getLastSyncTime() async {
244:     try {
245:       final prefs = await SharedPreferences.getInstance();
246:       final timestamp = prefs.getInt(_lastSyncKey);
247:       return timestamp != null
248:           ? DateTime.fromMillisecondsSinceEpoch(timestamp)
249:           : null;
250:     } catch (e, stackTrace) {
251:       _talker.severe('Error getting last sync time', e, stackTrace);
252:       return null;
253:     }
254:   }
255: 
256:   Future<void> _updateLastSyncTime() async {
257:     try {
258:       final prefs = await SharedPreferences.getInstance();
259:       await prefs.setInt(
260:         _lastSyncKey,
261:         DateTime.now().millisecondsSinceEpoch,
262:       );
263:     } catch (e, stackTrace) {
264:       _talker.severe('Error updating last sync time', e, stackTrace);
265:     }
266:   }
267: 
268:   Future<SyncStatus> getSyncStatus() async {
269:     try {
270:       final localCards = _hiveService.getAllCards();
271:       if (localCards.isEmpty) return SyncStatus.synced;
272: 
273:       if (localCards.any((card) => card.syncStatus == SyncStatus.error)) {
274:         return SyncStatus.error;
275:       }
276: 
277:       if (localCards.any((card) => card.syncStatus == SyncStatus.pending)) {
278:         return SyncStatus.pending;
279:       }
280: 
281:       return SyncStatus.synced;
282:     } catch (e, stackTrace) {
283:       _talker.severe('Error getting sync status', e, stackTrace);
284:       return SyncStatus.error;
285:     }
286:   }
287: }
288: 
289: // Providers
290: final hiveServiceProvider = Provider<HiveService>((ref) {
291:   return HiveService();
292: });
293: 
294: final syncServiceProvider = Provider<SyncService>((ref) {
295:   final hiveService = ref.watch(hiveServiceProvider);
296:   return SyncService(
297:     hiveService: hiveService,
298:     ref: ref,
299:     authService: AuthService(),
300:   );
301: });
302: 
303: final syncStatusProvider = FutureProvider<bool>((ref) {
304:   final syncService = ref.watch(syncServiceProvider);
305:   return syncService.isDataSynced();
306: });
307: 
308: final lastSyncTimeProvider = FutureProvider<DateTime?>((ref) {
309:   final syncService = ref.watch(syncServiceProvider);
310:   return syncService.getLastSyncTime();
311: });
312: 
313: final cardCountProvider = Provider<int>((ref) {
314:   final syncService = ref.watch(syncServiceProvider);
315:   return syncService.getCardCount();
316: });
</file>

<file path="lib/core/state/app_state.dart">
  1: // lib/core/state/app_state.dart
  2: 
  3: import 'package:flutter_riverpod/flutter_riverpod.dart';
  4: import '../../features/auth/providers/auth_providers.dart';
  5: import '../../features/auth/enums/auth_status.dart';
  6: import '../models/sync_status.dart';
  7: import '../services/connectivity_service.dart';
  8: import '../services/sync_service.dart';
  9: 
 10: // App-wide state
 11: class AppState {
 12:   final bool isInitialized;
 13:   final bool isOnline;
 14:   final SyncStatus syncStatus;
 15:   final String? error;
 16: 
 17:   const AppState({
 18:     this.isInitialized = false,
 19:     this.isOnline = false,
 20:     this.syncStatus = SyncStatus.synced,
 21:     this.error,
 22:   });
 23: 
 24:   AppState copyWith({
 25:     bool? isInitialized,
 26:     bool? isOnline,
 27:     SyncStatus? syncStatus,
 28:     String? error,
 29:   }) {
 30:     return AppState(
 31:       isInitialized: isInitialized ?? this.isInitialized,
 32:       isOnline: isOnline ?? this.isOnline,
 33:       syncStatus: syncStatus ?? this.syncStatus,
 34:       error: error,
 35:     );
 36:   }
 37: }
 38: 
 39: // Main state notifier
 40: class AppStateNotifier extends StateNotifier<AppState> {
 41:   final Ref _ref;
 42: 
 43:   AppStateNotifier(this._ref) : super(const AppState()) {
 44:     _initialize();
 45:   }
 46: 
 47:   Future<void> _initialize() async {
 48:     // Listen to auth state changes
 49:     _ref.listen(authNotifierProvider, (previous, next) {
 50:       if (next.status == AuthStatus.error) {
 51:         state = state.copyWith(error: next.errorMessage);
 52:       }
 53:     });
 54: 
 55:     // Listen to connectivity changes
 56:     _ref.listen(connectivityStatusProvider, (previous, next) {
 57:       next.whenData((isOnline) {
 58:         state = state.copyWith(isOnline: isOnline);
 59:       });
 60:     });
 61: 
 62:     // Listen to sync status from sync service
 63:     _ref.listen(syncStatusStreamProvider, (previous, next) {
 64:       next.whenData((status) {
 65:         state = state.copyWith(syncStatus: status);
 66:       });
 67:     });
 68: 
 69:     state = state.copyWith(isInitialized: true);
 70:   }
 71: }
 72: 
 73: // Main app state provider
 74: final appStateProvider =
 75:     StateNotifierProvider<AppStateNotifier, AppState>((ref) {
 76:   return AppStateNotifier(ref);
 77: });
 78: 
 79: // Convenience providers
 80: final isOnlineProvider = Provider<bool>((ref) {
 81:   return ref.watch(appStateProvider).isOnline;
 82: });
 83: 
 84: final appSyncStatusProvider = Provider<SyncStatus>((ref) {
 85:   return ref.watch(appStateProvider).syncStatus;
 86: });
 87: 
 88: final isInitializedProvider = Provider<bool>((ref) {
 89:   return ref.watch(appStateProvider).isInitialized;
 90: });
 91: 
 92: // Connectivity status stream provider
 93: final connectivityStatusProvider = StreamProvider<bool>((ref) {
 94:   final connectivityService = ref.watch(connectivityServiceProvider);
 95:   return connectivityService.connectivityStream;
 96: });
 97: 
 98: // Sync status stream provider
 99: final syncStatusStreamProvider = StreamProvider<SyncStatus>((ref) async* {
100:   final syncService = ref.watch(syncServiceProvider);
101:   while (true) {
102:     yield await syncService.getSyncStatus();
103:     await Future.delayed(const Duration(seconds: 30));
104:   }
105: });
</file>

<file path="lib/core/theme/app_theme.dart">
 1: import 'package:flutter/material.dart';
 2: 
 3: class AppTheme {
 4:   static final ThemeData lightTheme = ThemeData(
 5:   useMaterial3: true,
 6:   brightness: Brightness.light,
 7:   colorScheme: const ColorScheme.light(
 8:     primary: Color(0xFFFF00FF), // Magenta
 9:     secondary: Color(0xFFCC00CC), // Darker Magenta
10:     tertiary: Color(0xFFFF66FF),
11:     surface: Color(0xFFF5F5F5),
12:   ),
13:   scaffoldBackgroundColor: Colors.white,
14:   appBarTheme: const AppBarTheme(
15:     backgroundColor: Colors.white,
16:     elevation: 0,
17:     scrolledUnderElevation: 0, // Add this
18:     surfaceTintColor: Colors.transparent, // Add this
19:   ),
20:   cardTheme: const CardTheme(
21:     color: Colors.white,
22:     elevation: 2,
23:   ),
24: );
25: 
26: static final ThemeData darkTheme = ThemeData(
27:   useMaterial3: true,
28:   brightness: Brightness.dark,
29:   colorScheme: const ColorScheme.dark(
30:     primary: Color(0xFFFF00FF), // Magenta
31:     secondary: Color(0xFFCC00CC), // Darker Magenta
32:     tertiary: Color(0xFFFF66FF),
33:     surface: Color(0xFF2C2C2C),
34:   ),
35:   scaffoldBackgroundColor: const Color(0xFF1A1A1A),
36:   appBarTheme: const AppBarTheme(
37:     backgroundColor: Color(0xFF1A1A1A),
38:     elevation: 0,
39:     scrolledUnderElevation: 0, // Add this
40:     surfaceTintColor: Colors.transparent, // Add this
41:   ),
42:   cardTheme: const CardTheme(
43:     color: Color(0xFF2C2C2C),
44:     elevation: 2,
45:   ),
46: );
47: }
</file>

<file path="lib/core/utils/breakpoints.dart">
  1: // lib/core/utils/breakpoints.dart
  2: 
  3: import 'package:flutter/material.dart';
  4: 
  5: class Breakpoints {
  6:   // Screen width breakpoints
  7:   static const double mobileSmall = 320;
  8:   static const double mobileMedium = 375;
  9:   static const double mobileLarge = 425;
 10:   static const double tablet = 768;
 11:   static const double laptop = 1024;
 12:   static const double laptopLarge = 1440;
 13:   static const double desktop = 1920;
 14:   static const double desktop4K = 2560;
 15: 
 16:   // Content width constraints
 17:   static const double maxContentWidthMobile = 600;
 18:   static const double maxContentWidthTablet = 800;
 19:   static const double maxContentWidthDesktop = 1200;
 20: 
 21:   // Grid breakpoints
 22:   static const double gridSmall = 450;
 23:   static const double gridMedium = 800;
 24:   static const double gridLarge = 1100;
 25: 
 26:   // Navigation breakpoints
 27:   static const double navigationBreakpoint = 600;
 28:   static const double extendedNavigationBreakpoint = 1200;
 29: }
 30: 
 31: class ResponsiveBreakpoints {
 32:   static bool isMobileSmall(BuildContext context) =>
 33:       MediaQuery.of(context).size.width < Breakpoints.mobileSmall;
 34: 
 35:   static bool isMobileMedium(BuildContext context) =>
 36:       MediaQuery.of(context).size.width >= Breakpoints.mobileSmall &&
 37:       MediaQuery.of(context).size.width < Breakpoints.mobileLarge;
 38: 
 39:   static bool isMobileLarge(BuildContext context) =>
 40:       MediaQuery.of(context).size.width >= Breakpoints.mobileLarge &&
 41:       MediaQuery.of(context).size.width < Breakpoints.tablet;
 42: 
 43:   static bool isTablet(BuildContext context) =>
 44:       MediaQuery.of(context).size.width >= Breakpoints.tablet &&
 45:       MediaQuery.of(context).size.width < Breakpoints.laptop;
 46: 
 47:   static bool isLaptop(BuildContext context) =>
 48:       MediaQuery.of(context).size.width >= Breakpoints.laptop &&
 49:       MediaQuery.of(context).size.width < Breakpoints.laptopLarge;
 50: 
 51:   static bool isDesktop(BuildContext context) =>
 52:       MediaQuery.of(context).size.width >= Breakpoints.desktop;
 53: 
 54:   static T getValueForBreakpoint<T>({
 55:     required BuildContext context,
 56:     required T mobile,
 57:     T? mobileLarge,
 58:     T? tablet,
 59:     T? laptop,
 60:     T? desktop,
 61:   }) {
 62:     final width = MediaQuery.of(context).size.width;
 63: 
 64:     if (width >= Breakpoints.desktop) {
 65:       return desktop ?? laptop ?? tablet ?? mobileLarge ?? mobile;
 66:     }
 67:     if (width >= Breakpoints.laptop) {
 68:       return laptop ?? tablet ?? mobileLarge ?? mobile;
 69:     }
 70:     if (width >= Breakpoints.tablet) {
 71:       return tablet ?? mobileLarge ?? mobile;
 72:     }
 73:     if (width >= Breakpoints.mobileLarge) {
 74:       return mobileLarge ?? mobile;
 75:     }
 76:     return mobile;
 77:   }
 78: 
 79:   static EdgeInsets getScreenPadding(BuildContext context) {
 80:     return getValueForBreakpoint(
 81:       context: context,
 82:       mobile: const EdgeInsets.all(8),
 83:       mobileLarge: const EdgeInsets.all(16),
 84:       tablet: const EdgeInsets.all(24),
 85:       laptop: const EdgeInsets.all(32),
 86:       desktop: const EdgeInsets.all(48),
 87:     );
 88:   }
 89: 
 90:   static double getMaxContentWidth(BuildContext context) {
 91:     return getValueForBreakpoint(
 92:       context: context,
 93:       mobile: Breakpoints.maxContentWidthMobile,
 94:       tablet: Breakpoints.maxContentWidthTablet,
 95:       desktop: Breakpoints.maxContentWidthDesktop,
 96:     );
 97:   }
 98: }
 99: 
100: class ResponsiveLayout extends StatelessWidget {
101:   final Widget mobile;
102:   final Widget? tablet;
103:   final Widget? desktop;
104: 
105:   const ResponsiveLayout({
106:     super.key,
107:     required this.mobile,
108:     this.tablet,
109:     this.desktop,
110:   });
111: 
112:   @override
113:   Widget build(BuildContext context) {
114:     return LayoutBuilder(
115:       builder: (context, constraints) {
116:         if (constraints.maxWidth >= Breakpoints.desktop) {
117:           return desktop ?? tablet ?? mobile;
118:         }
119:         if (constraints.maxWidth >= Breakpoints.tablet) {
120:           return tablet ?? mobile;
121:         }
122:         return mobile;
123:       },
124:     );
125:   }
126: }
127: 
128: class ResponsiveBuilder extends StatelessWidget {
129:   final Widget Function(
130:     BuildContext context,
131:     BoxConstraints constraints,
132:     ScreenType screenType,
133:   ) builder;
134: 
135:   const ResponsiveBuilder({
136:     super.key,
137:     required this.builder,
138:   });
139: 
140:   @override
141:   Widget build(BuildContext context) {
142:     return LayoutBuilder(
143:       builder: (context, constraints) {
144:         ScreenType screenType;
145:         if (constraints.maxWidth >= Breakpoints.desktop) {
146:           screenType = ScreenType.desktop;
147:         } else if (constraints.maxWidth >= Breakpoints.tablet) {
148:           screenType = ScreenType.tablet;
149:         } else {
150:           screenType = ScreenType.mobile;
151:         }
152: 
153:         return builder(context, constraints, screenType);
154:       },
155:     );
156:   }
157: }
158: 
159: enum ScreenType { mobile, tablet, desktop }
160: 
161: extension ResponsiveExtensions on num {
162:   double w(BuildContext context) =>
163:       MediaQuery.of(context).size.width * (this / 100);
164: 
165:   double h(BuildContext context) =>
166:       MediaQuery.of(context).size.height * (this / 100);
167: }
</file>

<file path="lib/core/utils/responsive_utils.dart">
  1: // lib/core/utils/responsive_utils.dart
  2: import 'package:flutter/material.dart';
  3: 
  4: class ResponsiveUtils {
  5:   // Device breakpoints
  6:   static const double phoneSmall = 320;
  7:   static const double phoneMedium = 375;
  8:   static const double phoneLarge = 414;
  9:   static const double tablet = 768;
 10:   static const double laptop = 1024;
 11:   static const double desktop = 1440;
 12: 
 13:   // Standard max content widths
 14:   static const double maxContentWidthPhone = 600;
 15:   static const double maxContentWidthTablet = 800;
 16:   static const double maxContentWidthDesktop = 1200;
 17: 
 18:   // Grid breakpoints
 19:   static const Map<String, double> gridBreakpoints = {
 20:     'xs': 0,
 21:     'sm': 600,
 22:     'md': 960,
 23:     'lg': 1280,
 24:     'xl': 1920,
 25:   };
 26: 
 27:   // Grid columns per breakpoint
 28:   static const Map<String, int> gridColumns = {
 29:     'xs': 4,
 30:     'sm': 8,
 31:     'md': 12,
 32:     'lg': 12,
 33:     'xl': 12,
 34:   };
 35: 
 36:   // Standard spacing values
 37:   static const Map<String, double> spacing = {
 38:     'xs': 4.0,
 39:     'sm': 8.0,
 40:     'md': 16.0,
 41:     'lg': 24.0,
 42:     'xl': 32.0,
 43:   };
 44: 
 45:   // Device type detection
 46:   static bool isPhone(BuildContext context) =>
 47:       MediaQuery.of(context).size.width < tablet;
 48: 
 49:   static bool isTablet(BuildContext context) =>
 50:       MediaQuery.of(context).size.width >= tablet &&
 51:       MediaQuery.of(context).size.width < laptop;
 52: 
 53:   static bool isDesktop(BuildContext context) =>
 54:       MediaQuery.of(context).size.width >= laptop;
 55: 
 56:   // Layout helpers
 57:   static double getScreenWidth(BuildContext context) =>
 58:       MediaQuery.of(context).size.width;
 59: 
 60:   static double getScreenHeight(BuildContext context) =>
 61:       MediaQuery.of(context).size.height;
 62: 
 63:   static bool isLandscape(BuildContext context) =>
 64:       MediaQuery.of(context).orientation == Orientation.landscape;
 65: 
 66:   // Grid layout helpers
 67:   static int getCardGridCrossAxisCount(BuildContext context) {
 68:     final width = getScreenWidth(context);
 69:     if (width < phoneSmall) return 1;
 70:     if (width < tablet) return 2;
 71:     if (width < laptop) return 3;
 72:     if (width < desktop) return 4;
 73:     return 6;
 74:   }
 75: 
 76:   // Spacing and padding
 77:   static EdgeInsets getResponsivePadding(BuildContext context) {
 78:     final width = getScreenWidth(context);
 79:     if (width < tablet) {
 80:       return EdgeInsets.all(spacing['sm']!);
 81:     } else if (width < laptop) {
 82:       return EdgeInsets.all(spacing['md']!);
 83:     }
 84:     return EdgeInsets.all(spacing['lg']!);
 85:   }
 86: 
 87:   // Font scaling
 88:   static double getResponsiveFontSize(BuildContext context, double baseSize) {
 89:     final width = getScreenWidth(context);
 90:     final scaleFactor = width < tablet
 91:         ? 1.0
 92:         : width < laptop
 93:             ? 1.1
 94:             : 1.2;
 95:     return baseSize * scaleFactor;
 96:   }
 97: 
 98:   // Layout builders
 99:   static Widget buildResponsiveLayout({
100:     required BuildContext context,
101:     required Widget mobile,
102:     Widget? tablet,
103:     Widget? desktop,
104:   }) {
105:     return LayoutBuilder(
106:       builder: (context, constraints) {
107:         if (constraints.maxWidth >= gridBreakpoints['lg']!) {
108:           return desktop ?? tablet ?? mobile;
109:         }
110:         if (constraints.maxWidth >= gridBreakpoints['md']!) {
111:           return tablet ?? mobile;
112:         }
113:         return mobile;
114:       },
115:     );
116:   }
117: 
118:   // Content constraints
119:   static Widget wrapWithMaxWidth(Widget child, BuildContext context) {
120:     return Center(
121:       child: ConstrainedBox(
122:         constraints: BoxConstraints(
123:           maxWidth: _getMaxContentWidth(context),
124:         ),
125:         child: child,
126:       ),
127:     );
128:   }
129: 
130:   static double _getMaxContentWidth(BuildContext context) {
131:     if (isDesktop(context)) return maxContentWidthDesktop;
132:     if (isTablet(context)) return maxContentWidthTablet;
133:     return maxContentWidthPhone;
134:   }
135: 
136:   static EdgeInsets getScreenPadding(BuildContext context) {
137:     final width = getScreenWidth(context);
138:     if (width < tablet) {
139:       return const EdgeInsets.all(8.0);
140:     } else if (width < laptop) {
141:       return const EdgeInsets.all(16.0);
142:     }
143:     return const EdgeInsets.all(24.0);
144:   }
145: 
146:   static double getDialogWidth(BuildContext context) {
147:     final width = getScreenWidth(context);
148:     if (width < tablet) return width * 0.9;
149:     if (width < laptop) return width * 0.7;
150:     return width * 0.5;
151:   }
152: 
153:   // Navigation helpers
154:   static bool shouldShowSideNav(BuildContext context) =>
155:       getScreenWidth(context) >= gridBreakpoints['md']!;
156: 
157:   static double getSideNavWidth(BuildContext context) {
158:     final width = getScreenWidth(context);
159:     if (width >= gridBreakpoints['xl']!) return 280;
160:     if (width >= gridBreakpoints['lg']!) return 240;
161:     return 200;
162:   }
163: 
164:   // Component-specific helpers
165:   static double getCardWidth(BuildContext context) {
166:     final width = getScreenWidth(context);
167:     if (width < phoneSmall) return width * 0.9;
168:     if (width < tablet) return width * 0.45;
169:     if (width < laptop) return width * 0.3;
170:     return width * 0.22;
171:   }
172: 
173:   static double getCardHeight(BuildContext context) =>
174:       getCardWidth(context) * 1.4; // Assuming 1.4:1 aspect ratio
175: 
176:   static double getListItemHeight(BuildContext context) {
177:     if (isDesktop(context)) return 100;
178:     if (isTablet(context)) return 80;
179:     return 72;
180:   }
181: }
182: 
183: // Extension methods for responsive dimensions
184: extension ResponsiveDimensions on num {
185:   double w(BuildContext context) =>
186:       MediaQuery.of(context).size.width * (this / 100);
187: 
188:   double h(BuildContext context) =>
189:       MediaQuery.of(context).size.height * (this / 100);
190: 
191:   double sp(BuildContext context) =>
192:       ResponsiveUtils.getResponsiveFontSize(context, toDouble());
193: }
</file>

<file path="lib/features/auth/enums/auth_status.dart">
1: enum AuthStatus {
2:   initial,
3:   authenticated,
4:   unauthenticated,
5:   guest,
6:   loading,
7:   error
8: }
</file>

<file path="lib/features/auth/models/auth_exception.dart">
 1: class CustomAuthException implements Exception {
 2:   final String code;
 3:   final String message;
 4:   final dynamic originalError;
 5: 
 6:   CustomAuthException({
 7:     required this.code,
 8:     required this.message,
 9:     this.originalError,
10:   });
11: 
12:   @override
13:   String toString() => 'AuthException: $message (Code: $code)';
14: }
</file>

<file path="lib/features/auth/presentation/auth_wrapper.dart">
  1: // lib/features/auth/presentation/auth_wrapper.dart
  2: 
  3: import 'dart:async';
  4: import 'package:flutter/material.dart';
  5: import 'package:flutter_riverpod/flutter_riverpod.dart';
  6: import '../enums/auth_status.dart';
  7: import '../providers/auth_providers.dart';
  8: import '../presentation/widgets/email_verification_dialog.dart';
  9: import '../../../core/logging/talker_service.dart';
 10: import 'package:go_router/go_router.dart';
 11: 
 12: class AuthWrapper extends ConsumerStatefulWidget {
 13:   final Widget child;
 14: 
 15:   const AuthWrapper({
 16:     super.key,
 17:     required this.child,
 18:   });
 19: 
 20:   @override
 21:   ConsumerState<AuthWrapper> createState() => _AuthWrapperState();
 22: }
 23: 
 24: class _AuthWrapperState extends ConsumerState<AuthWrapper> {
 25:   Timer? _emailVerificationTimer;
 26:   bool _showingDialog = false;
 27:   final _talker = TalkerService();
 28: 
 29:   @override
 30:   void initState() {
 31:     super.initState();
 32:     _startEmailVerificationCheck();
 33:   }
 34: 
 35:   @override
 36:   void dispose() {
 37:     _emailVerificationTimer?.cancel();
 38:     super.dispose();
 39:   }
 40: 
 41:   void _startEmailVerificationCheck() {
 42:     _emailVerificationTimer?.cancel();
 43:     _emailVerificationTimer = Timer.periodic(
 44:       const Duration(seconds: 5),
 45:       (_) => _checkEmailVerification(),
 46:     );
 47:   }
 48: 
 49:   void _checkEmailVerification() {
 50:     if (!mounted) return;
 51: 
 52:     final authState = ref.read(authNotifierProvider);
 53:     final user = authState.user;
 54: 
 55:     if (authState.status == AuthStatus.authenticated &&
 56:         user != null &&
 57:         !user.isGuest &&
 58:         !user.isEmailVerified &&
 59:         user.email != null &&
 60:         !_showingDialog) {
 61:       _showVerificationDialog(user.email!);
 62:     }
 63:   }
 64: 
 65:   Future<void> _showVerificationDialog(String email) async {
 66:     if (!mounted) return;
 67: 
 68:     setState(() => _showingDialog = true);
 69: 
 70:     try {
 71:       if (!mounted) return;
 72: 
 73:       await showDialog(
 74:         context: context,
 75:         barrierDismissible: false,
 76:         builder: (dialogContext) => EmailVerificationDialog(
 77:           email: email,
 78:           onResendEmail: () async {
 79:             try {
 80:               await ref
 81:                   .read(authNotifierProvider.notifier)
 82:                   .sendEmailVerification();
 83:               if (!mounted) return;
 84:               ScaffoldMessenger.of(context).showSnackBar(
 85:                 const SnackBar(content: Text('Verification email sent')),
 86:               );
 87:             } catch (e) {
 88:               _talker.severe('Failed to send verification email', e);
 89:               if (!mounted) return;
 90:               ScaffoldMessenger.of(context).showSnackBar(
 91:                 SnackBar(
 92:                   content: Text('Failed to send verification email: $e'),
 93:                   backgroundColor: Theme.of(context).colorScheme.error,
 94:                 ),
 95:               );
 96:             }
 97:           },
 98:           onCancel: () async {
 99:             try {
100:               await ref.read(authNotifierProvider.notifier).signOut();
101:               if (!mounted) return;
102:               context.go('/auth/login');
103:             } catch (e) {
104:               _talker.severe('Error during verification cancel/logout', e);
105:               if (!mounted) return;
106:               ScaffoldMessenger.of(context).showSnackBar(
107:                 SnackBar(
108:                   content: Text('Error signing out: $e'),
109:                   backgroundColor: Theme.of(context).colorScheme.error,
110:                 ),
111:               );
112:             }
113:           },
114:         ),
115:       );
116:     } catch (e) {
117:       _talker.severe('Error showing verification dialog', e);
118:     } finally {
119:       if (mounted) {
120:         setState(() => _showingDialog = false);
121:       }
122:     }
123:   }
124: 
125:   @override
126:   Widget build(BuildContext context) {
127:     final authState = ref.watch(authNotifierProvider);
128: 
129:     // Show loading screen while checking auth status
130:     if (authState.status == AuthStatus.initial) {
131:       return const Scaffold(
132:         body: Center(child: CircularProgressIndicator()),
133:       );
134:     }
135: 
136:     // Handle error state
137:     if (authState.status == AuthStatus.error) {
138:       return Scaffold(
139:         body: Center(
140:           child: Column(
141:             mainAxisAlignment: MainAxisAlignment.center,
142:             children: [
143:               Text(
144:                 'Authentication Error',
145:                 style: Theme.of(context).textTheme.titleLarge,
146:               ),
147:               if (authState.errorMessage != null)
148:                 Padding(
149:                   padding: const EdgeInsets.all(16.0),
150:                   child: Text(
151:                     authState.errorMessage!,
152:                     textAlign: TextAlign.center,
153:                     style: TextStyle(
154:                       color: Theme.of(context).colorScheme.error,
155:                     ),
156:                   ),
157:                 ),
158:               ElevatedButton(
159:                 onPressed: () => context.go('/auth/login'),
160:                 child: const Text('Return to Login'),
161:               ),
162:             ],
163:           ),
164:         ),
165:       );
166:     }
167: 
168:     // If we get here, we're either authenticated or a guest
169:     // The router will handle redirecting unauthenticated users
170:     return widget.child;
171:   }
172: }
</file>

<file path="lib/features/auth/presentation/screens/account_linking_screen.dart">
  1: // lib/features/auth/presentation/screens/account_linking_screen.dart
  2: import 'package:firebase_auth/firebase_auth.dart';
  3: import 'package:flutter/material.dart';
  4: import 'package:flutter_riverpod/flutter_riverpod.dart';
  5: import '../widgets/auth_button.dart';
  6: import '../widgets/auth_text_field.dart';
  7: import '../../providers/auth_providers.dart';
  8: import '../../enums/auth_status.dart';
  9: 
 10: class AccountLinkingScreen extends ConsumerStatefulWidget {
 11:   const AccountLinkingScreen({super.key});
 12: 
 13:   @override
 14:   ConsumerState<AccountLinkingScreen> createState() =>
 15:       _AccountLinkingScreenState();
 16: }
 17: 
 18: class _AccountLinkingScreenState extends ConsumerState<AccountLinkingScreen> {
 19:   final _formKey = GlobalKey<FormState>();
 20:   final _emailController = TextEditingController();
 21:   final _passwordController = TextEditingController();
 22:   bool _isLoading = false;
 23: 
 24:   @override
 25:   void dispose() {
 26:     _emailController.dispose();
 27:     _passwordController.dispose();
 28:     super.dispose();
 29:   }
 30: 
 31:   Future<void> _linkWithGoogle() async {
 32:     if (_isLoading) return;
 33: 
 34:     setState(() => _isLoading = true);
 35:     try {
 36:       await ref.read(authNotifierProvider.notifier).linkWithGoogle();
 37: 
 38:       if (mounted) {
 39:         ScaffoldMessenger.of(context).showSnackBar(
 40:           const SnackBar(content: Text('Successfully linked Google account')),
 41:         );
 42:         Navigator.pop(context);
 43:       }
 44:     } catch (e) {
 45:       if (mounted) {
 46:         final message = e is FirebaseAuthException
 47:             ? ref.read(authServiceProvider).getReadableAuthError(e)
 48:             : e.toString();
 49: 
 50:         ScaffoldMessenger.of(context).showSnackBar(
 51:           SnackBar(
 52:             content: Text(message),
 53:             backgroundColor: Theme.of(context).colorScheme.error,
 54:           ),
 55:         );
 56:       }
 57:     } finally {
 58:       if (mounted) {
 59:         setState(() => _isLoading = false);
 60:       }
 61:     }
 62:   }
 63: 
 64:   Future<void> _linkWithEmailPassword() async {
 65:     if (!_formKey.currentState!.validate() || _isLoading) return;
 66: 
 67:     setState(() => _isLoading = true);
 68:     try {
 69:       await ref.read(authNotifierProvider.notifier).linkWithEmailPassword(
 70:             _emailController.text.trim(),
 71:             _passwordController.text,
 72:           );
 73:       if (mounted) {
 74:         ScaffoldMessenger.of(context).showSnackBar(
 75:           const SnackBar(
 76:               content: Text('Successfully linked email/password account')),
 77:         );
 78:         Navigator.pop(context);
 79:       }
 80:     } catch (e) {
 81:       if (mounted) {
 82:         ScaffoldMessenger.of(context).showSnackBar(
 83:           SnackBar(content: Text('Failed to link account: ${e.toString()}')),
 84:         );
 85:       }
 86:     } finally {
 87:       if (mounted) {
 88:         setState(() => _isLoading = false);
 89:       }
 90:     }
 91:   }
 92: 
 93:   @override
 94:   Widget build(BuildContext context) {
 95:     final authState = ref.watch(authNotifierProvider);
 96: 
 97:     return Scaffold(
 98:       appBar: AppBar(
 99:         title: const Text('Link Account'),
100:         leading: IconButton(
101:           icon: const Icon(Icons.arrow_back),
102:           onPressed: () => Navigator.pop(context),
103:         ),
104:         automaticallyImplyLeading: false,
105:       ), // Removed the actions array with the X button
106:       body: SingleChildScrollView(
107:         padding: const EdgeInsets.all(16),
108:         child: Column(
109:           crossAxisAlignment: CrossAxisAlignment.stretch,
110:           children: [
111:             const Text(
112:               'Link another account to access your data with multiple sign-in methods.',
113:               style: TextStyle(fontSize: 16),
114:             ),
115:             const SizedBox(height: 24),
116:             AuthButton(
117:               text: 'Link Google Account',
118:               onPressed: _isLoading ? null : _linkWithGoogle,
119:               isLoading: _isLoading && authState.status == AuthStatus.loading,
120:             ),
121:             const SizedBox(height: 24),
122:             const Divider(),
123:             const SizedBox(height: 24),
124:             Form(
125:               key: _formKey,
126:               child: Column(
127:                 children: [
128:                   AuthTextField(
129:                     controller: _emailController,
130:                     label: 'Email',
131:                     keyboardType: TextInputType.emailAddress,
132:                     enabled: !_isLoading,
133:                     validator: (value) {
134:                       if (value?.isEmpty ?? true) {
135:                         return 'Please enter your email';
136:                       }
137:                       if (!RegExp(r'^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}$')
138:                           .hasMatch(value!)) {
139:                         return 'Please enter a valid email';
140:                       }
141:                       return null;
142:                     },
143:                   ),
144:                   AuthTextField(
145:                     controller: _passwordController,
146:                     label: 'Password',
147:                     enabled: !_isLoading,
148:                     isPassword: true,
149:                     validator: (value) {
150:                       if (value?.isEmpty ?? true) {
151:                         return 'Please enter your password';
152:                       }
153:                       if (value!.length < 6) {
154:                         return 'Password must be at least 6 characters';
155:                       }
156:                       return null;
157:                     },
158:                   ),
159:                   const SizedBox(height: 16),
160:                   AuthButton(
161:                     text: 'Link Email/Password Account',
162:                     onPressed: _isLoading ? null : _linkWithEmailPassword,
163:                     isLoading:
164:                         _isLoading && authState.status == AuthStatus.loading,
165:                   ),
166:                 ],
167:               ),
168:             ),
169:           ],
170:         ),
171:       ),
172:     );
173:   }
174: }
</file>

<file path="lib/features/auth/presentation/screens/login_screen.dart">
  1: // lib/features/auth/presentation/screens/login_screen.dart
  2: 
  3: import 'package:firebase_auth/firebase_auth.dart';
  4: import 'package:flutter/material.dart';
  5: import 'package:flutter_riverpod/flutter_riverpod.dart';
  6: import '../../../../core/logging/talker_service.dart';
  7: import '../../enums/auth_status.dart';
  8: import '../../providers/auth_providers.dart';
  9: import '../widgets/auth_button.dart';
 10: import '../widgets/auth_text_field.dart';
 11: import '../widgets/email_verification_dialog.dart';
 12: import 'registration_screen.dart';
 13: import '../../../settings/presentation/screens/logs_viewer_screen.dart';
 14: import 'package:flutter/services.dart' show SystemNavigator;
 15: import 'package:flutter/foundation.dart' show kDebugMode;
 16: 
 17: class LoginScreen extends ConsumerStatefulWidget {
 18:   const LoginScreen({super.key});
 19: 
 20:   @override
 21:   ConsumerState<LoginScreen> createState() => _LoginScreenState();
 22: }
 23: 
 24: class _LoginScreenState extends ConsumerState<LoginScreen> {
 25:   final _formKey = GlobalKey<FormState>();
 26:   final _emailController = TextEditingController();
 27:   final _passwordController = TextEditingController();
 28:   final _talker = TalkerService();
 29:   bool _isLoading = false;
 30:   bool _isInputEnabled = true;
 31:   DateTime? _lastBackPress; // Add this field for back press handling
 32: 
 33:   @override
 34:   void initState() {
 35:     super.initState();
 36:     _talker.info('Login screen initialized');
 37:   }
 38: 
 39:   @override
 40:   void dispose() {
 41:     _emailController.dispose();
 42:     _passwordController.dispose();
 43:     super.dispose();
 44:   }
 45: 
 46:   void _handleError(FirebaseAuthException e) {
 47:     if (!mounted) return;
 48: 
 49:     final errorMessage = ref.read(authServiceProvider).getReadableAuthError(e);
 50:     _talker.severe('Firebase Auth Error: ${e.message}', e);
 51: 
 52:     if (e.code == 'too-many-requests') {
 53:       setState(() => _isInputEnabled = false);
 54:       Future.delayed(const Duration(minutes: 5), () {
 55:         if (mounted) {
 56:           setState(() => _isInputEnabled = true);
 57:         }
 58:       });
 59:     }
 60: 
 61:     ScaffoldMessenger.of(context).showSnackBar(
 62:       SnackBar(
 63:         content: Text(errorMessage),
 64:         behavior: SnackBarBehavior.floating,
 65:         duration: const Duration(seconds: 4),
 66:         action: e.code == 'too-many-requests' || e.code == 'wrong-password'
 67:             ? SnackBarAction(
 68:                 label: 'Reset Password',
 69:                 onPressed: () => _handlePasswordReset(),
 70:               )
 71:             : null,
 72:       ),
 73:     );
 74:   }
 75: 
 76:   Future<void> _handleEmailLogin() async {
 77:     if (_formKey.currentState == null || !_formKey.currentState!.validate()) {
 78:       return;
 79:     }
 80:     if (_isLoading || !_isInputEnabled) return;
 81: 
 82:     setState(() => _isLoading = true);
 83: 
 84:     // Store Navigator and ScaffoldMessenger before async gap
 85:     final navigator = Navigator.of(context);
 86:     final scaffold = ScaffoldMessenger.of(context);
 87: 
 88:     try {
 89:       _talker.info('Attempting email login for: ${_emailController.text}');
 90:       await ref.read(authNotifierProvider.notifier).signInWithEmailPassword(
 91:             _emailController.text.trim(),
 92:             _passwordController.text,
 93:           );
 94: 
 95:       // Check if email is verified
 96:       final user = ref.read(currentUserProvider);
 97:       if (!mounted) return;
 98: 
 99:       if (user != null && !user.isEmailVerified) {
100:         await showDialog(
101:           context: context,
102:           barrierDismissible: false,
103:           builder: (dialogContext) => EmailVerificationDialog(
104:             email: user.email ?? '',
105:             onResendEmail: () async {
106:               try {
107:                 await ref
108:                     .read(authNotifierProvider.notifier)
109:                     .sendEmailVerification();
110:                 if (!mounted) return;
111:                 scaffold.showSnackBar(
112:                   const SnackBar(content: Text('Verification email sent')),
113:                 );
114:               } catch (e) {
115:                 if (!mounted) return;
116:                 scaffold.showSnackBar(
117:                   SnackBar(
118:                       content: Text('Failed to send verification email: $e')),
119:                 );
120:               }
121:             },
122:             onCancel: () async {
123:               await ref.read(authNotifierProvider.notifier).signOut();
124:               if (!mounted) return;
125:               navigator.pop();
126:             },
127:           ),
128:         );
129:       }
130:     } on FirebaseAuthException catch (e) {
131:       if (!mounted) return;
132:       scaffold.showSnackBar(
133:         SnackBar(
134:           content: Text(ref.read(authServiceProvider).getReadableAuthError(e)),
135:           behavior: SnackBarBehavior.floating,
136:         ),
137:       );
138:     } catch (e, stackTrace) {
139:       _talker.severe('Email login failed', e, stackTrace);
140:       if (!mounted) return;
141:       scaffold.showSnackBar(
142:         SnackBar(
143:           content: Text('Login error: ${e.toString()}'),
144:           behavior: SnackBarBehavior.floating,
145:         ),
146:       );
147:     } finally {
148:       if (mounted) {
149:         setState(() => _isLoading = false);
150:       }
151:     }
152:   }
153: 
154:   Future<void> _handleGoogleLogin() async {
155:     if (_isLoading || !_isInputEnabled) return;
156:     setState(() => _isLoading = true);
157: 
158:     try {
159:       _talker.info('Attempting Google sign-in');
160:       await ref.read(authNotifierProvider.notifier).signInWithGoogle();
161:     } on FirebaseAuthException catch (e) {
162:       _handleError(e);
163:     } catch (e, stackTrace) {
164:       _talker.severe('Google sign-in failed', e, stackTrace);
165:       if (mounted) {
166:         ScaffoldMessenger.of(context).showSnackBar(
167:           const SnackBar(
168:             content: Text('An error occurred during Google sign-in'),
169:             behavior: SnackBarBehavior.floating,
170:           ),
171:         );
172:       }
173:     } finally {
174:       if (mounted) {
175:         setState(() => _isLoading = false);
176:       }
177:     }
178:   }
179: 
180:   Future<void> _handleGuestLogin() async {
181:     if (_isLoading || !_isInputEnabled) return;
182:     setState(() => _isLoading = true);
183: 
184:     try {
185:       _talker.info('Attempting guest login');
186:       await ref.read(authNotifierProvider.notifier).signInAsGuest();
187:     } catch (e, stackTrace) {
188:       _talker.severe('Guest login failed', e, stackTrace);
189:       if (mounted) {
190:         ScaffoldMessenger.of(context).showSnackBar(
191:           const SnackBar(
192:             content: Text('Failed to continue as guest'),
193:             behavior: SnackBarBehavior.floating,
194:           ),
195:         );
196:       }
197:     } finally {
198:       if (mounted) {
199:         setState(() => _isLoading = false);
200:       }
201:     }
202:   }
203: 
204:   Future<void> _handlePasswordReset() async {
205:     if (_emailController.text.isEmpty) {
206:       ScaffoldMessenger.of(context).showSnackBar(
207:         const SnackBar(
208:           content: Text('Please enter your email address'),
209:           behavior: SnackBarBehavior.floating,
210:         ),
211:       );
212:       return;
213:     }
214: 
215:     setState(() => _isLoading = true);
216: 
217:     try {
218:       _talker.info('Attempting password reset for: ${_emailController.text}');
219:       await FirebaseAuth.instance.sendPasswordResetEmail(
220:         email: _emailController.text.trim(),
221:       );
222: 
223:       if (mounted) {
224:         ScaffoldMessenger.of(context).showSnackBar(
225:           const SnackBar(
226:             content: Text('Password reset email sent'),
227:             behavior: SnackBarBehavior.floating,
228:           ),
229:         );
230:       }
231:     } on FirebaseAuthException catch (e) {
232:       _handleError(e);
233:     } catch (e, stackTrace) {
234:       _talker.severe('Password reset failed', e, stackTrace);
235:       if (mounted) {
236:         ScaffoldMessenger.of(context).showSnackBar(
237:           const SnackBar(
238:             content: Text('Failed to send password reset email'),
239:             behavior: SnackBarBehavior.floating,
240:           ),
241:         );
242:       }
243:     } finally {
244:       if (mounted) {
245:         setState(() => _isLoading = false);
246:       }
247:     }
248:   }
249: 
250:   @override
251:   Widget build(BuildContext context) {
252:     final authState = ref.watch(authNotifierProvider);
253:     final isLoading = _isLoading || authState.status == AuthStatus.loading;
254: 
255:     return PopScope(
256:       canPop: false,
257:       onPopInvokedWithResult: (didPop, _) async {
258:         if (didPop) return;
259: 
260:         final now = DateTime.now();
261:         if (_lastBackPress == null ||
262:             now.difference(_lastBackPress!) > const Duration(seconds: 2)) {
263:           _lastBackPress = now;
264:           if (!mounted) return;
265:           ScaffoldMessenger.of(context).showSnackBar(
266:             const SnackBar(
267:               content: Text('Press back again to exit'),
268:               duration: Duration(seconds: 2),
269:             ),
270:           );
271:           return;
272:         }
273: 
274:         if (!mounted) return;
275:         await SystemNavigator.pop(animated: true);
276:       },
277:       child: Scaffold(
278:         body: SafeArea(
279:           child: Center(
280:             child: SingleChildScrollView(
281:               padding: const EdgeInsets.all(24.0),
282:               child: Form(
283:                 key: _formKey,
284:                 child: Column(
285:                   mainAxisAlignment: MainAxisAlignment.center,
286:                   crossAxisAlignment: CrossAxisAlignment.stretch,
287:                   children: [
288:                     Text(
289:                       'FFTCG Companion',
290:                       style: Theme.of(context).textTheme.headlineMedium,
291:                       textAlign: TextAlign.center,
292:                     ),
293:                     const SizedBox(height: 48),
294:                     AuthTextField(
295:                       controller: _emailController,
296:                       label: 'Email',
297:                       enabled: _isInputEnabled && !isLoading,
298:                       keyboardType: TextInputType.emailAddress,
299:                       validator: (value) {
300:                         if (value?.isEmpty ?? true) {
301:                           return 'Please enter your email';
302:                         }
303:                         if (!RegExp(r'^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}$')
304:                             .hasMatch(value!)) {
305:                           return 'Please enter a valid email';
306:                         }
307:                         return null;
308:                       },
309:                     ),
310:                     AuthTextField(
311:                       controller: _passwordController,
312:                       label: 'Password',
313:                       enabled: _isInputEnabled && !isLoading,
314:                       isPassword: true,
315:                       validator: (value) {
316:                         if (value?.isEmpty ?? true) {
317:                           return 'Please enter your password';
318:                         }
319:                         if (value!.length < 6) {
320:                           return 'Password must be at least 6 characters';
321:                         }
322:                         return null;
323:                       },
324:                     ),
325:                     Align(
326:                       alignment: Alignment.centerRight,
327:                       child: TextButton(
328:                         onPressed: isLoading ? null : _handlePasswordReset,
329:                         child: const Text('Forgot Password?'),
330:                       ),
331:                     ),
332:                     const SizedBox(height: 24),
333:                     AuthButton(
334:                       text: 'Sign In',
335:                       onPressed: _isInputEnabled && !isLoading
336:                           ? () => _handleEmailLogin()
337:                           : null,
338:                       isLoading: isLoading,
339:                     ),
340:                     AuthButton(
341:                       text: 'Continue with Google',
342:                       onPressed: _isInputEnabled && !isLoading
343:                           ? () => _handleGoogleLogin()
344:                           : null,
345:                       isLoading: isLoading,
346:                       isOutlined: true,
347:                     ),
348:                     AuthButton(
349:                       text: 'Continue as Guest',
350:                       onPressed: _isInputEnabled && !isLoading
351:                           ? () => _handleGuestLogin()
352:                           : null,
353:                       isLoading: isLoading,
354:                       isOutlined: true,
355:                     ),
356:                     TextButton(
357:                       onPressed: _isInputEnabled && !isLoading
358:                           ? () {
359:                               Navigator.of(context).push(
360:                                 MaterialPageRoute(
361:                                   builder: (context) =>
362:                                       const RegistrationScreen(),
363:                                 ),
364:                               );
365:                             }
366:                           : null,
367:                       child: const Text('Create an Account'),
368:                     ),
369:                     if (kDebugMode)
370:                       IconButton(
371:                         icon: const Icon(Icons.bug_report),
372:                         onPressed: () {
373:                           Navigator.of(context).push(
374:                             MaterialPageRoute(
375:                               builder: (context) => const LogsViewerScreen(),
376:                             ),
377:                           );
378:                         },
379:                       ),
380:                   ],
381:                 ),
382:               ),
383:             ),
384:           ),
385:         ),
386:       ),
387:     );
388:   }
389: }
</file>

<file path="lib/features/auth/presentation/screens/registration_screen.dart">
  1: // lib/features/auth/presentation/screens/registration_screen.dart
  2: import 'package:firebase_auth/firebase_auth.dart';
  3: import 'package:flutter/material.dart';
  4: import 'package:flutter_riverpod/flutter_riverpod.dart';
  5: import '../../../../core/logging/talker_service.dart';
  6: import '../../enums/auth_status.dart';
  7: import '../../providers/auth_providers.dart';
  8: import '../widgets/auth_button.dart';
  9: import '../widgets/auth_text_field.dart';
 10: import 'login_screen.dart';
 11: import 'account_linking_screen.dart';
 12: import '../widgets/account_exists_dialog.dart';
 13: 
 14: class RegistrationScreen extends ConsumerStatefulWidget {
 15:   const RegistrationScreen({super.key});
 16: 
 17:   @override
 18:   ConsumerState<RegistrationScreen> createState() => _RegistrationScreenState();
 19: }
 20: 
 21: class _RegistrationScreenState extends ConsumerState<RegistrationScreen> {
 22:   final _formKey = GlobalKey<FormState>();
 23:   final _displayNameController = TextEditingController();
 24:   final _emailController = TextEditingController();
 25:   final _passwordController = TextEditingController();
 26:   final _confirmPasswordController = TextEditingController();
 27:   final _talker = TalkerService();
 28:   bool _isLoading = false;
 29:   bool _isInputEnabled = true;
 30: 
 31:   @override
 32:   void initState() {
 33:     super.initState();
 34:     _talker.info('Registration screen initialized');
 35:   }
 36: 
 37:   @override
 38:   void dispose() {
 39:     _displayNameController.dispose();
 40:     _emailController.dispose();
 41:     _passwordController.dispose();
 42:     _confirmPasswordController.dispose();
 43:     super.dispose();
 44:   }
 45: 
 46:   void _handleError(FirebaseAuthException e) {
 47:     if (!mounted) return;
 48: 
 49:     final errorMessage = ref.read(authServiceProvider).getReadableAuthError(e);
 50:     _talker.severe('Firebase Auth Error: ${e.message}', e);
 51: 
 52:     if (e.code == 'too-many-requests') {
 53:       setState(() => _isInputEnabled = false);
 54:       Future.delayed(const Duration(minutes: 5), () {
 55:         if (mounted) {
 56:           setState(() => _isInputEnabled = true);
 57:         }
 58:       });
 59:     }
 60: 
 61:     ScaffoldMessenger.of(context).showSnackBar(
 62:       SnackBar(
 63:         content: Text(errorMessage),
 64:         behavior: SnackBarBehavior.floating,
 65:         duration: const Duration(seconds: 4),
 66:       ),
 67:     );
 68:   }
 69: 
 70:   Future<void> _handleRegistration() async {
 71:     if (_formKey.currentState == null || !_formKey.currentState!.validate()) {
 72:       return;
 73:     }
 74:     if (_isLoading || !_isInputEnabled) return;
 75: 
 76:     setState(() => _isLoading = true);
 77: 
 78:     try {
 79:       _talker.info('Attempting registration for: ${_emailController.text}');
 80: 
 81:       final result = await ref
 82:           .read(authNotifierProvider.notifier)
 83:           .registerWithEmailPassword(
 84:             _emailController.text.trim(),
 85:             _passwordController.text,
 86:             _displayNameController.text.trim(),
 87:           );
 88: 
 89:       if (!mounted) return;
 90: 
 91:       if (result == null) {
 92:         // Show account exists dialog
 93:         await showDialog(
 94:           context: context,
 95:           barrierDismissible: false,
 96:           builder: (context) => AccountExistsDialog(
 97:             email: _emailController.text,
 98:             onLogin: () {
 99:               Navigator.of(context).pushReplacement(
100:                 MaterialPageRoute(
101:                   builder: (context) => const LoginScreen(),
102:                 ),
103:               );
104:             },
105:             onLink: () {
106:               final currentUser = ref.read(authNotifierProvider).user;
107:               if (currentUser?.isGuest ?? true) {
108:                 ScaffoldMessenger.of(context).showSnackBar(
109:                   const SnackBar(
110:                     content: Text('Please sign in first to link accounts'),
111:                     behavior: SnackBarBehavior.floating,
112:                   ),
113:                 );
114:                 return;
115:               }
116:               Navigator.of(context).push(
117:                 MaterialPageRoute(
118:                   builder: (context) => const AccountLinkingScreen(),
119:                 ),
120:               );
121:             },
122:           ),
123:         );
124:       } else {
125:         // Registration successful, show verification email sent message
126:         if (mounted) {
127:           Navigator.of(context).pushReplacement(
128:             MaterialPageRoute(
129:               builder: (context) => const LoginScreen(),
130:             ),
131:           );
132:           ScaffoldMessenger.of(context).showSnackBar(
133:             const SnackBar(
134:               content: Text(
135:                 'Account created! Please check your email to verify your account.',
136:               ),
137:               duration: Duration(seconds: 5),
138:               behavior: SnackBarBehavior.floating,
139:             ),
140:           );
141:         }
142:       }
143:     } on FirebaseAuthException catch (e) {
144:       _handleError(e);
145:     } catch (e, stackTrace) {
146:       _talker.severe('Unexpected error during registration', e, stackTrace);
147:       if (mounted) {
148:         ScaffoldMessenger.of(context).showSnackBar(
149:           SnackBar(
150:             content: Text('Registration error: ${e.toString()}'),
151:             backgroundColor: Theme.of(context).colorScheme.error,
152:             behavior: SnackBarBehavior.floating,
153:           ),
154:         );
155:       }
156:     } finally {
157:       if (mounted) {
158:         setState(() => _isLoading = false);
159:       }
160:     }
161:   }
162: 
163:   String? _validatePassword(String? value) {
164:     if (value == null || value.isEmpty) {
165:       return 'Please enter a password';
166:     }
167:     if (value.length < 6) {
168:       return 'Password must be at least 6 characters';
169:     }
170:     if (!value.contains(RegExp(r'[A-Z]'))) {
171:       return 'Password must contain at least one uppercase letter';
172:     }
173:     if (!value.contains(RegExp(r'[0-9]'))) {
174:       return 'Password must contain at least one number';
175:     }
176:     return null;
177:   }
178: 
179:   @override
180:   Widget build(BuildContext context) {
181:     final authState = ref.watch(authNotifierProvider);
182:     final isLoading = _isLoading || authState.status == AuthStatus.loading;
183: 
184:     return Scaffold(
185:       appBar: AppBar(
186:         title: const Text('Create Account'),
187:       ),
188:       body: SafeArea(
189:         child: SingleChildScrollView(
190:           padding: const EdgeInsets.all(24.0),
191:           child: Form(
192:             key: _formKey,
193:             child: Column(
194:               crossAxisAlignment: CrossAxisAlignment.stretch,
195:               children: [
196:                 AuthTextField(
197:                   controller: _displayNameController,
198:                   label: 'Display Name',
199:                   enabled: _isInputEnabled && !isLoading,
200:                   validator: (value) {
201:                     if (value?.isEmpty ?? true) {
202:                       return 'Please enter a display name';
203:                     }
204:                     if (value!.length < 3) {
205:                       return 'Display name must be at least 3 characters';
206:                     }
207:                     return null;
208:                   },
209:                 ),
210:                 AuthTextField(
211:                   controller: _emailController,
212:                   label: 'Email',
213:                   enabled: _isInputEnabled && !isLoading,
214:                   keyboardType: TextInputType.emailAddress,
215:                   validator: (value) {
216:                     if (value?.isEmpty ?? true) {
217:                       return 'Please enter your email';
218:                     }
219:                     if (!RegExp(r'^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}$')
220:                         .hasMatch(value!)) {
221:                       return 'Please enter a valid email';
222:                     }
223:                     return null;
224:                   },
225:                 ),
226:                 AuthTextField(
227:                   controller: _passwordController,
228:                   label: 'Password',
229:                   enabled: _isInputEnabled && !isLoading,
230:                   isPassword: true,
231:                   validator: _validatePassword,
232:                 ),
233:                 AuthTextField(
234:                   controller: _confirmPasswordController,
235:                   label: 'Confirm Password',
236:                   enabled: _isInputEnabled && !isLoading,
237:                   isPassword: true,
238:                   validator: (value) {
239:                     if (value?.isEmpty ?? true) {
240:                       return 'Please confirm your password';
241:                     }
242:                     if (value != _passwordController.text) {
243:                       return 'Passwords do not match';
244:                     }
245:                     return null;
246:                   },
247:                 ),
248:                 const SizedBox(height: 24),
249:                 AuthButton(
250:                   text: 'Create Account',
251:                   onPressed: _isInputEnabled && !isLoading
252:                       ? () => _handleRegistration()
253:                       : null,
254:                   isLoading: isLoading,
255:                 ),
256:                 if (!_isInputEnabled)
257:                   Padding(
258:                     padding: const EdgeInsets.only(top: 16.0),
259:                     child: Text(
260:                       'Registration temporarily disabled. Please try again later.',
261:                       style: TextStyle(
262:                         color: Theme.of(context).colorScheme.error,
263:                       ),
264:                       textAlign: TextAlign.center,
265:                     ),
266:                   ),
267:               ],
268:             ),
269:           ),
270:         ),
271:       ),
272:     );
273:   }
274: }
</file>

<file path="lib/features/auth/presentation/widgets/account_exists_dialog.dart">
 1: import 'package:flutter/material.dart';
 2: 
 3: class AccountExistsDialog extends StatelessWidget {
 4:   final String email;
 5:   final VoidCallback onLogin;
 6:   final VoidCallback onLink;
 7: 
 8:   const AccountExistsDialog({
 9:     super.key,
10:     required this.email,
11:     required this.onLogin,
12:     required this.onLink,
13:   });
14: 
15:   @override
16:   Widget build(BuildContext context) {
17:     return AlertDialog(
18:       title: const Text('Account Already Exists'),
19:       content: Text(
20:         'An account with email $email already exists. Would you like to sign in with that account or link it to your current account?',
21:       ),
22:       actions: [
23:         TextButton(
24:           onPressed: () => Navigator.of(context).pop(),
25:           child: const Text('Cancel'),
26:         ),
27:         TextButton(
28:           onPressed: () {
29:             Navigator.of(context).pop();
30:             onLogin();
31:           },
32:           child: const Text('Sign In'),
33:         ),
34:         TextButton(
35:           onPressed: () {
36:             Navigator.of(context).pop();
37:             onLink();
38:           },
39:           child: const Text('Link Account'),
40:         ),
41:       ],
42:     );
43:   }
44: }
</file>

<file path="lib/features/auth/presentation/widgets/auth_button.dart">
 1: import 'package:flutter/material.dart';
 2: 
 3: class AuthButton extends StatelessWidget {
 4:   final String text;
 5:   final void Function()?
 6:       onPressed; // Changed from VoidCallback to void Function()?
 7:   final bool isLoading;
 8:   final bool isOutlined;
 9: 
10:   const AuthButton({
11:     super.key,
12:     required this.text,
13:     required this.onPressed,
14:     this.isLoading = false,
15:     this.isOutlined = false,
16:   });
17: 
18:   @override
19:   Widget build(BuildContext context) {
20:     final buttonHeight = MediaQuery.of(context).size.height * 0.06;
21: 
22:     final Widget button = isOutlined
23:         ? OutlinedButton(
24:             onPressed: isLoading ? () {} : onPressed,
25:             style: OutlinedButton.styleFrom(
26:               padding: EdgeInsets.symmetric(
27:                 vertical: buttonHeight * 0.3,
28:               ),
29:               shape: RoundedRectangleBorder(
30:                 borderRadius: BorderRadius.circular(12),
31:               ),
32:             ),
33:             child: _buildButtonContent(),
34:           )
35:         : ElevatedButton(
36:             onPressed: isLoading ? () {} : onPressed,
37:             style: ElevatedButton.styleFrom(
38:               padding: EdgeInsets.symmetric(
39:                 vertical: buttonHeight * 0.3,
40:               ),
41:               shape: RoundedRectangleBorder(
42:                 borderRadius: BorderRadius.circular(12),
43:               ),
44:             ),
45:             child: _buildButtonContent(),
46:           );
47: 
48:     return Padding(
49:       padding: const EdgeInsets.symmetric(vertical: 8.0),
50:       child: SizedBox(
51:         height: buttonHeight,
52:         width: double.infinity,
53:         child: button,
54:       ),
55:     );
56:   }
57: 
58:   Widget _buildButtonContent() {
59:     return isLoading
60:         ? const SizedBox(
61:             height: 20,
62:             width: 20,
63:             child: CircularProgressIndicator(
64:               strokeWidth: 2,
65:             ),
66:           )
67:         : Text(text);
68:   }
69: }
</file>

<file path="lib/features/auth/presentation/widgets/auth_text_field.dart">
 1: import 'package:flutter/material.dart';
 2: 
 3: class AuthTextField extends StatefulWidget {
 4:   final TextEditingController controller;
 5:   final String label;
 6:   final String? Function(String?)? validator;
 7:   final bool isPassword;
 8:   final TextInputType? keyboardType;
 9:   final bool enabled; // Add this line
10: 
11:   const AuthTextField({
12:     super.key,
13:     required this.controller,
14:     required this.label,
15:     this.validator,
16:     this.isPassword = false,
17:     this.keyboardType,
18:     this.enabled = true, // Add this line
19:   });
20: 
21:   @override
22:   State<AuthTextField> createState() => _AuthTextFieldState();
23: }
24: 
25: class _AuthTextFieldState extends State<AuthTextField> {
26:   bool _obscureText = true;
27: 
28:   @override
29:   Widget build(BuildContext context) {
30:     return Padding(
31:       padding: const EdgeInsets.symmetric(vertical: 8.0),
32:       child: TextFormField(
33:         controller: widget.controller,
34:         enabled: widget.enabled, // Add this line
35:         decoration: InputDecoration(
36:           labelText: widget.label,
37:           border: const OutlineInputBorder(),
38:           suffixIcon: widget.isPassword
39:               ? IconButton(
40:                   icon: Icon(
41:                     _obscureText ? Icons.visibility : Icons.visibility_off,
42:                   ),
43:                   onPressed: () {
44:                     setState(() {
45:                       _obscureText = !_obscureText;
46:                     });
47:                   },
48:                 )
49:               : null,
50:         ),
51:         obscureText: widget.isPassword && _obscureText,
52:         keyboardType: widget.keyboardType,
53:         validator: widget.validator,
54:       ),
55:     );
56:   }
57: }
</file>

<file path="lib/features/auth/presentation/widgets/email_verification_dialog.dart">
 1: import 'package:flutter/material.dart';
 2: 
 3: class EmailVerificationDialog extends StatelessWidget {
 4:   final String email;
 5:   final VoidCallback onResendEmail;
 6:   final VoidCallback onCancel;
 7: 
 8:   const EmailVerificationDialog({
 9:     super.key,
10:     required this.email,
11:     required this.onResendEmail,
12:     required this.onCancel,
13:   });
14: 
15:   @override
16:   Widget build(BuildContext context) {
17:     return PopScope(
18:       canPop: false,
19:       child: AlertDialog(
20:         title: const Text('Email Verification Required'),
21:         content: Column(
22:           mainAxisSize: MainAxisSize.min,
23:           crossAxisAlignment: CrossAxisAlignment.start,
24:           children: [
25:             Text('Please verify your email address: $email'),
26:             const SizedBox(height: 16),
27:             const Text(
28:               'Check your inbox for the verification email and click the link to verify your account.',
29:             ),
30:           ],
31:         ),
32:         actions: [
33:           TextButton(
34:             onPressed: onCancel,
35:             child: const Text('Cancel'),
36:           ),
37:           TextButton(
38:             onPressed: onResendEmail,
39:             child: const Text('Resend Verification Email'),
40:           ),
41:         ],
42:       ),
43:     );
44:   }
45: }
</file>

<file path="lib/features/auth/providers/auth_notifier.dart">
  1: // lib/features/auth/providers/auth_notifier.dart
  2: 
  3: import 'dart:async';
  4: import 'package:flutter_riverpod/flutter_riverpod.dart';
  5: import 'package:firebase_auth/firebase_auth.dart';
  6: import '../../../core/logging/talker_service.dart';
  7: import '../../../models/user_model.dart';
  8: import '../../cards/providers/card_providers.dart';
  9: import '../repositories/auth_repository.dart';
 10: import '../enums/auth_status.dart';
 11: import '../services/auth_service.dart';
 12: import 'auth_state.dart';
 13: 
 14: class AuthNotifier extends StateNotifier<AuthState> {
 15:   final AuthRepository _authRepository;
 16:   final TalkerService _talker;
 17:   final AuthService _authService;
 18:   final Ref _ref; // Add this
 19:   StreamSubscription<UserModel?>? _authStateSubscription;
 20: 
 21:   AuthNotifier({
 22:     required AuthRepository authRepository,
 23:     required Ref ref, // Add this
 24:     TalkerService? talker,
 25:     AuthService? authService,
 26:   })  : _authRepository = authRepository,
 27:         _ref = ref, // Add this
 28:         _talker = talker ?? TalkerService(),
 29:         _authService = authService ?? AuthService(),
 30:         super(const AuthState()) {
 31:     _initialize();
 32:   }
 33: 
 34:   Future<void> signInWithGoogle() async {
 35:     try {
 36:       state = const AuthState(status: AuthStatus.loading);
 37:       _talker.info('Attempting Google sign in');
 38: 
 39:       final user = await _authRepository.signInWithGoogle();
 40:       if (user != null) {
 41:         state = AuthState(
 42:           status: AuthStatus.authenticated,
 43:           user: user,
 44:         );
 45:         _talker.info('Google sign in completed successfully');
 46:       } else {
 47:         state = const AuthState(status: AuthStatus.unauthenticated);
 48:         _talker.warning('Google sign in completed but no user returned');
 49:       }
 50:     } catch (e, stackTrace) {
 51:       _talker.severe('Error signing in with Google', e, stackTrace);
 52:       state = const AuthState(status: AuthStatus.unauthenticated);
 53:       rethrow;
 54:     }
 55:   }
 56: 
 57:   Future<void> signInWithEmailPassword(String email, String password) async {
 58:     try {
 59:       state = const AuthState(status: AuthStatus.loading);
 60:       _talker.info('Attempting email/password sign in');
 61: 
 62:       await _authRepository.signInWithEmailPassword(email, password);
 63:       _talker.info('Email/password sign in completed successfully');
 64:     } catch (e, stackTrace) {
 65:       _talker.severe('Error signing in with email/password', e, stackTrace);
 66:       state = const AuthState(status: AuthStatus.unauthenticated);
 67:       rethrow;
 68:     }
 69:   }
 70: 
 71:   Future<void> signInAsGuest() async {
 72:     try {
 73:       state = const AuthState(status: AuthStatus.loading);
 74:       final guestUser = await _authRepository.signInAsGuest();
 75:       if (guestUser != null) {
 76:         state = AuthState(
 77:           status: AuthStatus.guest,
 78:           user: guestUser,
 79:         );
 80: 
 81:         // Delay cache warmup to ensure auth state is fully updated
 82:         await Future.microtask(() async {
 83:           try {
 84:             await _ref
 85:                 .read(cardNotifierProvider.notifier)
 86:                 .loadNextPage(refresh: true);
 87:           } catch (e) {
 88:             _talker.warning('Cache warmup failed during guest login: $e');
 89:           }
 90:         });
 91:       } else {
 92:         throw Exception('Failed to create guest session');
 93:       }
 94:     } catch (e) {
 95:       _talker.severe('Error signing in as guest', e);
 96:       state = const AuthState(status: AuthStatus.error);
 97:       rethrow;
 98:     }
 99:   }
100: 
101:   Future<void> signOut() async {
102:     try {
103:       state = const AuthState(status: AuthStatus.loading);
104:       _talker.info('Attempting sign out');
105: 
106:       await _authRepository.signOut();
107:       state = const AuthState(status: AuthStatus.unauthenticated);
108:       _talker.info('Sign out completed successfully');
109:     } catch (e, stackTrace) {
110:       _talker.severe('Error signing out', e, stackTrace);
111:       state = const AuthState(status: AuthStatus.error);
112:       rethrow;
113:     }
114:   }
115: 
116:   Future<UserModel?> registerWithEmailPassword(
117:     String email,
118:     String password,
119:     String displayName,
120:   ) async {
121:     try {
122:       state = const AuthState(status: AuthStatus.loading);
123:       _talker.info('Attempting user registration');
124: 
125:       final user = await _authRepository.registerWithEmailPassword(
126:         email,
127:         password,
128:         displayName,
129:       );
130: 
131:       if (user == null) {
132:         state = const AuthState(status: AuthStatus.unauthenticated);
133:       }
134:       return user;
135:     } catch (e, stackTrace) {
136:       _talker.severe('Error registering with email/password', e, stackTrace);
137:       state = const AuthState(status: AuthStatus.unauthenticated);
138:       rethrow;
139:     }
140:   }
141: 
142:   Future<void> sendEmailVerification() async {
143:     try {
144:       await _authRepository.sendEmailVerification();
145:       _talker.info('Email verification sent');
146:     } catch (e, stackTrace) {
147:       _talker.severe('Error sending email verification', e, stackTrace);
148:       rethrow;
149:     }
150:   }
151: 
152:   Future<void> linkWithGoogle() async {
153:     try {
154:       state = const AuthState(status: AuthStatus.loading);
155:       final userModel = await _authRepository.linkWithGoogle();
156:       if (userModel != null) {
157:         state = AuthState(
158:           status: AuthStatus.authenticated,
159:           user: userModel,
160:         );
161:       } else {
162:         state = const AuthState(
163:           status: AuthStatus.error,
164:           errorMessage: 'Failed to link Google account',
165:         );
166:       }
167:     } catch (e) {
168:       _talker.severe('Error linking with Google', e);
169:       state = AuthState(
170:         status: AuthStatus.error,
171:         errorMessage: e is FirebaseAuthException
172:             ? _authService.getReadableAuthError(e)
173:             : 'Failed to link Google account',
174:       );
175:       rethrow;
176:     }
177:   }
178: 
179:   Future<void> linkWithEmailPassword(String email, String password) async {
180:     try {
181:       state = const AuthState(status: AuthStatus.loading);
182:       await _authRepository.linkWithEmailPassword(email, password);
183:     } catch (e) {
184:       state = const AuthState(status: AuthStatus.error);
185:       rethrow;
186:     }
187:   }
188: 
189:   @override
190:   void dispose() {
191:     _talker.info('Disposing AuthNotifier');
192:     _authStateSubscription?.cancel();
193:     super.dispose();
194:   }
195: 
196:   void _initialize() {
197:     _talker.info('Initializing auth state listener');
198:     _authStateSubscription?.cancel();
199:     _authStateSubscription = _authRepository.authStateChanges.listen(
200:       (user) async {
201:         _talker.info('Auth state changed: ${user?.id}');
202:         if (user != null) {
203:           if (user.isGuest) {
204:             state = AuthState(status: AuthStatus.guest, user: user);
205:           } else {
206:             state = AuthState(status: AuthStatus.authenticated, user: user);
207:           }
208:         } else {
209:           state = const AuthState(status: AuthStatus.unauthenticated);
210:         }
211:       },
212:       onError: (error, stackTrace) {
213:         _talker.severe('Auth state change error', error, stackTrace);
214:         state = const AuthState(status: AuthStatus.error);
215:       },
216:     );
217:   }
218: }
</file>

<file path="lib/features/auth/providers/auth_providers.dart">
 1: // lib/features/auth/providers/auth_providers.dart
 2: 
 3: import 'package:flutter_riverpod/flutter_riverpod.dart';
 4: import '../repositories/auth_repository.dart';
 5: import '../enums/auth_status.dart';
 6: import '../services/auth_service.dart';
 7: 
 8: import '../../../models/user_model.dart';
 9: import 'auth_notifier.dart';
10: import 'auth_state.dart';
11: 
12: // Service provider
13: final authServiceProvider = Provider<AuthService>((ref) {
14:   return AuthService();
15: });
16: 
17: // Repository provider
18: final authRepositoryProvider = Provider<AuthRepository>((ref) {
19:   final authService = ref.watch(authServiceProvider);
20:   return AuthRepository(authService: authService);
21: });
22: 
23: // Main auth state notifier provider
24: final authNotifierProvider =
25:     StateNotifierProvider<AuthNotifier, AuthState>((ref) {
26:   final authRepository = ref.watch(authRepositoryProvider);
27:   return AuthNotifier(
28:     authRepository: authRepository,
29:     ref: ref, // Add this
30:     talker: null,
31:   );
32: });
33: 
34: // Convenience providers
35: final currentUserProvider = Provider<UserModel?>((ref) {
36:   return ref.watch(authNotifierProvider).user;
37: });
38: 
39: final authStatusProvider = Provider<AuthStatus>((ref) {
40:   return ref.watch(authNotifierProvider).status;
41: });
42: 
43: final isAuthenticatedProvider = Provider<bool>((ref) {
44:   final status = ref.watch(authStatusProvider);
45:   return status == AuthStatus.authenticated || status == AuthStatus.guest;
46: });
47: 
48: // Error state provider
49: final authErrorProvider = Provider<String?>((ref) {
50:   return ref.watch(authNotifierProvider).errorMessage;
51: });
52: 
53: // Loading state provider
54: final isAuthLoadingProvider = Provider<bool>((ref) {
55:   return ref.watch(authNotifierProvider).status == AuthStatus.loading;
56: });
57: 
58: // Guest mode provider
59: final isGuestModeProvider = Provider<bool>((ref) {
60:   return ref.watch(authNotifierProvider).status == AuthStatus.guest;
61: });
62: 
63: // Auth action providers
64: final signOutProvider = Provider<Future<void> Function()>((ref) {
65:   return () => ref.read(authNotifierProvider.notifier).signOut();
66: });
67: 
68: final sendVerificationEmailProvider = Provider<Future<void> Function()>((ref) {
69:   return () => ref.read(authNotifierProvider.notifier).sendEmailVerification();
70: });
</file>

<file path="lib/features/auth/providers/auth_state.dart">
 1: // lib/features/auth/providers/auth_state.dart
 2: import '../../../models/user_model.dart';
 3: import '../enums/auth_status.dart';
 4: 
 5: class AuthState {
 6:   final AuthStatus status;
 7:   final UserModel? user;
 8:   final String? errorMessage;
 9: 
10:   const AuthState({
11:     this.status = AuthStatus.initial,
12:     this.user,
13:     this.errorMessage,
14:   });
15: 
16:   AuthState copyWith({
17:     AuthStatus? status,
18:     UserModel? user,
19:     String? errorMessage,
20:   }) {
21:     return AuthState(
22:       status: status ?? this.status,
23:       user: user ?? this.user,
24:       errorMessage: errorMessage, // Allow null to clear error messages
25:     );
26:   }
27: 
28:   @override
29:   String toString() {
30:     return 'AuthState(status: $status, user: ${user?.email}, errorMessage: $errorMessage)';
31:   }
32: 
33:   @override
34:   bool operator ==(Object other) {
35:     if (identical(this, other)) return true;
36:     return other is AuthState &&
37:         other.status == status &&
38:         other.user == user &&
39:         other.errorMessage == errorMessage;
40:   }
41: 
42:   @override
43:   int get hashCode => status.hashCode ^ user.hashCode ^ errorMessage.hashCode;
44: }
</file>

<file path="lib/features/auth/repositories/auth_repository.dart">
  1: import 'package:cloud_firestore/cloud_firestore.dart';
  2: import 'package:firebase_auth/firebase_auth.dart';
  3: import '../../../models/user_model.dart';
  4: import '../services/auth_service.dart';
  5: import '../../../core/logging/talker_service.dart';
  6: 
  7: class AuthRepository {
  8:   final AuthService _authService;
  9:   final TalkerService _talker;
 10:   final FirebaseFirestore _firestore;
 11:   final FirebaseAuth _auth;
 12: 
 13:   AuthRepository({
 14:     AuthService? authService,
 15:     TalkerService? talker,
 16:     FirebaseFirestore? firestore,
 17:     FirebaseAuth? auth,
 18:   })  : _authService = authService ?? AuthService(),
 19:         _talker = talker ?? TalkerService(),
 20:         _firestore = firestore ?? FirebaseFirestore.instance,
 21:         _auth = auth ?? FirebaseAuth.instance;
 22: 
 23:   Future<bool> isGuestSession() async {
 24:     try {
 25:       final currentUser = _auth.currentUser;
 26:       if (currentUser == null) return false;
 27: 
 28:       final doc =
 29:           await _firestore.collection('users').doc(currentUser.uid).get();
 30:       return doc.exists && (doc.data()?['isGuest'] ?? false);
 31:     } catch (e, stackTrace) {
 32:       _talker.severe('Error checking guest session', e, stackTrace);
 33:       return false;
 34:     }
 35:   }
 36: 
 37:   Stream<UserModel?> get authStateChanges => _auth.authStateChanges().asyncMap(
 38:         (user) async {
 39:           if (user == null) return null;
 40:           try {
 41:             final doc =
 42:                 await _firestore.collection('users').doc(user.uid).get();
 43:             if (doc.exists) {
 44:               return UserModel.fromFirestore(doc);
 45:             }
 46:             return null;
 47:           } catch (e, stackTrace) {
 48:             _talker.severe('Error in auth state changes stream', e, stackTrace);
 49:             return null;
 50:           }
 51:         },
 52:       );
 53: 
 54:   Future<UserModel?> getCurrentUser() async {
 55:     try {
 56:       final User? user = _auth.currentUser;
 57:       if (user == null) return null;
 58: 
 59:       final doc = await _firestore.collection('users').doc(user.uid).get();
 60:       if (doc.exists) {
 61:         return UserModel.fromFirestore(doc);
 62:       }
 63:       return null;
 64:     } catch (e, stackTrace) {
 65:       _talker.severe('Error getting current user', e, stackTrace);
 66:       return null;
 67:     }
 68:   }
 69: 
 70:   Future<UserModel?> signInWithGoogle() async {
 71:     try {
 72:       return await _authService.signInWithGoogle();
 73:     } catch (e, stackTrace) {
 74:       _talker.severe(
 75:           'Error signing in with Google in repository', e, stackTrace);
 76:       rethrow;
 77:     }
 78:   }
 79: 
 80:   Future<UserModel?> signInWithEmailPassword(
 81:       String email, String password) async {
 82:     try {
 83:       return await _authService.signInWithEmailPassword(email, password);
 84:     } catch (e, stackTrace) {
 85:       _talker.severe(
 86:           'Error signing in with email/password in repository', e, stackTrace);
 87:       rethrow;
 88:     }
 89:   }
 90: 
 91:   Future<UserModel?> registerWithEmailPassword(
 92:     String email,
 93:     String password,
 94:     String displayName,
 95:   ) async {
 96:     try {
 97:       return await _authService.registerWithEmailPassword(
 98:         email,
 99:         password,
100:         displayName,
101:       );
102:     } catch (e, stackTrace) {
103:       _talker.severe(
104:           'Error registering with email/password in repository', e, stackTrace);
105:       rethrow;
106:     }
107:   }
108: 
109:   Future<UserModel?> signInAsGuest() async {
110:     try {
111:       final userCredential = await _auth.signInAnonymously();
112:       final user = userCredential.user;
113: 
114:       if (user == null) {
115:         throw FirebaseAuthException(
116:           code: 'guest-session-failed',
117:           message: 'Failed to create guest session',
118:         );
119:       }
120: 
121:       final guestUser = UserModel(
122:         id: user.uid,
123:         displayName: 'Guest User',
124:         isGuest: true,
125:         isEmailVerified: false,
126:         createdAt: DateTime.now(),
127:         lastLoginAt: DateTime.now(),
128:       );
129: 
130:       await _firestore.collection('users').doc(user.uid).set(
131:         {
132:           ...guestUser.toMap(),
133:           'lastLoginAt': FieldValue.serverTimestamp(),
134:         },
135:         SetOptions(merge: true),
136:       );
137: 
138:       _talker.info('Guest session created successfully: ${user.uid}');
139:       return guestUser;
140:     } catch (e, stackTrace) {
141:       _talker.severe('Error signing in as guest in repository', e, stackTrace);
142:       rethrow;
143:     }
144:   }
145: 
146:   Future<UserModel?> linkWithGoogle() async {
147:     try {
148:       return await _authService.linkWithGoogle();
149:     } catch (e, stackTrace) {
150:       _talker.severe('Error linking with Google', e, stackTrace);
151:       rethrow;
152:     }
153:   }
154: 
155:   Future<void> linkWithEmailPassword(String email, String password) async {
156:     await _authService.linkWithEmailPassword(email, password);
157:   }
158: 
159:   Future<void> signOut() async {
160:     try {
161:       final currentUser = _auth.currentUser;
162:       final isGuest = await isGuestSession();
163: 
164:       if (isGuest && currentUser != null) {
165:         // Clean up guest user data before signing out
166:         await _firestore.collection('users').doc(currentUser.uid).delete();
167:         await currentUser.delete();
168:         _talker.info('Guest user data cleaned up: ${currentUser.uid}');
169:       }
170: 
171:       await _authService.signOut();
172:     } catch (e, stackTrace) {
173:       _talker.severe('Error signing out in repository', e, stackTrace);
174:       rethrow;
175:     }
176:   }
177: 
178:   Future<void> sendEmailVerification() async {
179:     try {
180:       await _authService.sendEmailVerification();
181:     } catch (e, stackTrace) {
182:       _talker.severe(
183:           'Error sending email verification in repository', e, stackTrace);
184:       rethrow;
185:     }
186:   }
187: 
188:   Future<void> checkEmailVerification() async {
189:     try {
190:       await _authService.checkEmailVerification();
191:     } catch (e, stackTrace) {
192:       _talker.severe(
193:           'Error checking email verification in repository', e, stackTrace);
194:       rethrow;
195:     }
196:   }
197: 
198:   Future<void> updateUserData(UserModel user) async {
199:     try {
200:       await _firestore.collection('users').doc(user.id).update(user.toMap());
201:       _talker.info('User data updated: ${user.id}');
202:     } catch (e, stackTrace) {
203:       _talker.severe('Error updating user data', e, stackTrace);
204:       rethrow;
205:     }
206:   }
207: 
208:   Future<void> deleteUserData(String userId) async {
209:     try {
210:       await _firestore.collection('users').doc(userId).delete();
211:       _talker.info('User data deleted: $userId');
212:     } catch (e, stackTrace) {
213:       _talker.severe('Error deleting user data', e, stackTrace);
214:       rethrow;
215:     }
216:   }
217: 
218:   Future<void> convertGuestToPermananet(UserModel user) async {
219:     try {
220:       await _firestore.collection('users').doc(user.id).update({
221:         ...user.toMap(),
222:         'isGuest': false,
223:         'convertedAt': FieldValue.serverTimestamp(),
224:       });
225:       _talker.info('Guest user converted to permanent: ${user.id}');
226:     } catch (e, stackTrace) {
227:       _talker.severe('Error converting guest user', e, stackTrace);
228:       rethrow;
229:     }
230:   }
231: }
</file>

<file path="lib/features/auth/services/auth_service.dart">
  1: // lib/features/auth/services/auth_service.dart
  2: 
  3: import 'package:firebase_auth/firebase_auth.dart';
  4: import 'package:google_sign_in/google_sign_in.dart';
  5: import 'package:cloud_firestore/cloud_firestore.dart';
  6: import 'package:flutter/foundation.dart';
  7: import '../../../models/user_model.dart';
  8: import 'package:shared_preferences/shared_preferences.dart';
  9: import 'dart:async';
 10: import '../../../services/app_check_service.dart';
 11: import '../../../core/logging/talker_service.dart';
 12: import '../../cards/services/card_cache_service.dart';
 13: 
 14: class AuthService {
 15:   final _auth = FirebaseAuth.instance;
 16:   final _googleSignIn = GoogleSignIn();
 17:   final _firestore = FirebaseFirestore.instance;
 18:   final _appCheckService = AppCheckService();
 19:   static const String _guestPrefsKey = 'guest_session';
 20:   static const Duration _timeout = Duration(seconds: 30);
 21:   final _talker = TalkerService();
 22: 
 23:   // Rate limiting properties
 24:   final _maxAttempts = 5;
 25:   final _cooldownPeriod = const Duration(minutes: 5);
 26:   final Map<String, List<DateTime>> _attemptHistory = {};
 27: 
 28:   // Authentication state
 29:   Stream<User?> get authStateChanges => _auth.authStateChanges();
 30: 
 31:   Future<void> _checkRateLimit(String identifier) async {
 32:     final now = DateTime.now();
 33:     _attemptHistory[identifier] = _attemptHistory[identifier] ?? [];
 34:     final attempts = _attemptHistory[identifier]!;
 35:     attempts
 36:         .removeWhere((attempt) => now.difference(attempt) > _cooldownPeriod);
 37: 
 38:     if (attempts.length >= _maxAttempts) {
 39:       final oldestAttempt = attempts.first;
 40:       final timeUntilReset = _cooldownPeriod - now.difference(oldestAttempt);
 41:       throw FirebaseAuthException(
 42:         code: 'too-many-requests',
 43:         message:
 44:             'Too many attempts. Please try again in ${timeUntilReset.inMinutes} minutes.',
 45:       );
 46:     }
 47: 
 48:     attempts.add(now);
 49:     _attemptHistory[identifier] = attempts;
 50:   }
 51: 
 52:   Future<void> _verifyConnectivityAndAppCheck() async {
 53:     if (!kDebugMode) {
 54:       try {
 55:         final isValid = await _appCheckService.validateToken();
 56:         if (!isValid) {
 57:           throw FirebaseAuthException(
 58:             code: 'app-check-failed',
 59:             message: 'Failed to verify app authenticity',
 60:           );
 61:         }
 62:       } on FirebaseException catch (e) {
 63:         if (e.code == 'too-many-attempts') {
 64:           _talker
 65:               .warning('App Check rate limit hit, proceeding with retry logic');
 66:           return;
 67:         }
 68:         rethrow;
 69:       }
 70:     }
 71:   }
 72: 
 73:   Future<UserModel?> signInWithEmailPassword(
 74:       String email, String password) async {
 75:     int retryCount = 0;
 76:     const maxRetries = 3;
 77: 
 78:     while (retryCount < maxRetries) {
 79:       try {
 80:         await _verifyConnectivityAndAppCheck();
 81:         await _checkRateLimit(email.toLowerCase());
 82: 
 83:         final userCredential = await _auth
 84:             .signInWithEmailAndPassword(
 85:               email: email.trim(),
 86:               password: password,
 87:             )
 88:             .timeout(_timeout);
 89: 
 90:         final user = userCredential.user;
 91:         if (user == null) {
 92:           throw FirebaseAuthException(
 93:             code: 'null-user',
 94:             message: 'Failed to get user details from Firebase',
 95:           );
 96:         }
 97: 
 98:         await user.reload();
 99:         return await _createOrUpdateUser(user);
100:       } on FirebaseException catch (e) {
101:         if (e.code == 'too-many-attempts') {
102:           retryCount++;
103:           if (retryCount < maxRetries) {
104:             _talker.warning(
105:                 'App Check rate limit hit, retrying... ($retryCount/$maxRetries)');
106:             await Future.delayed(Duration(seconds: retryCount * 2));
107:             continue;
108:           }
109:         }
110:         rethrow;
111:       }
112:     }
113: 
114:     throw FirebaseAuthException(
115:       code: 'rate-limit-exceeded',
116:       message: 'Authentication failed after $maxRetries retries',
117:     );
118:   }
119: 
120:   Future<UserModel?> signInWithGoogle() async {
121:     try {
122:       await _verifyConnectivityAndAppCheck();
123: 
124:       final GoogleSignInAccount? googleUser = await _googleSignIn.signIn();
125:       if (googleUser == null) {
126:         throw FirebaseAuthException(
127:           code: 'google-sign-in-cancelled',
128:           message: 'Google sign in was cancelled',
129:         );
130:       }
131: 
132:       final GoogleSignInAuthentication googleAuth =
133:           await googleUser.authentication;
134:       final credential = GoogleAuthProvider.credential(
135:         accessToken: googleAuth.accessToken,
136:         idToken: googleAuth.idToken,
137:       );
138: 
139:       final userCredential = await _auth.signInWithCredential(credential);
140:       await _clearGuestSession();
141:       return await _createOrUpdateUser(userCredential.user!);
142:     } catch (e) {
143:       _talker.severe('Error signing in with Google', e);
144:       rethrow;
145:     }
146:   }
147: 
148:   Future<UserModel?> signInAsGuest() async {
149:     try {
150:       _talker.info('Creating guest session');
151: 
152:       final userCredential = await _auth.signInAnonymously();
153:       final user = userCredential.user;
154: 
155:       if (user == null) {
156:         throw FirebaseAuthException(
157:           code: 'guest-session-failed',
158:           message: 'Failed to create guest session',
159:         );
160:       }
161: 
162:       final guestUser = UserModel(
163:         id: user.uid,
164:         displayName: 'Guest User',
165:         isGuest: true,
166:         isEmailVerified: false,
167:         createdAt: DateTime.now(),
168:         lastLoginAt: DateTime.now(),
169:       );
170: 
171:       await _firestore.collection('users').doc(user.uid).set({
172:         ...guestUser.toMap(),
173:         'lastLoginAt': FieldValue.serverTimestamp(),
174:       }, SetOptions(merge: true));
175: 
176:       _talker.info('Guest session created successfully with ID: ${user.uid}');
177:       return guestUser;
178:     } catch (e) {
179:       _talker.severe('Error creating guest session', e);
180:       throw FirebaseAuthException(
181:         code: 'guest-session-failed',
182:         message: 'Failed to create guest session: ${e.toString()}',
183:       );
184:     }
185:   }
186: 
187:   Future<bool> isGuestSession() async {
188:     try {
189:       final currentUser = _auth.currentUser;
190:       if (currentUser == null) return false;
191: 
192:       final doc =
193:           await _firestore.collection('users').doc(currentUser.uid).get();
194: 
195:       return doc.exists && (doc.data()?['isGuest'] ?? false);
196:     } catch (e) {
197:       _talker.severe('Error checking guest session', e);
198:       return false;
199:     }
200:   }
201: 
202:   Future<void> _clearGuestSession() async {
203:     try {
204:       final prefs = await SharedPreferences.getInstance();
205:       await prefs.remove(_guestPrefsKey);
206:     } catch (e) {
207:       _talker.severe('Error clearing guest session', e);
208:     }
209:   }
210: 
211:   Future<UserModel?> registerWithEmailPassword(
212:       String email, String password, String displayName) async {
213:     try {
214:       await _checkRateLimit(email.toLowerCase());
215:       await _verifyConnectivityAndAppCheck();
216: 
217:       final userCredential = await _auth
218:           .createUserWithEmailAndPassword(
219:             email: email.trim(),
220:             password: password,
221:           )
222:           .timeout(_timeout);
223: 
224:       final user = userCredential.user;
225:       if (user == null) {
226:         throw FirebaseAuthException(
227:           code: 'null-user',
228:           message: 'Failed to create user account',
229:         );
230:       }
231: 
232:       await user.updateDisplayName(displayName.trim());
233:       await user.sendEmailVerification();
234:       await _clearGuestSession();
235: 
236:       return await _createOrUpdateUser(user);
237:     } on FirebaseAuthException catch (e) {
238:       if (e.code == 'email-already-in-use') {
239:         _talker.warning('Email already in use: $email');
240:         return null;
241:       }
242:       rethrow;
243:     } catch (e) {
244:       _talker.severe('Error registering with email/password', e);
245:       rethrow;
246:     }
247:   }
248: 
249:   Future<void> signOut() async {
250:     try {
251:       final isGuest = await isGuestSession();
252:       final currentUser = _auth.currentUser;
253: 
254:       if (isGuest && currentUser != null) {
255:         await _firestore.collection('users').doc(currentUser.uid).delete();
256:         await currentUser.delete();
257:       }
258: 
259:       // Clear image cache on logout
260:       await CardCacheManager().emptyCache();
261: 
262:       await Future.wait([
263:         _auth.signOut(),
264:         _googleSignIn.signOut(),
265:       ]);
266:       _talker.info('User signed out successfully');
267:     } catch (e) {
268:       _talker.severe('Error signing out', e);
269:       rethrow;
270:     }
271:   }
272: 
273:   Future<UserModel?> getCurrentUser() async {
274:     try {
275:       final currentUser = _auth.currentUser;
276:       if (currentUser == null) return null;
277: 
278:       final doc =
279:           await _firestore.collection('users').doc(currentUser.uid).get();
280: 
281:       if (doc.exists) {
282:         return UserModel.fromFirestore(doc);
283:       }
284: 
285:       return null;
286:     } catch (e) {
287:       _talker.severe('Error getting current user', e);
288:       return null;
289:     }
290:   }
291: 
292:   Future<UserModel> _createOrUpdateUser(User user) async {
293:     final userDoc = _firestore.collection('users').doc(user.uid);
294: 
295:     final userData = UserModel(
296:       id: user.uid,
297:       email: user.email,
298:       displayName: user.displayName ?? 'User ${user.uid.substring(0, 4)}',
299:       photoURL: user.photoURL,
300:       isGuest: false,
301:       isEmailVerified: user.emailVerified,
302:       lastLoginAt: DateTime.now(),
303:       createdAt: DateTime.now(),
304:     );
305: 
306:     try {
307:       final doc = await userDoc.get();
308:       if (!doc.exists) {
309:         await userDoc.set(userData.toMap());
310:         _talker.info('Created new user document for ${user.uid}');
311:       } else {
312:         await userDoc.update({
313:           'lastLoginAt': Timestamp.fromDate(DateTime.now()),
314:           'email': user.email,
315:           'displayName': user.displayName,
316:           'photoURL': user.photoURL,
317:           'isEmailVerified': user.emailVerified,
318:         });
319:         _talker.info('Updated user document for ${user.uid}');
320:       }
321: 
322:       return userData;
323:     } catch (e) {
324:       _talker.severe('Error creating/updating user', e);
325:       throw FirebaseAuthException(
326:         code: 'user-update-failed',
327:         message: 'Failed to update user data: ${e.toString()}',
328:       );
329:     }
330:   }
331: 
332:   Future<void> sendEmailVerification() async {
333:     try {
334:       final user = _auth.currentUser;
335:       if (user != null && !user.emailVerified) {
336:         await user.sendEmailVerification().timeout(_timeout);
337:         _talker.info('Verification email sent to ${user.email}');
338:       }
339:     } catch (e) {
340:       _talker.severe('Error sending email verification', e);
341:       rethrow;
342:     }
343:   }
344: 
345:   Future<void> checkEmailVerification() async {
346:     try {
347:       final user = _auth.currentUser;
348:       if (user != null) {
349:         await user.reload().timeout(_timeout);
350:         _talker.info('Email verification status: ${user.emailVerified}');
351:       }
352:     } catch (e) {
353:       _talker.severe('Error checking email verification', e);
354:       rethrow;
355:     }
356:   }
357: 
358:   String getReadableAuthError(FirebaseAuthException e) {
359:     switch (e.code) {
360:       case 'too-many-requests':
361:         return e.message ?? 'Too many attempts. Please try again later.';
362:       case 'email-already-in-use':
363:         return 'An account already exists with this email. Please sign in or use a different email.';
364:       case 'invalid-email':
365:         return 'Please enter a valid email address.';
366:       case 'operation-not-allowed':
367:         return 'This sign-in method is not enabled. Please contact support.';
368:       case 'weak-password':
369:         return 'Please choose a stronger password (at least 6 characters).';
370:       case 'wrong-password':
371:         return 'Incorrect password. Please try again or reset your password.';
372:       case 'user-not-found':
373:         return 'No account found with this email. Please check the email or create an account.';
374:       case 'invalid-credential':
375:         return 'Invalid login credentials. Please check your email and password.';
376:       case 'network-request-failed':
377:         return 'Network error. Please check your connection and try again.';
378:       case 'user-disabled':
379:         return 'This account has been disabled. Please contact support.';
380:       case 'email-not-verified':
381:         return 'Please verify your email address. A verification email has been sent.';
382:       case 'app-check-failed':
383:         return 'App verification failed. Please try again or reinstall the app.';
384:       case 'no-connection':
385:         return 'No internet connection. Please check your connection and try again.';
386:       case 'google-sign-in-cancelled':
387:         return 'Google sign in was cancelled. Please try again.';
388:       default:
389:         return e.message ?? 'An error occurred. Please try again.';
390:     }
391:   }
392: 
393:   Future<UserModel?> linkWithGoogle() async {
394:     try {
395:       final currentUser = _auth.currentUser;
396:       if (currentUser == null) {
397:         throw FirebaseAuthException(
398:           code: 'no-current-user',
399:           message: 'No user is currently signed in',
400:         );
401:       }
402: 
403:       final GoogleSignInAccount? googleUser = await _googleSignIn.signIn();
404:       if (googleUser == null) {
405:         throw FirebaseAuthException(
406:           code: 'google-sign-in-cancelled',
407:           message: 'Google sign in was cancelled',
408:         );
409:       }
410: 
411:       final GoogleSignInAuthentication googleAuth =
412:           await googleUser.authentication;
413:       final credential = GoogleAuthProvider.credential(
414:         accessToken: googleAuth.accessToken,
415:         idToken: googleAuth.idToken,
416:       );
417: 
418:       try {
419:         final userCredential = await currentUser.linkWithCredential(credential);
420:         final linkedUser = userCredential.user;
421: 
422:         if (linkedUser == null) {
423:           throw FirebaseAuthException(
424:             code: 'linking-failed',
425:             message: 'Failed to link Google account',
426:           );
427:         }
428: 
429:         final userData = UserModel(
430:           id: linkedUser.uid,
431:           email: linkedUser.email,
432:           displayName: linkedUser.displayName ?? googleUser.displayName,
433:           photoURL: linkedUser.photoURL,
434:           isGuest: false,
435:           isEmailVerified: linkedUser.emailVerified,
436:           lastLoginAt: DateTime.now(),
437:         );
438: 
439:         await _firestore.collection('users').doc(linkedUser.uid).set(
440:               userData.toMap(),
441:               SetOptions(merge: true),
442:             );
443: 
444:         _talker.info('Successfully linked Google account: ${linkedUser.uid}');
445:         return userData;
446:       } on FirebaseAuthException catch (e) {
447:         if (e.code == 'credential-already-in-use') {
448:           _talker.warning('Google account already linked to another user');
449: 
450:           final existingCredential =
451:               await _auth.signInWithCredential(credential);
452:           final existingUser = existingCredential.user;
453: 
454:           if (existingUser != null) {
455:             await _firestore.collection('users').doc(currentUser.uid).delete();
456:             return await _createOrUpdateUser(existingUser);
457:           }
458:         }
459:         rethrow;
460:       }
461:     } catch (e) {
462:       _talker.severe('Error linking with Google', e);
463:       rethrow;
464:     }
465:   }
466: 
467:   Future<void> linkWithEmailPassword(String email, String password) async {
468:     try {
469:       final credential = EmailAuthProvider.credential(
470:         email: email,
471:         password: password,
472:       );
473:       await _auth.currentUser?.linkWithCredential(credential);
474:     } catch (e) {
475:       _talker.severe('Error linking with email/password', e);
476:       rethrow;
477:     }
478:   }
479: 
480:   Future<UserModel?> linkWithProvider(AuthCredential credential) async {
481:     try {
482:       final currentUser = _auth.currentUser;
483:       if (currentUser == null) {
484:         throw FirebaseAuthException(
485:           code: 'no-current-user',
486:           message: 'No user is currently signed in',
487:         );
488:       }
489: 
490:       try {
491:         await currentUser.linkWithCredential(credential);
492:         final updatedUser = _auth.currentUser!;
493:         await updatedUser.reload();
494:         return _createOrUpdateUser(updatedUser);
495:       } on FirebaseAuthException catch (e) {
496:         if (e.code == 'provider-already-linked') {
497:           return _handleExistingAccount(credential)
498:               .then((_) => getCurrentUser());
499:         }
500:         rethrow;
501:       }
502:     } catch (e) {
503:       _talker.severe('Error linking provider', e);
504:       rethrow;
505:     }
506:   }
507: 
508:   Future<bool> isProviderLinked(String providerId) async {
509:     final user = _auth.currentUser;
510:     if (user == null) return false;
511:     return user.providerData.any((info) => info.providerId == providerId);
512:   }
513: 
514:   Future<List<String>> getLinkedProviders() async {
515:     final user = _auth.currentUser;
516:     if (user == null) return [];
517:     return user.providerData.map((info) => info.providerId).toList();
518:   }
519: 
520:   Future<UserCredential?> _handleExistingAccount(
521:       AuthCredential credential) async {
522:     try {
523:       return await _auth.signInWithCredential(credential);
524:     } on FirebaseAuthException catch (e) {
525:       if (e.code == 'account-exists-with-different-credential') {
526:         final googleUser = await GoogleSignIn().signIn();
527: 
528:         if (googleUser != null) {
529:           final googleAuth = await googleUser.authentication;
530:           final googleCredential = GoogleAuthProvider.credential(
531:             accessToken: googleAuth.accessToken,
532:             idToken: googleAuth.idToken,
533:           );
534:           return await _auth.signInWithCredential(googleCredential);
535:         }
536:       }
537:       rethrow;
538:     }
539:   }
540: }
</file>

<file path="lib/features/cards/models/card_extended_data.dart">
 1: import 'package:hive/hive.dart';
 2: 
 3: part 'card_extended_data.g.dart';
 4: 
 5: @HiveType(typeId: 2)
 6: class CardExtendedData {
 7:   @HiveField(0)
 8:   final String displayName;
 9: 
10:   @HiveField(1)
11:   final String name;
12: 
13:   @HiveField(2)
14:   final String value;
15: 
16:   const CardExtendedData({
17:     required this.displayName,
18:     required this.name,
19:     required this.value,
20:   });
21: 
22:   factory CardExtendedData.fromMap(Map<String, dynamic> map) {
23:     return CardExtendedData(
24:       displayName: map['displayName'] as String,
25:       name: map['name'] as String,
26:       value: map['value'] as String,
27:     );
28:   }
29: 
30:   Map<String, dynamic> toMap() {
31:     return {
32:       'displayName': displayName,
33:       'name': name,
34:       'value': value,
35:     };
36:   }
37: 
38:   CardExtendedData copyWith({
39:     String? displayName,
40:     String? name,
41:     String? value,
42:   }) {
43:     return CardExtendedData(
44:       displayName: displayName ?? this.displayName,
45:       name: name ?? this.name,
46:       value: value ?? this.value,
47:     );
48:   }
49: 
50:   @override
51:   String toString() {
52:     return 'CardExtendedData(displayName: $displayName, name: $name, value: $value)';
53:   }
54: }
</file>

<file path="lib/features/cards/models/card_filter_options.dart">
 1: enum CardSortOption {
 2:   nameAsc,
 3:   nameDesc,
 4:   costAsc,
 5:   costDesc,
 6:   powerAsc,
 7:   powerDesc,
 8:   setNumber,
 9:   releaseDate
10: }
11: 
12: class CardFilterOptions {
13:   final List<String>? elements;
14:   final String? cardType;
15:   final List<String>? costs;
16:   final List<String>? rarities;
17:   final String? job;
18:   final String? category;
19:   final List<String>? opus;
20:   final String? powerRange; // e.g., "1000-5000"
21:   final CardSortOption sortOption;
22:   final bool ascending;
23: 
24:   const CardFilterOptions({
25:     this.elements,
26:     this.cardType,
27:     this.costs,
28:     this.rarities,
29:     this.job,
30:     this.category,
31:     this.opus,
32:     this.powerRange,
33:     this.sortOption = CardSortOption.setNumber,
34:     this.ascending = true,
35:   });
36: 
37:   CardFilterOptions copyWith({
38:     List<String>? elements,
39:     String? cardType,
40:     List<String>? costs,
41:     List<String>? rarities,
42:     String? job,
43:     String? category,
44:     List<String>? opus,
45:     String? powerRange,
46:     CardSortOption? sortOption,
47:     bool? ascending,
48:   }) {
49:     return CardFilterOptions(
50:       elements: elements ?? this.elements,
51:       cardType: cardType ?? this.cardType,
52:       costs: costs ?? this.costs,
53:       rarities: rarities ?? this.rarities,
54:       job: job ?? this.job,
55:       category: category ?? this.category,
56:       opus: opus ?? this.opus,
57:       powerRange: powerRange ?? this.powerRange,
58:       sortOption: sortOption ?? this.sortOption,
59:       ascending: ascending ?? this.ascending,
60:     );
61:   }
62: 
63:   Map<String, dynamic> toJson() {
64:     return {
65:       'elements': elements,
66:       'cardType': cardType,
67:       'costs': costs,
68:       'rarities': rarities,
69:       'job': job,
70:       'category': category,
71:       'opus': opus,
72:       'powerRange': powerRange,
73:       'sortOption': sortOption.index,
74:       'ascending': ascending,
75:     };
76:   }
77: 
78:   factory CardFilterOptions.fromJson(Map<String, dynamic> json) {
79:     return CardFilterOptions(
80:       elements: (json['elements'] as List?)?.cast<String>(),
81:       cardType: json['cardType'] as String?,
82:       costs: (json['costs'] as List?)?.cast<String>(),
83:       rarities: (json['rarities'] as List?)?.cast<String>(),
84:       job: json['job'] as String?,
85:       category: json['category'] as String?,
86:       opus: (json['opus'] as List?)?.cast<String>(),
87:       powerRange: json['powerRange'] as String?,
88:       sortOption: CardSortOption.values[json['sortOption'] as int],
89:       ascending: json['ascending'] as bool,
90:     );
91:   }
92: 
93:   @override
94:   String toString() {
95:     return 'CardFilterOptions(elements: $elements, cardType: $cardType, costs: $costs, rarities: $rarities, job: $job, category: $category, opus: $opus, powerRange: $powerRange, sortOption: $sortOption, ascending: $ascending)';
96:   }
97: }
</file>

<file path="lib/features/cards/models/card_image_metadata.dart">
 1: import 'package:hive/hive.dart';
 2: import 'package:cloud_firestore/cloud_firestore.dart';
 3: 
 4: part 'card_image_metadata.g.dart';
 5: 
 6: @HiveType(typeId: 3)
 7: class CardImageMetadata {
 8:   @HiveField(0)
 9:   final String contentType;
10: 
11:   @HiveField(1)
12:   final String hash;
13: 
14:   @HiveField(2)
15:   final int highResSize;
16: 
17:   @HiveField(3)
18:   final int lowResSize;
19: 
20:   @HiveField(4)
21:   final int originalSize;
22: 
23:   @HiveField(5)
24:   final int size;
25: 
26:   @HiveField(6)
27:   final DateTime updated;
28: 
29:   const CardImageMetadata({
30:     required this.contentType,
31:     required this.hash,
32:     required this.highResSize,
33:     required this.lowResSize,
34:     required this.originalSize,
35:     required this.size,
36:     required this.updated,
37:   });
38: 
39:   factory CardImageMetadata.fromMap(Map<String, dynamic> map) {
40:     return CardImageMetadata(
41:       contentType: map['contentType'] as String? ?? '',
42:       hash: map['hash'] as String? ?? '',
43:       highResSize: map['highResSize'] as int? ?? 0,
44:       lowResSize: map['lowResSize'] as int? ?? 0,
45:       originalSize: map['originalSize'] as int? ?? 0,
46:       size: map['size'] as int? ?? 0,
47:       updated: (map['updated'] as Timestamp?)?.toDate() ?? DateTime.now(),
48:     );
49:   }
50: 
51:   Map<String, dynamic> toMap() {
52:     return {
53:       'contentType': contentType,
54:       'hash': hash,
55:       'highResSize': highResSize,
56:       'lowResSize': lowResSize,
57:       'originalSize': originalSize,
58:       'size': size,
59:       'updated': Timestamp.fromDate(updated),
60:     };
61:   }
62: 
63:   CardImageMetadata copyWith({
64:     String? contentType,
65:     String? hash,
66:     int? highResSize,
67:     int? lowResSize,
68:     int? originalSize,
69:     int? size,
70:     DateTime? updated,
71:   }) {
72:     return CardImageMetadata(
73:       contentType: contentType ?? this.contentType,
74:       hash: hash ?? this.hash,
75:       highResSize: highResSize ?? this.highResSize,
76:       lowResSize: lowResSize ?? this.lowResSize,
77:       originalSize: originalSize ?? this.originalSize,
78:       size: size ?? this.size,
79:       updated: updated ?? this.updated,
80:     );
81:   }
82: 
83:   @override
84:   String toString() {
85:     return 'CardImageMetadata(contentType: $contentType, hash: $hash, highResSize: $highResSize, lowResSize: $lowResSize, originalSize: $originalSize, size: $size, updated: $updated)';
86:   }
87: }
</file>

<file path="lib/features/cards/models/favorite_card.dart">
 1: // lib/features/cards/models/favorite_card.dart
 2: import 'package:hive/hive.dart';
 3: 
 4: part 'favorite_card.g.dart';
 5: 
 6: @HiveType(typeId: 4)
 7: class FavoriteCard extends HiveObject {
 8:   @HiveField(0)
 9:   final String productId;
10: 
11:   @HiveField(1)
12:   final DateTime addedAt;
13: 
14:   FavoriteCard({
15:     required this.productId,
16:     required this.addedAt,
17:   });
18: 
19:   Map<String, dynamic> toMap() => {
20:         'productId': productId,
21:         'addedAt': addedAt.toIso8601String(),
22:       };
23: 
24:   factory FavoriteCard.fromMap(Map<String, dynamic> map) => FavoriteCard(
25:         productId: map['productId'],
26:         addedAt: DateTime.parse(map['addedAt']),
27:       );
28: 
29:   @override
30:   String toString() => 'FavoriteCard(productId: $productId, addedAt: $addedAt)';
31: }
</file>

<file path="lib/features/cards/models/fftcg_card.dart">
  1: // lib/features/cards/models/fftcg_card.dart
  2: 
  3: import 'package:cloud_firestore/cloud_firestore.dart';
  4: import 'package:hive/hive.dart';
  5: import '../../../core/models/sync_status.dart';
  6: import 'card_image_metadata.dart';
  7: import 'card_extended_data.dart';
  8: 
  9: part 'fftcg_card.g.dart';
 10: 
 11: @HiveType(typeId: 1)
 12: class FFTCGCard extends HiveObject {
 13:   @HiveField(0)
 14:   final int categoryId;
 15: 
 16:   @HiveField(1)
 17:   final String cleanName;
 18: 
 19:   @HiveField(2)
 20:   final List<CardExtendedData> extendedData;
 21: 
 22:   @HiveField(3)
 23:   final String groupHash;
 24: 
 25:   @HiveField(4)
 26:   final int groupId;
 27: 
 28:   @HiveField(5)
 29:   final String highResUrl;
 30: 
 31:   @HiveField(6)
 32:   final int imageCount;
 33: 
 34:   @HiveField(7)
 35:   final CardImageMetadata imageMetadata;
 36: 
 37:   @HiveField(8)
 38:   final DateTime lastUpdated;
 39: 
 40:   @HiveField(9)
 41:   final String lowResUrl;
 42: 
 43:   @HiveField(10)
 44:   final String? modifiedOn;
 45: 
 46:   @HiveField(11)
 47:   final String name;
 48: 
 49:   @HiveField(12)
 50:   final String originalUrl;
 51: 
 52:   @HiveField(13)
 53:   final bool isPresale;
 54: 
 55:   @HiveField(14)
 56:   final int productId;
 57: 
 58:   @HiveField(15)
 59:   final String url;
 60: 
 61:   @HiveField(16)
 62:   SyncStatus syncStatus;
 63: 
 64:   @HiveField(17)
 65:   DateTime? lastModifiedLocally;
 66: 
 67:   String get effectiveHighResUrl => _getEffectiveUrl(highResUrl);
 68:   String get effectiveLowResUrl => _getEffectiveUrl(lowResUrl);
 69: 
 70:   // Convenience getters for common card properties
 71:   String? get cardNumber => _getExtendedValue('Number');
 72:   String? get description => _getExtendedValue('Description');
 73:   String? get cardType => _getExtendedValue('CardType');
 74:   List<String> get elements => _getExtendedValue('Element')?.split(',') ?? [];
 75:   String? get cost => _getExtendedValue('Cost');
 76:   String? get power => _getExtendedValue('Power');
 77:   String? get job => _getExtendedValue('Job');
 78:   String? get category => _getExtendedValue('Category');
 79:   String? get rarity => _getExtendedValue('Rarity');
 80: 
 81:   String _getEffectiveUrl(String url) {
 82:     if (url.isEmpty) return FFTCGCard.defaultImageUrl;
 83: 
 84:     // Convert Firebase Storage URLs to CDN URLs
 85:     if (url.contains('firebasestorage.googleapis.com')) {
 86:       final uri = Uri.parse(url);
 87:       final filename = uri.pathSegments.last;
 88:       return 'https://fftcgcompanion.com/card-images/$filename';
 89:     }
 90:     return url;
 91:   }
 92: 
 93:   static const String defaultImageUrl =
 94:       'https://fftcgcompanion.com/card-images/image-coming-soon.jpeg';
 95: 
 96:   FFTCGCard({
 97:     required this.categoryId,
 98:     required this.cleanName,
 99:     required this.extendedData,
100:     required this.groupHash,
101:     required this.groupId,
102:     required this.highResUrl,
103:     required this.imageCount,
104:     required this.imageMetadata,
105:     required this.lastUpdated,
106:     required this.lowResUrl,
107:     required this.name,
108:     required this.originalUrl,
109:     required this.isPresale,
110:     required this.productId,
111:     required this.url,
112:     this.modifiedOn,
113:     this.syncStatus = SyncStatus.synced,
114:     this.lastModifiedLocally,
115:   });
116: 
117:   String? _getExtendedValue(String name) {
118:     return extendedData
119:         .firstWhere(
120:           (data) => data.name == name,
121:           orElse: () => const CardExtendedData(
122:             displayName: '',
123:             name: '',
124:             value: '',
125:           ),
126:         )
127:         .value;
128:   }
129: 
130:   factory FFTCGCard.fromFirestore(DocumentSnapshot doc) {
131:     final data = doc.data() as Map<String, dynamic>? ?? {};
132: 
133:     final imageMetadataMap =
134:         (data['imageMetadata'] as Map<String, dynamic>?) ?? {};
135: 
136:     return FFTCGCard(
137:       categoryId: data['categoryId'] as int? ?? 0,
138:       cleanName: data['cleanName'] as String? ?? '',
139:       extendedData: (data['extendedData'] as List<dynamic>?)
140:               ?.map((e) => CardExtendedData.fromMap(e as Map<String, dynamic>))
141:               .toList() ??
142:           [],
143:       groupHash: data['groupHash'] as String? ?? '',
144:       groupId: data['groupId'] as int? ?? 0,
145:       highResUrl: data['highResUrl'] as String? ?? '',
146:       imageCount: data['imageCount'] as int? ?? 0,
147:       imageMetadata: CardImageMetadata.fromMap(imageMetadataMap),
148:       lastUpdated:
149:           (data['lastUpdated'] as Timestamp?)?.toDate() ?? DateTime.now(),
150:       lowResUrl: data['lowResUrl'] as String? ?? '',
151:       modifiedOn: data['modifiedOn'] as String?,
152:       name: data['name'] as String? ?? '',
153:       originalUrl: data['originalUrl'] as String? ?? '',
154:       isPresale: data['presaleInfo']?['isPresale'] as bool? ?? false,
155:       productId: data['productId'] as int? ?? 0,
156:       url: data['url'] as String? ?? '',
157:     );
158:   }
159: 
160:   Map<String, dynamic> toMap() {
161:     return {
162:       'categoryId': categoryId,
163:       'cleanName': cleanName,
164:       'extendedData': extendedData.map((e) => e.toMap()).toList(),
165:       'groupHash': groupHash,
166:       'groupId': groupId,
167:       'highResUrl': highResUrl,
168:       'imageCount': imageCount,
169:       'imageMetadata': imageMetadata.toMap(),
170:       'lastUpdated': Timestamp.fromDate(lastUpdated),
171:       'lowResUrl': lowResUrl,
172:       'modifiedOn': modifiedOn,
173:       'name': name,
174:       'originalUrl': originalUrl,
175:       'presaleInfo': {
176:         'isPresale': isPresale,
177:         'note': null,
178:         'releasedOn': null,
179:       },
180:       'productId': productId,
181:       'url': url,
182:     };
183:   }
184: 
185:   factory FFTCGCard.fromJson(Map<String, dynamic> json, String cardNumber) {
186:     return FFTCGCard(
187:       categoryId: json['categoryId'] as int? ?? 0,
188:       cleanName: json['cleanName'] as String? ?? '',
189:       extendedData: (json['extendedData'] as List<dynamic>?)
190:               ?.map((e) => CardExtendedData.fromMap(e as Map<String, dynamic>))
191:               .toList() ??
192:           [],
193:       groupHash: json['groupHash'] as String? ?? '',
194:       groupId: json['groupId'] as int? ?? 0,
195:       highResUrl: json['highResUrl'] as String? ?? '',
196:       imageCount: json['imageCount'] as int? ?? 0,
197:       imageMetadata: CardImageMetadata.fromMap(json['imageMetadata'] ?? {}),
198:       lastUpdated: DateTime.parse(json['lastUpdated']),
199:       lowResUrl: json['lowResUrl'] as String? ?? '',
200:       modifiedOn: json['modifiedOn'] as String?,
201:       name: json['name'] as String? ?? '',
202:       originalUrl: json['originalUrl'] as String? ?? '',
203:       isPresale: json['presaleInfo']?['isPresale'] as bool? ?? false,
204:       productId: json['productId'] as int? ?? 0,
205:       url: json['url'] as String? ?? '',
206:       syncStatus: SyncStatus.values[json['syncStatus'] as int? ?? 0],
207:       lastModifiedLocally: json['lastModifiedLocally'] != null
208:           ? DateTime.parse(json['lastModifiedLocally'])
209:           : null,
210:     );
211:   }
212: 
213:   Map<String, dynamic> toJson() {
214:     return {
215:       'categoryId': categoryId,
216:       'cleanName': cleanName,
217:       'extendedData': extendedData.map((e) => e.toMap()).toList(),
218:       'groupHash': groupHash,
219:       'groupId': groupId,
220:       'highResUrl': highResUrl,
221:       'imageCount': imageCount,
222:       'imageMetadata': imageMetadata.toMap(),
223:       'lastUpdated': lastUpdated.toIso8601String(),
224:       'lowResUrl': lowResUrl,
225:       
226:       'modifiedOn': modifiedOn,
227:       'name': name,
228:       'originalUrl': originalUrl,
229:       'presaleInfo': {
230:         'isPresale': isPresale,
231:         'note': null,
232:         'releasedOn': null,
233:       },
234:       'productId': productId,
235:       'url': url,
236:       'syncStatus': syncStatus.index,
237:       'lastModifiedLocally': lastModifiedLocally?.toIso8601String(),
238:     };
239:   }
240: 
241:   void markForSync() {
242:     syncStatus = SyncStatus.pending;
243:     lastModifiedLocally = DateTime.now();
244:     save();
245:   }
246: 
247:   void markSynced() {
248:     syncStatus = SyncStatus.synced;
249:     lastModifiedLocally = null;
250:     save();
251:   }
252: 
253:   void markError() {
254:     syncStatus = SyncStatus.error;
255:     save();
256:   }
257: 
258:   FFTCGCard copyWith({
259:     int? categoryId,
260:     String? cleanName,
261:     List<CardExtendedData>? extendedData,
262:     String? groupHash,
263:     int? groupId,
264:     String? highResUrl,
265:     int? imageCount,
266:     CardImageMetadata? imageMetadata,
267:     DateTime? lastUpdated,
268:     String? lowResUrl,
269:     String? modifiedOn,
270:     String? name,
271:     String? originalUrl,
272:     bool? isPresale,
273:     int? productId,
274:     String? url,
275:     SyncStatus? syncStatus,
276:     DateTime? lastModifiedLocally,
277:   }) {
278:     return FFTCGCard(
279:       categoryId: categoryId ?? this.categoryId,
280:       cleanName: cleanName ?? this.cleanName,
281:       extendedData: extendedData ?? this.extendedData,
282:       groupHash: groupHash ?? this.groupHash,
283:       groupId: groupId ?? this.groupId,
284:       highResUrl: highResUrl ?? this.highResUrl,
285:       imageCount: imageCount ?? this.imageCount,
286:       imageMetadata: imageMetadata ?? this.imageMetadata,
287:       lastUpdated: lastUpdated ?? this.lastUpdated,
288:       lowResUrl: lowResUrl ?? this.lowResUrl,
289:       modifiedOn: modifiedOn ?? this.modifiedOn,
290:       name: name ?? this.name,
291:       originalUrl: originalUrl ?? this.originalUrl,
292:       isPresale: isPresale ?? this.isPresale,
293:       productId: productId ?? this.productId,
294:       url: url ?? this.url,
295:       syncStatus: syncStatus ?? this.syncStatus,
296:       lastModifiedLocally: lastModifiedLocally ?? this.lastModifiedLocally,
297:     );
298:   }
299: }
</file>

<file path="lib/features/cards/models/price_model.dart">
 1: // lib/features/cards/models/price_model.dart
 2: 
 3: import 'package:cloud_firestore/cloud_firestore.dart';
 4: 
 5: class PriceData {
 6:   final double? directLowPrice;
 7:   final double highPrice;
 8:   final double lowPrice;
 9:   final double marketPrice;
10:   final double midPrice;
11:   final String subTypeName;
12: 
13:   PriceData({
14:     this.directLowPrice,
15:     required this.highPrice,
16:     required this.lowPrice,
17:     required this.marketPrice,
18:     required this.midPrice,
19:     required this.subTypeName,
20:   });
21: 
22:   factory PriceData.fromMap(Map<String, dynamic> map) => PriceData(
23:         directLowPrice: map['directLowPrice']?.toDouble(),
24:         highPrice: map['highPrice']?.toDouble() ?? 0.0,
25:         lowPrice: map['lowPrice']?.toDouble() ?? 0.0,
26:         marketPrice: map['marketPrice']?.toDouble() ?? 0.0,
27:         midPrice: map['midPrice']?.toDouble() ?? 0.0,
28:         subTypeName: map['subTypeName'] ?? '',
29:       );
30: 
31:   Map<String, dynamic> toMap() => {
32:         'directLowPrice': directLowPrice,
33:         'highPrice': highPrice,
34:         'lowPrice': lowPrice,
35:         'marketPrice': marketPrice,
36:         'midPrice': midPrice,
37:         'subTypeName': subTypeName,
38:       };
39: }
40: 
41: class PriceModel {
42:   final String productId;
43:   final PriceData? normal;
44:   final PriceData? foil;
45:   final DateTime lastUpdated;
46:   final DateTime? date;
47:   final int groupId;
48: 
49:   PriceModel({
50:     required this.productId,
51:     this.normal,
52:     this.foil,
53:     required this.lastUpdated,
54:     this.date,
55:     required this.groupId,
56:   });
57: 
58:   factory PriceModel.fromFirestore(DocumentSnapshot doc) {
59:     final data = doc.data() as Map<String, dynamic>;
60:     return PriceModel(
61:       productId: doc.id,
62:       normal: data['normal'] != null ? PriceData.fromMap(data['normal']) : null,
63:       foil: data['foil'] != null ? PriceData.fromMap(data['foil']) : null,
64:       lastUpdated: (data['lastUpdated'] as Timestamp).toDate(),
65:       date: data['date'] != null ? (data['date'] as Timestamp).toDate() : null,
66:       groupId: data['groupId'] as int? ?? 0,
67:     );
68:   }
69: 
70:   Map<String, dynamic> toMap() => {
71:         'productId': productId,
72:         'normal': normal?.toMap(),
73:         'foil': foil?.toMap(),
74:         'lastUpdated': Timestamp.fromDate(lastUpdated),
75:         'groupId': groupId,
76:         if (date != null) 'date': Timestamp.fromDate(date!),
77:       };
78: 
79:       factory PriceModel.fromJson(Map<String, dynamic> json, String productId) {
80:     return PriceModel(
81:       productId: productId,
82:       normal: json['normal'] != null ? PriceData.fromMap(json['normal']) : null,
83:       foil: json['foil'] != null ? PriceData.fromMap(json['foil']) : null,
84:       lastUpdated: DateTime.parse(json['lastUpdated']),
85:       date: json['date'] != null ? DateTime.parse(json['date']) : null,
86:       groupId: json['groupId'] ?? 0,
87:     );
88:   }
89: 
90:   Map<String, dynamic> toJson() => {
91:         'productId': productId,
92:         'normal': normal?.toMap(),
93:         'foil': foil?.toMap(),
94:         'lastUpdated': lastUpdated.toIso8601String(),
95:         'groupId': groupId,
96:         if (date != null) 'date': date!.toIso8601String(),
97:       };
98: }
</file>

<file path="lib/features/cards/presentation/screens/card_detail_screen.dart">
  1: // lib/features/cards/presentation/screens/card_detail_screen.dart
  2: 
  3: import 'package:flutter/material.dart';
  4: import 'package:flutter_riverpod/flutter_riverpod.dart';
  5: import 'package:cached_network_image/cached_network_image.dart';
  6: import 'package:fl_chart/fl_chart.dart';
  7: import '../../models/fftcg_card.dart';
  8: import '../../models/price_model.dart';
  9: import '../../providers/favorites_provider.dart';
 10: import '../../../../services/firestore_service.dart';
 11: import '../../../../core/logging/talker_service.dart';
 12: 
 13: final cardPriceProvider =
 14:     FutureProvider.family<PriceModel?, String>((ref, productId) async {
 15:   final firestoreService = ref.watch(firestoreServiceProvider);
 16:   final result = await firestoreService.getCurrentPrice(productId.toString());
 17:   return result.data;
 18: });
 19: 
 20: final priceHistoryProvider =
 21:     FutureProvider.family<List<PriceModel>, String>((ref, productId) async {
 22:   final firestoreService = ref.watch(firestoreServiceProvider);
 23:   final result = await firestoreService.getPriceHistory(productId.toString());
 24:   return result.data ?? [];
 25: });
 26: 
 27: class CardDetailScreen extends ConsumerStatefulWidget {
 28:   final FFTCGCard card;
 29: 
 30:   const CardDetailScreen({super.key, required this.card});
 31: 
 32:   @override
 33:   ConsumerState<CardDetailScreen> createState() => _CardDetailScreenState();
 34: }
 35: 
 36: class _CardDetailScreenState extends ConsumerState<CardDetailScreen> {
 37:   bool _showHighResImage = false;
 38:   final _talker = TalkerService();
 39: 
 40:   Widget _buildCardImage() {
 41:     final cardNumber = widget.card.cardNumber ?? 'unknown';
 42:     final imageUrl = _showHighResImage
 43:         ? widget.card.effectiveHighResUrl
 44:         : widget.card.effectiveLowResUrl;
 45: 
 46:     return AspectRatio(
 47:       aspectRatio: 0.7,
 48:       child: Hero(
 49:         tag: 'card_$cardNumber',
 50:         child: CachedNetworkImage(
 51:           imageUrl: imageUrl,
 52:           fit: BoxFit.contain,
 53:           placeholder: (context, url) => const Center(
 54:             child: CircularProgressIndicator(),
 55:           ),
 56:           errorWidget: (context, url, error) {
 57:             _talker.severe('Error loading image', error);
 58:             return Center(
 59:               child: Column(
 60:                 mainAxisAlignment: MainAxisAlignment.center,
 61:                 children: [
 62:                   Icon(
 63:                     Icons.broken_image,
 64:                     color: Theme.of(context).colorScheme.error,
 65:                   ),
 66:                   const SizedBox(height: 8),
 67:                   const Text('Image not available'),
 68:                 ],
 69:               ),
 70:             );
 71:           },
 72:         ),
 73:       ),
 74:     );
 75:   }
 76: 
 77:   Widget _buildCardInfo() {
 78:     return Padding(
 79:       padding: const EdgeInsets.all(16.0),
 80:       child: Column(
 81:         crossAxisAlignment: CrossAxisAlignment.start,
 82:         children: [
 83:           Text(
 84:             widget.card.name,
 85:             style: Theme.of(context).textTheme.titleLarge,
 86:           ),
 87:           const SizedBox(height: 8),
 88:           if (widget.card.cardNumber != null)
 89:             Text('Card Number: ${widget.card.cardNumber}'),
 90:           if (widget.card.elements.isNotEmpty) ...[
 91:             const SizedBox(height: 8),
 92:             Wrap(
 93:               spacing: 8,
 94:               children: widget.card.elements
 95:                   .map((element) => Chip(label: Text(element)))
 96:                   .toList(),
 97:             ),
 98:           ],
 99:           if (widget.card.cost != null) ...[
100:             const SizedBox(height: 8),
101:             Text('Cost: ${widget.card.cost}'),
102:           ],
103:           if (widget.card.power != null) ...[
104:             const SizedBox(height: 8),
105:             Text('Power: ${widget.card.power}'),
106:           ],
107:         ],
108:       ),
109:     );
110:   }
111: 
112:   LineChartData _createChartData(
113:       List<FlSpot> normalPrices, List<FlSpot> foilPrices) {
114:     return LineChartData(
115:       gridData: const FlGridData(show: true),
116:       titlesData: _createTitlesData(),
117:       borderData: FlBorderData(show: true),
118:       lineBarsData: _createLineBarsData(normalPrices, foilPrices),
119:       lineTouchData: _createLineTouchData(),
120:     );
121:   }
122: 
123:   FlTitlesData _createTitlesData() {
124:     return FlTitlesData(
125:       bottomTitles: AxisTitles(
126:         sideTitles: SideTitles(
127:           showTitles: true,
128:           getTitlesWidget: (value, meta) {
129:             final date = DateTime.fromMillisecondsSinceEpoch(value.toInt());
130:             return Text(
131:               '${date.month}/${date.day}',
132:               style: const TextStyle(fontSize: 10),
133:             );
134:           },
135:           interval: 86400000 * 7, // 7 days
136:         ),
137:       ),
138:       leftTitles: AxisTitles(
139:         sideTitles: SideTitles(
140:           showTitles: true,
141:           getTitlesWidget: (value, meta) {
142:             return Text(
143:               '\$${value.toStringAsFixed(2)}',
144:               style: const TextStyle(fontSize: 10),
145:             );
146:           },
147:           interval: 1,
148:         ),
149:       ),
150:       rightTitles: const AxisTitles(
151:         sideTitles: SideTitles(showTitles: false),
152:       ),
153:       topTitles: const AxisTitles(
154:         sideTitles: SideTitles(showTitles: false),
155:       ),
156:     );
157:   }
158: 
159:   List<LineChartBarData> _createLineBarsData(
160:       List<FlSpot> normalPrices, List<FlSpot> foilPrices) {
161:     return [
162:       if (normalPrices.isNotEmpty)
163:         LineChartBarData(
164:           spots: normalPrices,
165:           isCurved: true,
166:           color: Colors.blue,
167:           dotData: const FlDotData(show: false),
168:           belowBarData: BarAreaData(show: false),
169:         ),
170:       if (foilPrices.isNotEmpty)
171:         LineChartBarData(
172:           spots: foilPrices,
173:           isCurved: true,
174:           color: Colors.purple,
175:           dotData: const FlDotData(show: false),
176:           belowBarData: BarAreaData(show: false),
177:         ),
178:     ];
179:   }
180: 
181:   LineTouchData _createLineTouchData() {
182:     return LineTouchData(
183:       touchTooltipData: LineTouchTooltipData(
184:         tooltipRoundedRadius: 8,
185:         tooltipPadding: const EdgeInsets.all(8),
186:         tooltipMargin: 4,
187:         fitInsideHorizontally: true,
188:         fitInsideVertically: true,
189:         getTooltipItems: (touchedSpots) {
190:           return touchedSpots.map((spot) {
191:             final date = DateTime.fromMillisecondsSinceEpoch(spot.x.toInt());
192:             return LineTooltipItem(
193:               '${date.month}/${date.day}\n\$${spot.y.toStringAsFixed(2)}',
194:               const TextStyle(color: Colors.white),
195:             );
196:           }).toList();
197:         },
198:       ),
199:     );
200:   }
201: 
202:   Widget _buildPriceHistory(List<PriceModel> priceHistory) {
203:     if (priceHistory.isEmpty) return const SizedBox.shrink();
204: 
205:     final normalPrices = priceHistory
206:         .where((p) => p.normal != null)
207:         .map((p) => FlSpot(
208:               p.date!.millisecondsSinceEpoch.toDouble(),
209:               p.normal!.marketPrice,
210:             ))
211:         .toList();
212: 
213:     final foilPrices = priceHistory
214:         .where((p) => p.foil != null)
215:         .map((p) => FlSpot(
216:               p.date!.millisecondsSinceEpoch.toDouble(),
217:               p.foil!.marketPrice,
218:             ))
219:         .toList();
220: 
221:     return Column(
222:       crossAxisAlignment: CrossAxisAlignment.start,
223:       children: [
224:         Padding(
225:           padding: const EdgeInsets.all(16),
226:           child: Text(
227:             'Price History',
228:             style: Theme.of(context).textTheme.titleLarge,
229:           ),
230:         ),
231:         SizedBox(
232:           height: 300,
233:           child: Padding(
234:             padding: const EdgeInsets.all(16),
235:             child: LineChart(_createChartData(normalPrices, foilPrices)),
236:           ),
237:         ),
238:         _buildPriceLegend(),
239:       ],
240:     );
241:   }
242: 
243:   Widget _buildPriceLegend() {
244:     return Padding(
245:       padding: const EdgeInsets.symmetric(horizontal: 16),
246:       child: Row(
247:         mainAxisAlignment: MainAxisAlignment.center,
248:         children: [
249:           _buildLegendItem('Normal', Colors.blue),
250:           const SizedBox(width: 20),
251:           _buildLegendItem('Foil', Colors.purple),
252:         ],
253:       ),
254:     );
255:   }
256: 
257:   Widget _buildLegendItem(String label, Color color) {
258:     return Row(
259:       children: [
260:         Container(
261:           width: 16,
262:           height: 2,
263:           color: color,
264:         ),
265:         const SizedBox(width: 4),
266:         Text(label),
267:       ],
268:     );
269:   }
270: 
271:   Widget _buildPriceSection(PriceModel? price) {
272:     return Padding(
273:       padding: const EdgeInsets.all(16),
274:       child: Column(
275:         crossAxisAlignment: CrossAxisAlignment.start,
276:         children: [
277:           Text(
278:             'Current Prices',
279:             style: Theme.of(context).textTheme.titleLarge,
280:           ),
281:           if (price?.normal != null) ...[
282:             const SizedBox(height: 8),
283:             _buildPriceRow('Market Price', price!.normal!.marketPrice),
284:             _buildPriceRow('Low Price', price.normal!.lowPrice),
285:             _buildPriceRow('High Price', price.normal!.highPrice),
286:             if (price.normal!.directLowPrice != null)
287:               _buildPriceRow('Direct Low', price.normal!.directLowPrice!),
288:           ],
289:           if (price?.foil != null) ...[
290:             const SizedBox(height: 16),
291:             Text('Foil Prices', style: Theme.of(context).textTheme.titleMedium),
292:             const SizedBox(height: 8),
293:             _buildPriceRow('Market Price', price!.foil!.marketPrice),
294:             _buildPriceRow('Low Price', price.foil!.lowPrice),
295:             _buildPriceRow('High Price', price.foil!.highPrice),
296:             if (price.foil!.directLowPrice != null)
297:               _buildPriceRow('Direct Low', price.foil!.directLowPrice!),
298:           ],
299:         ],
300:       ),
301:     );
302:   }
303: 
304:   Widget _buildPriceRow(String label, double price) {
305:     return Padding(
306:       padding: const EdgeInsets.symmetric(vertical: 4),
307:       child: Row(
308:         mainAxisAlignment: MainAxisAlignment.spaceBetween,
309:         children: [
310:           Text(label),
311:           Text(
312:             '\$${price.toStringAsFixed(2)}',
313:             style: const TextStyle(fontWeight: FontWeight.bold),
314:           ),
315:         ],
316:       ),
317:     );
318:   }
319: 
320:   @override
321:   Widget build(BuildContext context) {
322:     final priceAsync =
323:         ref.watch(cardPriceProvider(widget.card.productId.toString()));
324:     final priceHistoryAsync =
325:         ref.watch(priceHistoryProvider(widget.card.productId.toString()));
326:     final isFavorite = ref
327:         .watch(favoritesProvider.notifier)
328:         .isFavorite(widget.card.productId.toString());
329: 
330:     return Scaffold(
331:       appBar: AppBar(
332:         title: Text(widget.card.name),
333:         actions: [
334:           IconButton(
335:             icon: Icon(isFavorite ? Icons.favorite : Icons.favorite_border),
336:             onPressed: () {
337:               if (isFavorite) {
338:                 ref
339:                     .read(favoritesProvider.notifier)
340:                     .removeFavorite(widget.card.productId.toString());
341:               } else {
342:                 ref
343:                     .read(favoritesProvider.notifier)
344:                     .addFavorite(widget.card.productId.toString());
345:               }
346:             },
347:           ),
348:           IconButton(
349:             icon: Icon(_showHighResImage ? Icons.hd : Icons.sd),
350:             onPressed: () =>
351:                 setState(() => _showHighResImage = !_showHighResImage),
352:           ),
353:         ],
354:       ),
355:       body: RefreshIndicator(
356:         onRefresh: () async {
357:           ref.invalidate(cardPriceProvider(widget.card.productId.toString()));
358:           ref.invalidate(
359:               priceHistoryProvider(widget.card.productId.toString()));
360:         },
361:         child: SingleChildScrollView(
362:           child: Column(
363:             crossAxisAlignment: CrossAxisAlignment.start,
364:             children: [
365:               _buildCardImage(),
366:               _buildCardInfo(),
367:               priceAsync.when(
368:                 data: (price) => _buildPriceSection(price),
369:                 loading: () => const Center(child: CircularProgressIndicator()),
370:                 error: (error, _) => Center(
371:                   child: Text('Error loading price data: $error'),
372:                 ),
373:               ),
374:               priceHistoryAsync.when(
375:                 data: (priceHistory) => _buildPriceHistory(priceHistory),
376:                 loading: () => const Center(child: CircularProgressIndicator()),
377:                 error: (error, _) => Center(
378:                   child: Text('Error loading price history: $error'),
379:                 ),
380:               ),
381:             ],
382:           ),
383:         ),
384:       ),
385:     );
386:   }
387: }
</file>

<file path="lib/features/cards/presentation/screens/cards_screen.dart">
  1: // lib/features/cards/presentation/screens/cards_screen.dart
  2: 
  3: import 'package:flutter/material.dart';
  4: import 'package:flutter_riverpod/flutter_riverpod.dart';
  5: import '../../../../core/utils/responsive_utils.dart';
  6: import '../../providers/card_providers.dart';
  7: import '../../models/card_filter_options.dart';
  8: import '../widgets/card_grid_item.dart';
  9: import '../widgets/card_list_item.dart';
 10: import '../widgets/filter_bottom_sheet.dart';
 11: import '../widgets/search_bar_widget.dart';
 12: import '../../providers/card_state.dart';
 13: 
 14: class CardsScreen extends ConsumerStatefulWidget {
 15:   const CardsScreen({super.key});
 16: 
 17:   @override
 18:   ConsumerState<CardsScreen> createState() => _CardsScreenState();
 19: }
 20: 
 21: class _CardsScreenState extends ConsumerState<CardsScreen> {
 22:   final _scrollController = ScrollController();
 23:   bool _isLoadingMore = false;
 24: 
 25:   @override
 26:   void initState() {
 27:     super.initState();
 28:     _scrollController.addListener(_onScroll);
 29:   }
 30: 
 31:   @override
 32:   void dispose() {
 33:     _scrollController.removeListener(_onScroll);
 34:     _scrollController.dispose();
 35:     super.dispose();
 36:   }
 37: 
 38:   void _onScroll() {
 39:     if (!_scrollController.hasClients) return;
 40: 
 41:     final maxScroll = _scrollController.position.maxScrollExtent;
 42:     final currentScroll = _scrollController.position.pixels;
 43:     final threshold = maxScroll * 0.9; // Load more when 90% scrolled
 44: 
 45:     if (currentScroll >= threshold && !_isLoadingMore) {
 46:       _loadMoreCards();
 47:     }
 48:   }
 49: 
 50:   Future<void> _loadMoreCards() async {
 51:     final cardState = ref.read(cardNotifierProvider);
 52:     if (cardState.isLoading || cardState.hasReachedEnd) return;
 53: 
 54:     setState(() => _isLoadingMore = true);
 55: 
 56:     try {
 57:       await ref.read(cardNotifierProvider.notifier).loadNextPage();
 58:     } finally {
 59:       if (mounted) {
 60:         setState(() => _isLoadingMore = false);
 61:       }
 62:     }
 63:   }
 64: 
 65:   Future<void> _handleRefresh() async {
 66:     return ref.read(cardNotifierProvider.notifier).refreshCards();
 67:   }
 68: 
 69:   @override
 70:   Widget build(BuildContext context) {
 71:     final cardState = ref.watch(cardNotifierProvider);
 72:     final themeColor = Theme.of(context).colorScheme.primary;
 73: 
 74:     return Scaffold(      
 75:       body: RefreshIndicator(
 76:         onRefresh: _handleRefresh,
 77:         child: CustomScrollView(
 78:           controller: _scrollController,
 79:           slivers: [
 80:             SliverToBoxAdapter(
 81:               child: Padding(
 82:                 padding: ResponsiveUtils.getScreenPadding(context),
 83:                 child: const SearchBarWidget(),
 84:               ),
 85:             ),
 86:             if (cardState.status == CardLoadingStatus.initial)
 87:               const SliverFillRemaining(
 88:                 child: Center(child: CircularProgressIndicator()),
 89:               )
 90:             else if (cardState.status == CardLoadingStatus.error)
 91:               SliverFillRemaining(
 92:                 child: _buildErrorView(cardState),
 93:               )
 94:             else ...[
 95:               if (cardState.cards.isEmpty)
 96:                 const SliverFillRemaining(
 97:                   child: Center(child: Text('No cards found')),
 98:                 )
 99:               else
100:                 cardState.isGridView
101:                     ? _buildCardGrid(cardState)
102:                     : _buildCardList(cardState),
103:               if (_isLoadingMore)
104:                 const SliverToBoxAdapter(
105:                   child: Padding(
106:                     padding: EdgeInsets.all(16.0),
107:                     child: Center(
108:                       child: CircularProgressIndicator(),
109:                     ),
110:                   ),
111:                 ),
112:             ],
113:           ],
114:         ),
115:       ),
116:       floatingActionButton: _buildFloatingActionButtons(cardState, themeColor),
117:     );
118:   }
119: 
120:   Widget _buildCardGrid(CardState cardState) {
121:     final crossAxisCount = ResponsiveUtils.getCardGridCrossAxisCount(context);
122:     final spacing = ResponsiveUtils
123:         .spacing[ResponsiveUtils.isPhone(context) ? 'sm' : 'md']!;
124: 
125:     return SliverPadding(
126:       padding: ResponsiveUtils.getScreenPadding(context),
127:       sliver: SliverGrid(
128:         gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(
129:           crossAxisCount: crossAxisCount,
130:           childAspectRatio: 0.7,
131:           crossAxisSpacing: spacing,
132:           mainAxisSpacing: spacing,
133:         ),
134:         delegate: SliverChildBuilderDelegate(
135:           (context, index) {
136:             final card = cardState.cards[index];
137:             return CardGridItem(
138:               card: card,
139:               useHighRes: ResponsiveUtils.isDesktop(context),
140:             );
141:           },
142:           childCount: cardState.cards.length,
143:         ),
144:       ),
145:     );
146:   }
147: 
148:   Widget _buildCardList(CardState cardState) {
149:     return SliverList(
150:       delegate: SliverChildBuilderDelegate(
151:         (context, index) {
152:           final card = cardState.cards[index];
153:           return CardListItem(
154:             card: card,
155:             height: ResponsiveUtils.getListItemHeight(context),
156:           );
157:         },
158:         childCount: cardState.cards.length,
159:       ),
160:     );
161:   }
162: 
163:   Widget _buildErrorView(CardState cardState) {
164:     return Center(
165:       child: Padding(
166:         padding: const EdgeInsets.all(16),
167:         child: Column(
168:           mainAxisAlignment: MainAxisAlignment.center,
169:           children: [
170:             Text(
171:               cardState.errorMessage ?? 'An error occurred',
172:               textAlign: TextAlign.center,
173:               style: TextStyle(
174:                 fontSize: ResponsiveUtils.getResponsiveFontSize(context, 16),
175:               ),
176:             ),
177:             const SizedBox(height: 16),
178:             ElevatedButton.icon(
179:               onPressed: _handleRefresh,
180:               icon: const Icon(Icons.refresh),
181:               label: const Text('Retry'),
182:             ),
183:           ],
184:         ),
185:       ),
186:     );
187:   }
188: 
189:   Widget _buildFloatingActionButtons(CardState cardState, Color themeColor) {
190:     final buttonSpacing = ResponsiveUtils
191:         .spacing[ResponsiveUtils.isPhone(context) ? 'sm' : 'md']!;
192: 
193:     return Padding(
194:       padding: EdgeInsets.only(
195:         bottom: MediaQuery.of(context).padding.bottom + buttonSpacing,
196:       ),
197:       child: Row(
198:         mainAxisAlignment: MainAxisAlignment.end,
199:         children: [
200:           FloatingActionButton(
201:             heroTag: 'view_toggle',
202:             onPressed: () {
203:               ref.read(cardNotifierProvider.notifier).toggleViewMode();
204:             },
205:             backgroundColor: themeColor,
206:             child: Icon(
207:               cardState.isGridView ? Icons.list : Icons.grid_view,
208:               color: Colors.white,
209:             ),
210:           ),
211:           SizedBox(width: buttonSpacing),
212:           FloatingActionButton(
213:             heroTag: 'filter',
214:             onPressed: _showFilterBottomSheet,
215:             backgroundColor: themeColor,
216:             child: const Icon(
217:               Icons.filter_list,
218:               color: Colors.white,
219:             ),
220:           ),
221:         ],
222:       ),
223:     );
224:   }
225: 
226:   void _showFilterBottomSheet() {
227:     showModalBottomSheet(
228:       context: context,
229:       isScrollControlled: true,
230:       backgroundColor: Colors.transparent,
231:       constraints: BoxConstraints(
232:         maxWidth: ResponsiveUtils.getDialogWidth(context),
233:       ),
234:       builder: (context) => FilterBottomSheet(
235:         currentFilters: ref.read(cardNotifierProvider).filterOptions ??
236:             const CardFilterOptions(),
237:         onFilterChanged: (filters) {
238:           ref.read(cardNotifierProvider.notifier).updateFilters(filters);
239:         },
240:       ),
241:     );
242:   }  
243: }
</file>

<file path="lib/features/cards/presentation/widgets/card_grid_item.dart">
  1: import 'package:flutter/material.dart';
  2: import 'package:flutter_riverpod/flutter_riverpod.dart';
  3: import '../../../../core/utils/responsive_utils.dart';
  4: import '../../../../core/logging/talker_service.dart';
  5: import '../../models/fftcg_card.dart';
  6: import '../screens/card_detail_screen.dart';
  7: import 'package:cached_network_image/cached_network_image.dart';
  8: 
  9: class CardGridItem extends ConsumerWidget {
 10:   final FFTCGCard card;
 11:   final bool useHighRes;
 12:   final TalkerService _talker = TalkerService();
 13: 
 14:   CardGridItem({
 15:     super.key,
 16:     required this.card,
 17:     this.useHighRes = false,
 18:   });
 19: 
 20:   @override
 21:   Widget build(BuildContext context, WidgetRef ref) {
 22:     // Remove imageService since we're using direct URLs
 23:     final imageUrl =
 24:         useHighRes ? card.effectiveHighResUrl : card.effectiveLowResUrl;
 25: 
 26:     return Card(
 27:       clipBehavior: Clip.antiAlias,
 28:       child: InkWell(
 29:         onTap: () => Navigator.of(context).push(
 30:           MaterialPageRoute(
 31:             builder: (context) => CardDetailScreen(card: card),
 32:           ),
 33:         ),
 34:         child: Column(
 35:           crossAxisAlignment: CrossAxisAlignment.stretch,
 36:           children: [
 37:             Expanded(
 38:               child: Hero(
 39:                 tag: 'card_${card.cardNumber}',
 40:                 child: CachedNetworkImage(
 41:                   imageUrl: imageUrl, // Direct URL use
 42:                   fit: BoxFit.contain,
 43:                   placeholder: (context, url) => const Center(
 44:                     child: CircularProgressIndicator(strokeWidth: 2),
 45:                   ),
 46:                   errorWidget: (context, url, error) {
 47:                     _talker.severe(
 48:                       'Error loading image for card: ${card.cardNumber}',
 49:                       error,
 50:                     );
 51:                     return Center(
 52:                       child: Column(
 53:                         mainAxisAlignment: MainAxisAlignment.center,
 54:                         children: [
 55:                           Icon(
 56:                             Icons.broken_image_outlined,
 57:                             color: Theme.of(context).colorScheme.error,
 58:                             size: 32,
 59:                           ),
 60:                           const SizedBox(height: 4),
 61:                           Text(
 62:                             'Image Not Available',
 63:                             style: TextStyle(
 64:                               fontSize: 12,
 65:                               color: Theme.of(context).colorScheme.error,
 66:                             ),
 67:                             textAlign: TextAlign.center,
 68:                           ),
 69:                         ],
 70:                       ),
 71:                     );
 72:                   },
 73:                 ),
 74:               ),
 75:             ),
 76:             _buildCardInfo(context),
 77:           ],
 78:         ),
 79:       ),
 80:     );
 81:   }
 82: 
 83:   Widget _buildCardInfo(BuildContext context) {
 84:     final textTheme = Theme.of(context).textTheme;
 85:     final titleStyle = textTheme.titleSmall?.copyWith(
 86:       fontSize: ResponsiveUtils.getResponsiveFontSize(context, 14),
 87:     );
 88:     final subtitleStyle = textTheme.bodySmall?.copyWith(
 89:       fontSize: ResponsiveUtils.getResponsiveFontSize(context, 12),
 90:     );
 91: 
 92:     return Padding(
 93:       padding: ResponsiveUtils.getResponsivePadding(context),
 94:       child: Column(
 95:         crossAxisAlignment: CrossAxisAlignment.start,
 96:         children: [
 97:           Text(
 98:             card.name,
 99:             style: titleStyle,
100:             maxLines: 1,
101:             overflow: TextOverflow.ellipsis,
102:           ),
103:           const SizedBox(height: 4),
104:           Row(
105:             mainAxisAlignment: MainAxisAlignment.spaceBetween,
106:             children: [
107:               if (card.cardNumber != null)
108:                 Text(
109:                   card.cardNumber!,
110:                   style: subtitleStyle,
111:                 ),
112:               if (card.cost != null)
113:                 Text(
114:                   'Cost: ${card.cost}',
115:                   style: subtitleStyle,
116:                 ),
117:             ],
118:           ),
119:           if (card.elements.isNotEmpty) ...[
120:             const SizedBox(height: 4),
121:             Row(
122:               children: card.elements.map((element) {
123:                 return Padding(
124:                   padding: const EdgeInsets.only(right: 4),
125:                   child: Text(
126:                     element,
127:                     style: subtitleStyle?.copyWith(
128:                       color: Theme.of(context).colorScheme.primary,
129:                     ),
130:                   ),
131:                 );
132:               }).toList(),
133:             ),
134:           ],
135:         ],
136:       ),
137:     );
138:   }
139: }
</file>

<file path="lib/features/cards/presentation/widgets/card_list_item.dart">
  1: import 'package:flutter/material.dart';
  2: import 'package:flutter_riverpod/flutter_riverpod.dart';
  3: import '../../../../core/utils/responsive_utils.dart';
  4: import '../../../../core/logging/talker_service.dart';
  5: import '../../models/fftcg_card.dart';
  6: import '../screens/card_detail_screen.dart';
  7: import 'package:cached_network_image/cached_network_image.dart';
  8: 
  9: class CardListItem extends ConsumerWidget {
 10:   final FFTCGCard card;
 11:   final double height;
 12:   final TalkerService _talker = TalkerService();
 13: 
 14:   CardListItem({
 15:     super.key,
 16:     required this.card,
 17:     this.height = 72.0,
 18:   });
 19: 
 20:   @override
 21:   Widget build(BuildContext context, WidgetRef ref) {
 22:     final isDesktop = ResponsiveUtils.isDesktop(context);
 23:     final imageSize = isDesktop ? 80.0 : 60.0;
 24:     final elevation = ResponsiveUtils.isPhone(context) ? 2.0 : 4.0;
 25: 
 26:     return Card(
 27:       elevation: elevation,
 28:       margin: EdgeInsets.symmetric(
 29:         vertical: ResponsiveUtils.isPhone(context) ? 4.0 : 8.0,
 30:         horizontal: ResponsiveUtils.getResponsivePadding(context).horizontal,
 31:       ),
 32:       child: ListTile(
 33:         onTap: () {
 34:           Navigator.of(context).push(
 35:             MaterialPageRoute(
 36:               builder: (context) => CardDetailScreen(card: card),
 37:             ),
 38:           );
 39:         },
 40:         contentPadding: EdgeInsets.all(
 41:           ResponsiveUtils.isPhone(context) ? 8.0 : 12.0,
 42:         ),
 43:         leading: Hero(
 44:           tag: 'card_${card.cardNumber}',
 45:           child: SizedBox(
 46:             width: imageSize,
 47:             child: CachedNetworkImage(
 48:               imageUrl: card.effectiveLowResUrl,
 49:               fit: BoxFit.contain,
 50:               placeholder: (context, url) => const Center(
 51:                 child: CircularProgressIndicator(strokeWidth: 2),
 52:               ),
 53:               errorWidget: (context, url, error) {
 54:                 _talker.severe(
 55:                   'Error loading list image for card: ${card.cardNumber}',
 56:                   error,
 57:                 );
 58:                 return _buildErrorWidget(context);
 59:               },
 60:             ),
 61:           ),
 62:         ),
 63:         title: Text(
 64:           card.name,
 65:           style: TextStyle(
 66:             fontSize: ResponsiveUtils.getResponsiveFontSize(context, 16),
 67:           ),
 68:         ),
 69:         subtitle: _buildSubtitle(context),
 70:         trailing: _buildTrailing(context),
 71:       ),
 72:     );
 73:   }
 74: 
 75:   Widget _buildErrorWidget(BuildContext context) {
 76:     return Center(
 77:       child: Column(
 78:         mainAxisAlignment: MainAxisAlignment.center,
 79:         children: [
 80:           Icon(Icons.error, color: Theme.of(context).colorScheme.error),
 81:           Text(
 82:             'No Image',
 83:             style: TextStyle(
 84:               color: Theme.of(context).colorScheme.error,
 85:               fontSize: 10,
 86:             ),
 87:           ),
 88:         ],
 89:       ),
 90:     );
 91:   }
 92: 
 93:   Widget _buildSubtitle(BuildContext context) {
 94:     final subtitleStyle = TextStyle(
 95:       fontSize: ResponsiveUtils.getResponsiveFontSize(context, 12),
 96:     );
 97: 
 98:     return Column(
 99:       crossAxisAlignment: CrossAxisAlignment.start,
100:       children: [
101:         if (card.cardNumber != null)
102:           Text(card.cardNumber!, style: subtitleStyle),
103:         if (card.elements.isNotEmpty)
104:           Row(
105:             children: card.elements.map((element) {
106:               return Padding(
107:                 padding: const EdgeInsets.only(right: 4),
108:                 child: Text(
109:                   element,
110:                   style: subtitleStyle.copyWith(
111:                     color: Theme.of(context).colorScheme.primary,
112:                     fontWeight: FontWeight.bold,
113:                   ),
114:                 ),
115:               );
116:             }).toList(),
117:           ),
118:       ],
119:     );
120:   }
121: 
122:   Widget _buildTrailing(BuildContext context) {
123:     final isTabletOrLarger = !ResponsiveUtils.isPhone(context);
124:     final trailingStyle = TextStyle(
125:       fontSize: ResponsiveUtils.getResponsiveFontSize(context, 12),
126:     );
127: 
128:     return Column(
129:       mainAxisAlignment: MainAxisAlignment.center,
130:       crossAxisAlignment: CrossAxisAlignment.end,
131:       children: [
132:         if (card.cost != null)
133:           Text(
134:             'Cost: ${card.cost}',
135:             style: trailingStyle,
136:           ),
137:         if (card.power != null && isTabletOrLarger)
138:           Text(
139:             'Power: ${card.power}',
140:             style: trailingStyle,
141:           ),
142:       ],
143:     );
144:   }
145: }
</file>

<file path="lib/features/cards/presentation/widgets/filter_bottom_sheet.dart">
  1: // lib/features/cards/presentation/widgets/filter_bottom_sheet.dart
  2: 
  3: import 'package:flutter/material.dart';
  4: import 'package:flutter_riverpod/flutter_riverpod.dart';
  5: import '../../../../core/utils/responsive_utils.dart';
  6: import '../../models/card_filter_options.dart';
  7: import '../../providers/card_providers.dart';
  8: 
  9: class FilterBottomSheet extends ConsumerStatefulWidget {
 10:   final CardFilterOptions currentFilters;
 11:   final ValueChanged<CardFilterOptions> onFilterChanged;
 12: 
 13:   const FilterBottomSheet({
 14:     super.key,
 15:     required this.currentFilters,
 16:     required this.onFilterChanged,
 17:   });
 18: 
 19:   @override
 20:   ConsumerState<FilterBottomSheet> createState() => _FilterBottomSheetState();
 21: }
 22: 
 23: class _FilterBottomSheetState extends ConsumerState<FilterBottomSheet> {
 24:   late CardFilterOptions _filters;
 25: 
 26:   @override
 27:   void initState() {
 28:     super.initState();
 29:     _filters = widget.currentFilters;
 30:   }
 31: 
 32:   @override
 33:   Widget build(BuildContext context) {
 34:     final elements = ref.watch(uniqueElementsProvider);
 35:     final cardTypes = ref.watch(uniqueCardTypesProvider);
 36:     final isDesktop = ResponsiveUtils.isDesktop(context);
 37:     final isTablet = ResponsiveUtils.isTablet(context);
 38: 
 39:     return DraggableScrollableSheet(
 40:       initialChildSize: isDesktop ? 0.8 : 0.9,
 41:       minChildSize: isTablet ? 0.4 : 0.5,
 42:       maxChildSize: 0.95,
 43:       builder: (context, scrollController) {
 44:         return Container(
 45:           decoration: BoxDecoration(
 46:             color: Theme.of(context).scaffoldBackgroundColor,
 47:             borderRadius: const BorderRadius.vertical(top: Radius.circular(16)),
 48:           ),
 49:           child: Column(
 50:             children: [
 51:               _buildHeader(context),
 52:               const Divider(),
 53:               Expanded(
 54:                 child: _buildFilterContent(
 55:                   context,
 56:                   scrollController,
 57:                   elements,
 58:                   cardTypes,
 59:                 ),
 60:               ),
 61:             ],
 62:           ),
 63:         );
 64:       },
 65:     );
 66:   }
 67: 
 68:   Widget _buildHeader(BuildContext context) {
 69:     final textTheme = Theme.of(context).textTheme;
 70:     final headerStyle = textTheme.titleLarge?.copyWith(
 71:       fontSize: ResponsiveUtils.getResponsiveFontSize(context, 20),
 72:     );
 73:     final buttonStyle = textTheme.labelLarge?.copyWith(
 74:       fontSize: ResponsiveUtils.getResponsiveFontSize(context, 14),
 75:     );
 76: 
 77:     return Padding(
 78:       padding: ResponsiveUtils.getResponsivePadding(context),
 79:       child: Row(
 80:         mainAxisAlignment: MainAxisAlignment.spaceBetween,
 81:         children: [
 82:           TextButton(
 83:             onPressed: () {
 84:               setState(() {
 85:                 _filters = const CardFilterOptions();
 86:               });
 87:             },
 88:             child: Text('Reset', style: buttonStyle),
 89:           ),
 90:           Text('Filters', style: headerStyle),
 91:           TextButton(
 92:             onPressed: () {
 93:               widget.onFilterChanged(_filters);
 94:               Navigator.pop(context);
 95:             },
 96:             child: Text('Apply', style: buttonStyle),
 97:           ),
 98:         ],
 99:       ),
100:     );
101:   }
102: 
103:   Widget _buildFilterContent(
104:     BuildContext context,
105:     ScrollController scrollController,
106:     AsyncValue<List<String>> elements,
107:     AsyncValue<List<String>> cardTypes,
108:   ) {
109:     final isWideScreen =
110:         ResponsiveUtils.isTablet(context) || ResponsiveUtils.isDesktop(context);
111: 
112:     if (isWideScreen) {
113:       return Row(
114:         crossAxisAlignment: CrossAxisAlignment.start,
115:         children: [
116:           Expanded(
117:             child: _buildFilterList(
118:               scrollController,
119:               elements,
120:               cardTypes,
121:               startIndex: 0,
122:               endIndex: 2,
123:             ),
124:           ),
125:           const VerticalDivider(width: 1),
126:           Expanded(
127:             child: _buildFilterList(
128:               scrollController,
129:               elements,
130:               cardTypes,
131:               startIndex: 2,
132:               endIndex: 4,
133:             ),
134:           ),
135:         ],
136:       );
137:     }
138: 
139:     return _buildFilterList(
140:       scrollController,
141:       elements,
142:       cardTypes,
143:       startIndex: 0,
144:       endIndex: 4,
145:     );
146:   }
147: 
148:   Widget _buildFilterList(
149:     ScrollController scrollController,
150:     AsyncValue<List<String>> elements,
151:     AsyncValue<List<String>> cardTypes, {
152:     required int startIndex,
153:     required int endIndex,
154:   }) {
155:     final filterSections = [
156:       _buildElementsSection(elements),
157:       _buildCardTypesSection(cardTypes),
158:       _buildCostSection(),
159:       _buildPowerSection(),
160:     ].sublist(startIndex, endIndex);
161: 
162:     return ListView.separated(
163:       controller: scrollController,
164:       padding: ResponsiveUtils.getResponsivePadding(context),
165:       itemCount: filterSections.length,
166:       separatorBuilder: (context, index) => const Divider(),
167:       itemBuilder: (context, index) => filterSections[index],
168:     );
169:   }
170: 
171:   Widget _buildElementsSection(AsyncValue<List<String>> elements) {
172:     return Column(
173:       crossAxisAlignment: CrossAxisAlignment.start,
174:       children: [
175:         Text(
176:           'Elements',
177:           style: Theme.of(context).textTheme.titleMedium?.copyWith(
178:                 fontSize: ResponsiveUtils.getResponsiveFontSize(context, 16),
179:               ),
180:         ),
181:         const SizedBox(height: 8),
182:         elements.when(
183:           data: (elementList) => Wrap(
184:             spacing: 8,
185:             runSpacing: 8,
186:             children: elementList.map((element) {
187:               return FilterChip(
188:                 label: Text(
189:                   element,
190:                   style: TextStyle(
191:                     fontSize:
192:                         ResponsiveUtils.getResponsiveFontSize(context, 12),
193:                   ),
194:                 ),
195:                 selected: _filters.elements?.contains(element) ?? false,
196:                 onSelected: (selected) {
197:                   setState(() {
198:                     final currentElements =
199:                         List<String>.from(_filters.elements ?? []);
200:                     if (selected) {
201:                       currentElements.add(element);
202:                     } else {
203:                       currentElements.remove(element);
204:                     }
205:                     _filters = _filters.copyWith(
206:                       elements:
207:                           currentElements.isEmpty ? null : currentElements,
208:                     );
209:                   });
210:                 },
211:               );
212:             }).toList(),
213:           ),
214:           loading: () => const CircularProgressIndicator(),
215:           error: (_, __) => const Text('Failed to load elements'),
216:         ),
217:       ],
218:     );
219:   }
220: 
221:   Widget _buildCardTypesSection(AsyncValue<List<String>> cardTypes) {
222:     return Column(
223:       crossAxisAlignment: CrossAxisAlignment.start,
224:       children: [
225:         Text(
226:           'Card Type',
227:           style: Theme.of(context).textTheme.titleMedium?.copyWith(
228:                 fontSize: ResponsiveUtils.getResponsiveFontSize(context, 16),
229:               ),
230:         ),
231:         const SizedBox(height: 8),
232:         cardTypes.when(
233:           data: (types) => Wrap(
234:             spacing: 8,
235:             runSpacing: 8,
236:             children: types.map((type) {
237:               return ChoiceChip(
238:                 label: Text(
239:                   type,
240:                   style: TextStyle(
241:                     fontSize:
242:                         ResponsiveUtils.getResponsiveFontSize(context, 12),
243:                   ),
244:                 ),
245:                 selected: _filters.cardType == type,
246:                 onSelected: (selected) {
247:                   setState(() {
248:                     _filters = _filters.copyWith(
249:                       cardType: selected ? type : null,
250:                     );
251:                   });
252:                 },
253:               );
254:             }).toList(),
255:           ),
256:           loading: () => const CircularProgressIndicator(),
257:           error: (_, __) => const Text('Failed to load card types'),
258:         ),
259:       ],
260:     );
261:   }
262: 
263:   Widget _buildCostSection() {
264:     return Column(
265:       crossAxisAlignment: CrossAxisAlignment.start,
266:       children: [
267:         Text(
268:           'Cost',
269:           style: Theme.of(context).textTheme.titleMedium?.copyWith(
270:                 fontSize: ResponsiveUtils.getResponsiveFontSize(context, 16),
271:               ),
272:         ),
273:         const SizedBox(height: 8),
274:         Wrap(
275:           spacing: 8,
276:           runSpacing: 8,
277:           children: List.generate(13, (index) {
278:             final cost = index.toString();
279:             return FilterChip(
280:               label: Text(
281:                 cost,
282:                 style: TextStyle(
283:                   fontSize: ResponsiveUtils.getResponsiveFontSize(context, 12),
284:                 ),
285:               ),
286:               selected: _filters.costs?.contains(cost) ?? false,
287:               onSelected: (selected) {
288:                 setState(() {
289:                   final currentCosts = List<String>.from(_filters.costs ?? []);
290:                   if (selected) {
291:                     currentCosts.add(cost);
292:                   } else {
293:                     currentCosts.remove(cost);
294:                   }
295:                   _filters = _filters.copyWith(
296:                     costs: currentCosts.isEmpty ? null : currentCosts,
297:                   );
298:                 });
299:               },
300:             );
301:           }),
302:         ),
303:       ],
304:     );
305:   }
306: 
307:   Widget _buildPowerSection() {
308:     final ranges = ['1000-5000', '5001-10000', '10001+'];
309: 
310:     return Column(
311:       crossAxisAlignment: CrossAxisAlignment.start,
312:       children: [
313:         Text(
314:           'Power Range',
315:           style: Theme.of(context).textTheme.titleMedium?.copyWith(
316:                 fontSize: ResponsiveUtils.getResponsiveFontSize(context, 16),
317:               ),
318:         ),
319:         const SizedBox(height: 8),
320:         Wrap(
321:           spacing: 8,
322:           runSpacing: 8,
323:           children: ranges.map((range) {
324:             return ChoiceChip(
325:               label: Text(
326:                 range,
327:                 style: TextStyle(
328:                   fontSize: ResponsiveUtils.getResponsiveFontSize(context, 12),
329:                 ),
330:               ),
331:               selected: _filters.powerRange == range,
332:               onSelected: (selected) {
333:                 setState(() {
334:                   _filters = _filters.copyWith(
335:                     powerRange: selected ? range : null,
336:                   );
337:                 });
338:               },
339:             );
340:           }).toList(),
341:         ),
342:       ],
343:     );
344:   }
345: }
</file>

<file path="lib/features/cards/presentation/widgets/search_bar_widget.dart">
 1: // lib/features/cards/presentation/widgets/search_bar_widget.dart
 2: 
 3: import 'package:flutter/material.dart';
 4: import 'package:flutter_riverpod/flutter_riverpod.dart';
 5: import '../../providers/card_providers.dart';
 6: 
 7: class SearchBarWidget extends ConsumerStatefulWidget {
 8:   const SearchBarWidget({super.key});
 9: 
10:   @override
11:   ConsumerState<SearchBarWidget> createState() => _SearchBarWidgetState();
12: }
13: 
14: class _SearchBarWidgetState extends ConsumerState<SearchBarWidget> {
15:   final _searchController = TextEditingController();
16:   final _focusNode = FocusNode();
17:   bool _isSearching = false;
18: 
19:   @override
20:   void initState() {
21:     super.initState();
22:     _searchController.addListener(_onSearchChanged);
23:   }
24: 
25:   @override
26:   void dispose() {
27:     _searchController.dispose();
28:     _focusNode.dispose();
29:     super.dispose();
30:   }
31: 
32:   void _onSearchChanged() {
33:     ref
34:         .read(cardNotifierProvider.notifier)
35:         .updateSearchQuery(_searchController.text);
36:   }
37: 
38:   void _clearSearch() {
39:     _searchController.clear();
40:     _focusNode.unfocus();
41:   }
42: 
43:   @override
44:   Widget build(BuildContext context) {
45:     final theme = Theme.of(context);
46: 
47:     return Padding(
48:       padding: const EdgeInsets.symmetric(horizontal: 8.0, vertical: 4.0),
49:       child: SearchBar(
50:         controller: _searchController,
51:         focusNode: _focusNode,
52:         hintText: 'Search cards...',
53:         padding: const WidgetStatePropertyAll<EdgeInsets>(
54:           EdgeInsets.symmetric(horizontal: 16.0),
55:         ),
56:         leading: Icon(
57:           _isSearching ? Icons.search_off : Icons.search,
58:           color: theme.colorScheme.onSurface,
59:         ),
60:         trailing: [
61:           if (_searchController.text.isNotEmpty)
62:             IconButton(
63:               icon: const Icon(Icons.clear),
64:               onPressed: _clearSearch,
65:             ),
66:         ],
67:         onTap: () {
68:           setState(() => _isSearching = true);
69:         },
70:         onChanged: (_) {
71:           setState(() {}); // Update to show/hide clear button
72:         },
73:         onSubmitted: (_) {
74:           setState(() => _isSearching = false);
75:           _focusNode.unfocus();
76:         },
77:       ),
78:     );
79:   }
80: }
</file>

<file path="lib/features/cards/presentation/widgets/sort_menu_button.dart">
  1: // lib/features/cards/presentation/widgets/sort_menu_button.dart
  2: 
  3: import 'package:flutter/material.dart';
  4: import 'package:flutter_riverpod/flutter_riverpod.dart';
  5: import '../../../../core/utils/responsive_utils.dart';
  6: import '../../models/card_filter_options.dart';
  7: import '../../providers/card_providers.dart';
  8: 
  9: class SortMenuButton extends ConsumerWidget {
 10:   const SortMenuButton({super.key});
 11: 
 12:   @override
 13:   Widget build(BuildContext context, WidgetRef ref) {
 14:     final cardState = ref.watch(cardNotifierProvider);
 15:     final currentSort =
 16:         cardState.filterOptions?.sortOption ?? CardSortOption.setNumber;
 17:     final isAscending = cardState.filterOptions?.ascending ?? true;
 18:     final isDesktop = ResponsiveUtils.isDesktop(context);
 19: 
 20:     return PopupMenuButton<(CardSortOption, bool)>(
 21:       initialValue: (currentSort, isAscending),
 22:       tooltip: 'Sort cards',
 23:       icon: const Icon(Icons.sort),
 24:       itemBuilder: (context) {
 25:         List<PopupMenuEntry<(CardSortOption, bool)>> items = [];
 26: 
 27:         // Set Number
 28:         items.add(
 29:           PopupMenuItem(
 30:             value: (CardSortOption.setNumber, true),
 31:             child: Row(
 32:               children: [
 33:                 Text(
 34:                   'Set Number',
 35:                   style: TextStyle(
 36:                     fontSize:
 37:                         ResponsiveUtils.getResponsiveFontSize(context, 14),
 38:                   ),
 39:                 ),
 40:                 const SizedBox(width: 8),
 41:                 if (currentSort == CardSortOption.setNumber && isAscending)
 42:                   const Icon(Icons.check, size: 20),
 43:               ],
 44:             ),
 45:           ),
 46:         );
 47: 
 48:         items.add(const PopupMenuDivider());
 49: 
 50:         // Name
 51:         items.add(
 52:           PopupMenuItem(
 53:             value: (CardSortOption.nameAsc, true),
 54:             child: Row(
 55:               mainAxisAlignment: MainAxisAlignment.spaceBetween,
 56:               children: [
 57:                 Text(
 58:                   'Name (A-Z)',
 59:                   style: TextStyle(
 60:                     fontSize:
 61:                         ResponsiveUtils.getResponsiveFontSize(context, 14),
 62:                   ),
 63:                 ),
 64:                 if (currentSort == CardSortOption.nameAsc && isAscending)
 65:                   const Icon(Icons.check, size: 20),
 66:               ],
 67:             ),
 68:           ),
 69:         );
 70:         items.add(
 71:           PopupMenuItem(
 72:             value: (CardSortOption.nameDesc, false),
 73:             child: Row(
 74:               mainAxisAlignment: MainAxisAlignment.spaceBetween,
 75:               children: [
 76:                 Text(
 77:                   'Name (Z-A)',
 78:                   style: TextStyle(
 79:                     fontSize:
 80:                         ResponsiveUtils.getResponsiveFontSize(context, 14),
 81:                   ),
 82:                 ),
 83:                 if (currentSort == CardSortOption.nameDesc && !isAscending)
 84:                   const Icon(Icons.check, size: 20),
 85:               ],
 86:             ),
 87:           ),
 88:         );
 89: 
 90:         items.add(const PopupMenuDivider());
 91: 
 92:         // Cost
 93:         items.add(
 94:           PopupMenuItem(
 95:             value: (CardSortOption.costAsc, true),
 96:             child: Row(
 97:               mainAxisAlignment: MainAxisAlignment.spaceBetween,
 98:               children: [
 99:                 Text(
100:                   'Cost (Low to High)',
101:                   style: TextStyle(
102:                     fontSize:
103:                         ResponsiveUtils.getResponsiveFontSize(context, 14),
104:                   ),
105:                 ),
106:                 if (currentSort == CardSortOption.costAsc && isAscending)
107:                   const Icon(Icons.check, size: 20),
108:               ],
109:             ),
110:           ),
111:         );
112:         items.add(
113:           PopupMenuItem(
114:             value: (CardSortOption.costDesc, false),
115:             child: Row(
116:               mainAxisAlignment: MainAxisAlignment.spaceBetween,
117:               children: [
118:                 Text(
119:                   'Cost (High to Low)',
120:                   style: TextStyle(
121:                     fontSize:
122:                         ResponsiveUtils.getResponsiveFontSize(context, 14),
123:                   ),
124:                 ),
125:                 if (currentSort == CardSortOption.costDesc && !isAscending)
126:                   const Icon(Icons.check, size: 20),
127:               ],
128:             ),
129:           ),
130:         );
131: 
132:         // Power (Desktop only)
133:         if (isDesktop) {
134:           items.add(const PopupMenuDivider());
135:           items.add(
136:             PopupMenuItem(
137:               value: (CardSortOption.powerAsc, true),
138:               child: Row(
139:                 mainAxisAlignment: MainAxisAlignment.spaceBetween,
140:                 children: [
141:                   Text(
142:                     'Power (Low to High)',
143:                     style: TextStyle(
144:                       fontSize:
145:                           ResponsiveUtils.getResponsiveFontSize(context, 14),
146:                     ),
147:                   ),
148:                   if (currentSort == CardSortOption.powerAsc && isAscending)
149:                     const Icon(Icons.check, size: 20),
150:                 ],
151:               ),
152:             ),
153:           );
154:           items.add(
155:             PopupMenuItem(
156:               value: (CardSortOption.powerDesc, false),
157:               child: Row(
158:                 mainAxisAlignment: MainAxisAlignment.spaceBetween,
159:                 children: [
160:                   Text(
161:                     'Power (High to Low)',
162:                     style: TextStyle(
163:                       fontSize:
164:                           ResponsiveUtils.getResponsiveFontSize(context, 14),
165:                     ),
166:                   ),
167:                   if (currentSort == CardSortOption.powerDesc && !isAscending)
168:                     const Icon(Icons.check, size: 20),
169:                 ],
170:               ),
171:             ),
172:           );
173:         }
174: 
175:         // Release Date
176:         items.add(const PopupMenuDivider());
177:         items.add(
178:           PopupMenuItem(
179:             value: (CardSortOption.releaseDate, true),
180:             child: Row(
181:               mainAxisAlignment: MainAxisAlignment.spaceBetween,
182:               children: [
183:                 Text(
184:                   'Release Date (Newest)',
185:                   style: TextStyle(
186:                     fontSize:
187:                         ResponsiveUtils.getResponsiveFontSize(context, 14),
188:                   ),
189:                 ),
190:                 if (currentSort == CardSortOption.releaseDate && isAscending)
191:                   const Icon(Icons.check, size: 20),
192:               ],
193:             ),
194:           ),
195:         );
196: 
197:         return items;
198:       },
199:       onSelected: (value) {
200:         final currentFilters =
201:             cardState.filterOptions ?? const CardFilterOptions();
202:         ref.read(cardNotifierProvider.notifier).updateFilters(
203:               currentFilters.copyWith(
204:                 sortOption: value.$1,
205:                 ascending: value.$2,
206:               ),
207:             );
208:       },
209:     );
210:   }
211: }
</file>

<file path="lib/features/cards/providers/card_notifier.dart">
  1: // lib/features/cards/providers/card_notifier.dart
  2: 
  3: import 'dart:async';
  4: import 'package:flutter_riverpod/flutter_riverpod.dart';
  5: import '../../../core/logging/talker_service.dart';
  6: import '../repositories/card_repository.dart';
  7: import '../services/card_cache_service.dart';
  8: import '../models/card_filter_options.dart';
  9: import '../models/fftcg_card.dart';
 10: import 'card_state.dart';
 11: 
 12: class CardNotifier extends StateNotifier<CardState> {
 13:   final CardRepository _repository;
 14:   final CardCacheService _cacheService;
 15:   final TalkerService _talker;
 16:   StreamSubscription? _cardsSubscription;
 17:   static const int _pageSize = 20;
 18: 
 19:   CardNotifier({
 20:     required CardRepository repository,
 21:     required CardCacheService cacheService,
 22:     TalkerService? talker,
 23:   })  : _repository = repository,
 24:         _cacheService = cacheService,
 25:         _talker = talker ?? TalkerService(),
 26:         super(const CardState()) {
 27:     _initializeCards();
 28:   }
 29: 
 30:   Future<void> _initializeCards() async {
 31:     try {
 32:       state = state.copyWith(status: CardLoadingStatus.loading);
 33: 
 34:       // Initialize Hive
 35:       await _repository.initialize();
 36: 
 37:       final savedFilters = _cacheService.getFilterOptions();
 38:       if (savedFilters != null) {
 39:         state = state.copyWith(filterOptions: savedFilters);
 40:         _talker.info('Restored saved filters: ${savedFilters.toJson()}');
 41:       }
 42: 
 43:       // Load initial page
 44:       await loadNextPage(refresh: true);
 45:     } catch (e, stackTrace) {
 46:       _talker.severe('Error initializing cards', e, stackTrace);
 47:       state = state.copyWith(
 48:         status: CardLoadingStatus.error,
 49:         errorMessage: 'Failed to initialize cards storage',
 50:       );
 51:     }
 52:   }
 53: 
 54: Future<void> loadNextPage({bool refresh = false}) async {
 55:     if (state.isLoading || (state.hasReachedEnd && !refresh)) return;
 56: 
 57:     try {
 58:       state = state.copyWith(isLoading: true);
 59: 
 60:       final page = refresh ? 0 : state.currentPage + 1;
 61:       final List<FFTCGCard> cards = await _repository.getCardsPage(page);
 62: 
 63:       // Only set hasReachedEnd if we get zero cards
 64:       if (cards.isEmpty) {
 65:         state = state.copyWith(
 66:           status: CardLoadingStatus.loaded,
 67:           cards: refresh ? [] : state.cards,
 68:           hasReachedEnd: true,
 69:           isLoading: false,
 70:           currentPage: page,
 71:         );
 72:         return;
 73:       }
 74: 
 75:       final updatedCards = refresh ? cards : [...state.cards, ...cards];
 76: 
 77:       // Pre-cache images for better performance
 78:       _talker.info('Pre-caching images for ${cards.length} cards');
 79:       await _cacheService.preCacheCards(cards);
 80: 
 81:       state = state.copyWith(
 82:         status: CardLoadingStatus.loaded,
 83:         cards: updatedCards,
 84:         isLoading: false,
 85:         currentPage: page,
 86:         errorMessage: null,
 87:         // Only set hasReachedEnd if we get fewer cards than requested
 88:         hasReachedEnd: cards.length < _pageSize,
 89:       );
 90: 
 91:       _talker.info('Loaded page $page with ${cards.length} cards');
 92:     } catch (e, stackTrace) {
 93:       _talker.severe('Error loading cards page', e, stackTrace);
 94:       state = state.copyWith(
 95:         status: CardLoadingStatus.error,
 96:         errorMessage: 'Failed to load cards: ${e.toString()}',
 97:         isLoading: false,
 98:       );
 99:     }
100:   }
101: 
102:   Future<void> refreshCards() async {
103:     await loadNextPage(refresh: true);
104:   }
105: 
106:   void toggleViewMode() {
107:     state = state.copyWith(isGridView: !state.isGridView);
108:     _talker.info('View mode changed to: ${state.isGridView ? 'grid' : 'list'}');
109:   }
110: 
111:   void updateFilters(CardFilterOptions options) {
112:     _talker.info('Updating filters: ${options.toJson()}');
113:     state = state.copyWith(
114:       status: CardLoadingStatus.loading,
115:       filterOptions: options,
116:     );
117:     _cacheService.saveFilterOptions(options);
118:     refreshCards();
119:   }
120: 
121:   void updateSearchQuery(String? query) {
122:     if (query == state.searchQuery) return;
123: 
124:     _talker.info('Updating search query: $query');
125:     state = state.copyWith(
126:       searchQuery: query,
127:       status: CardLoadingStatus.loading,
128:     );
129:     refreshCards();
130:   }
131: 
132:   @override
133:   void dispose() {
134:     _talker.info('Disposing CardNotifier');
135:     _cardsSubscription?.cancel();
136:     super.dispose();
137:   }
138: }
</file>

<file path="lib/features/cards/providers/card_providers.dart">
  1: import 'package:flutter_riverpod/flutter_riverpod.dart';
  2: import 'package:shared_preferences/shared_preferences.dart';
  3: import '../../../core/logging/talker_service.dart';
  4: import '../repositories/card_repository.dart';
  5: import '../services/card_cache_service.dart';
  6: import 'card_notifier.dart';
  7: import 'card_state.dart';
  8: import '../models/fftcg_card.dart';
  9: import '../models/card_filter_options.dart';
 10: 
 11: // Core providers
 12: final sharedPreferencesProvider = Provider<SharedPreferences>((ref) {
 13:   throw UnimplementedError('Must be overridden in main.dart');
 14: });
 15: 
 16: // Service providers
 17: final cardCacheServiceProvider = Provider<CardCacheService>((ref) {
 18:   final prefs = ref.watch(sharedPreferencesProvider);
 19:   return CardCacheService(prefs: prefs);
 20: });
 21: 
 22: final cardRepositoryProvider = Provider<CardRepository>((ref) {
 23:   try {
 24:     return CardRepository();
 25:   } catch (e, stack) {
 26:     ref.watch(talkerServiceProvider).severe(
 27:           'Failed to initialize CardRepository',
 28:           e,
 29:           stack,
 30:         );
 31:     throw StateError('Failed to initialize CardRepository: $e');
 32:   }
 33: });
 34: 
 35: // Main card state provider
 36: final cardNotifierProvider =
 37:     StateNotifierProvider<CardNotifier, CardState>((ref) {
 38:   final repository = ref.watch(cardRepositoryProvider);
 39:   final cacheService = ref.watch(cardCacheServiceProvider);
 40:   final talker = TalkerService();
 41: 
 42:   ref.onDispose(() {
 43:     talker.info('Disposing CardNotifier provider');
 44:   });
 45: 
 46:   return CardNotifier(
 47:     repository: repository,
 48:     cacheService: cacheService,
 49:     talker: talker,
 50:   );
 51: });
 52: 
 53: // Convenience providers for card data
 54: final cardsProvider = Provider<List<FFTCGCard>>((ref) {
 55:   return ref.watch(cardNotifierProvider).cards;
 56: });
 57: 
 58: final filteredCardsProvider = Provider<List<FFTCGCard>>((ref) {
 59:   final state = ref.watch(cardNotifierProvider);
 60:   final filters = state.filterOptions;
 61:   if (filters == null) return state.cards;
 62: 
 63:   return state.cards.where((card) {
 64:     if (filters.elements?.isNotEmpty ?? false) {
 65:       if (!card.elements
 66:           .any((element) => filters.elements!.contains(element))) {
 67:         return false;
 68:       }
 69:     }
 70:     if (filters.cardType != null && card.cardType != filters.cardType) {
 71:       return false;
 72:     }
 73:     if (filters.costs?.isNotEmpty ?? false) {
 74:       if (!filters.costs!.contains(card.cost)) {
 75:         return false;
 76:       }
 77:     }
 78:     return true;
 79:   }).toList();
 80: });
 81: 
 82: // Status providers
 83: final cardLoadingStatusProvider = Provider<CardLoadingStatus>((ref) {
 84:   return ref.watch(cardNotifierProvider).status;
 85: });
 86: 
 87: final isGridViewProvider = Provider<bool>((ref) {
 88:   return ref.watch(cardNotifierProvider).isGridView;
 89: });
 90: 
 91: // Filter-related providers
 92: final uniqueElementsProvider = FutureProvider<List<String>>((ref) async {
 93:   return ref.read(cardRepositoryProvider).getUniqueElements();
 94: });
 95: 
 96: final uniqueCardTypesProvider = FutureProvider<List<String>>((ref) async {
 97:   return ref.read(cardRepositoryProvider).getUniqueCardTypes();
 98: });
 99: 
100: final uniqueRaritiesProvider = FutureProvider<List<String>>((ref) async {
101:   final cards = await ref.read(cardRepositoryProvider).getAllCards();
102:   return cards
103:       .map((card) => card.rarity)
104:       .where((rarity) => rarity != null)
105:       .toSet()
106:       .cast<String>()
107:       .toList();
108: });
109: 
110: final uniqueOpusProvider = FutureProvider<List<String>>((ref) async {
111:   final cards = await ref.read(cardRepositoryProvider).getAllCards();
112:   return cards
113:       .map((card) => card.cardNumber?.split('-').first)
114:       .where((opus) => opus != null)
115:       .toSet()
116:       .cast<String>()
117:       .toList();
118: });
119: 
120: // Search providers
121: final searchResultsProvider = FutureProvider.family<List<FFTCGCard>, String>(
122:   (ref, query) async {
123:     if (query.isEmpty) return [];
124:     return ref.read(cardRepositoryProvider).searchCards(query);
125:   },
126: );
127: 
128: // Card detail providers
129: final cardByNumberProvider = FutureProvider.family<FFTCGCard?, String>(
130:   (ref, cardNumber) async {
131:     return ref.read(cardRepositoryProvider).getCardByNumber(cardNumber);
132:   },
133: );
134: 
135: // Recent cards provider
136: final recentCardsProvider = Provider<List<String>>((ref) {
137:   return ref.read(cardCacheServiceProvider).getRecentCards();
138: });
139: 
140: // Filter state providers
141: final selectedFiltersProvider = Provider<CardFilterOptions?>((ref) {
142:   return ref.watch(cardNotifierProvider).filterOptions;
143: });
144: 
145: final selectedElementsProvider = Provider<List<String>?>((ref) {
146:   return ref.watch(selectedFiltersProvider)?.elements;
147: });
148: 
149: final selectedCardTypeProvider = Provider<String?>((ref) {
150:   return ref.watch(selectedFiltersProvider)?.cardType;
151: });
152: 
153: final selectedCostsProvider = Provider<List<String>?>((ref) {
154:   return ref.watch(selectedFiltersProvider)?.costs;
155: });
156: 
157: final selectedRaritiesProvider = Provider<List<String>?>((ref) {
158:   return ref.watch(selectedFiltersProvider)?.rarities;
159: });
160: 
161: final selectedOpusProvider = Provider<List<String>?>((ref) {
162:   return ref.watch(selectedFiltersProvider)?.opus;
163: });
164: 
165: // Error handling provider
166: final cardErrorMessageProvider = Provider<String?>((ref) {
167:   return ref.watch(cardNotifierProvider).errorMessage;
168: });
169: 
170: // Sort-related providers
171: final currentSortOptionProvider = Provider<CardSortOption>((ref) {
172:   return ref.watch(selectedFiltersProvider)?.sortOption ??
173:       CardSortOption.setNumber;
174: });
175: 
176: final sortAscendingProvider = Provider<bool>((ref) {
177:   return ref.watch(selectedFiltersProvider)?.ascending ?? true;
178: });
179: 
180: final imageCacheManagerProvider = Provider<CardCacheManager>((ref) {
181:   return CardCacheManager();
182: });
183: 
184: final cardPreCacheProvider =
185:     Provider<Future<void> Function(List<FFTCGCard>)>((ref) {
186:   final cacheManager = ref.watch(cardCacheServiceProvider).imageCacheManager;
187: 
188:   return (List<FFTCGCard> cards) async {
189:     final futures = cards.map((card) => Future.wait([
190:           cacheManager.downloadFile(card.lowResUrl),
191:           // Only pre-cache high res for the first few cards
192:           if (cards.indexOf(card) < 5)
193:             cacheManager.downloadFile(card.highResUrl),
194:         ]));
195: 
196:     await Future.wait(futures);
197:   };
198: });
</file>

<file path="lib/features/cards/providers/card_state.dart">
 1: import '../models/card_filter_options.dart';
 2: import '../models/fftcg_card.dart';
 3: 
 4: enum CardLoadingStatus {
 5:   initial,
 6:   loading,
 7:   loaded,
 8:   error,
 9: }
10: 
11: class CardState {
12:   final CardLoadingStatus status;
13:   final List<FFTCGCard> cards;
14:   final String? errorMessage;
15:   final bool isGridView;
16:   final String? searchQuery;
17:   final CardFilterOptions? filterOptions;
18:   final bool isLoading;
19:   final bool hasReachedEnd;
20:   final int currentPage;
21: 
22:   const CardState({
23:     this.status = CardLoadingStatus.initial,
24:     this.cards = const [],
25:     this.errorMessage,
26:     this.isGridView = true,
27:     this.searchQuery,
28:     this.filterOptions,
29:     this.isLoading = false,
30:     this.hasReachedEnd = false,
31:     this.currentPage = 0,
32:   });
33: 
34:   CardState copyWith({
35:     CardLoadingStatus? status,
36:     List<FFTCGCard>? cards,
37:     String? errorMessage,
38:     bool? isGridView,
39:     String? searchQuery,
40:     CardFilterOptions? filterOptions,
41:     bool? isLoading,
42:     bool? hasReachedEnd,
43:     int? currentPage,
44:   }) {
45:     return CardState(
46:       status: status ?? this.status,
47:       cards: cards ?? this.cards,
48:       errorMessage: errorMessage ?? this.errorMessage,
49:       isGridView: isGridView ?? this.isGridView,
50:       searchQuery: searchQuery ?? this.searchQuery,
51:       filterOptions: filterOptions ?? this.filterOptions,
52:       isLoading: isLoading ?? this.isLoading,
53:       hasReachedEnd: hasReachedEnd ?? this.hasReachedEnd,
54:       currentPage: currentPage ?? this.currentPage,
55:     );
56:   }
57: 
58:   @override
59:   String toString() {
60:     return '''CardState(
61:       status: $status,
62:       cards: ${cards.length} cards,
63:       errorMessage: $errorMessage,
64:       isGridView: $isGridView,
65:       searchQuery: $searchQuery,
66:       filterOptions: $filterOptions,
67:       isLoading: $isLoading,
68:       hasReachedEnd: $hasReachedEnd,
69:       currentPage: $currentPage
70:     )''';
71:   }
72: }
</file>

<file path="lib/features/cards/providers/favorites_provider.dart">
 1: // lib/features/cards/providers/favorites_provider.dart
 2: import 'package:flutter_riverpod/flutter_riverpod.dart';
 3: import '../services/favorites_service.dart';
 4: import '../models/favorite_card.dart';
 5: 
 6: final favoritesServiceProvider = Provider<FavoritesService>((ref) {
 7:   return FavoritesService();
 8: });
 9: 
10: final favoritesProvider =
11:     StateNotifierProvider<FavoritesNotifier, List<FavoriteCard>>((ref) {
12:   return FavoritesNotifier(ref.watch(favoritesServiceProvider));
13: });
14: 
15: class FavoritesNotifier extends StateNotifier<List<FavoriteCard>> {
16:   final FavoritesService _favoritesService;
17: 
18:   FavoritesNotifier(this._favoritesService) : super([]) {
19:     _loadFavorites();
20:   }
21: 
22:   void _loadFavorites() {
23:     state = _favoritesService.getAllFavorites();
24:   }
25: 
26:   Future<void> addFavorite(String productId) async {
27:     await _favoritesService.addFavorite(productId);
28:     _loadFavorites();
29:   }
30: 
31:   Future<void> removeFavorite(String productId) async {
32:     await _favoritesService.removeFavorite(productId);
33:     _loadFavorites();
34:   }
35: 
36:   bool isFavorite(String productId) {
37:     return _favoritesService.isFavorite(productId);
38:   }
39: }
</file>

<file path="lib/features/cards/repositories/card_repository.dart">
  1: // lib/features/cards/repositories/card_repository.dart
  2: 
  3: import 'package:cloud_firestore/cloud_firestore.dart';
  4: import 'package:firebase_core/firebase_core.dart' show Firebase;
  5: import '../../../core/logging/talker_service.dart';
  6: import '../../../core/services/hive_service.dart';
  7: import '../../../core/services/connectivity_service.dart';
  8: import '../models/fftcg_card.dart';
  9: import 'package:shared_preferences/shared_preferences.dart';
 10: 
 11: class CardRepository {
 12:   static const String _collectionName =
 13:       'cards'; // This matches the sync service
 14:   static const int _batchSize = 20;
 15:   static const String _lastCacheTimeKey = 'last_cache_timestamp';
 16:   static const Duration _cacheExpiration = Duration(hours: 24);
 17:   static const int _maxRetries = 3;
 18:   static const Duration _retryDelay = Duration(seconds: 2);
 19: 
 20:   final FirebaseFirestore _firestore;
 21:   final HiveService _hiveService;
 22:   final TalkerService _talker;
 23:   final ConnectivityService _connectivityService;
 24: 
 25:   CardRepository({
 26:     FirebaseFirestore? firestore,
 27:     HiveService? hiveService,
 28:     TalkerService? talker,    
 29:     ConnectivityService? connectivityService,
 30:   })  : _firestore = firestore ?? FirebaseFirestore.instance,
 31:         _hiveService = hiveService ?? HiveService(),
 32:         _talker = talker ?? TalkerService(),        
 33:         _connectivityService = connectivityService ?? ConnectivityService() {
 34:     _verifyFirebaseInitialization();
 35:   }
 36: 
 37:   void _verifyFirebaseInitialization() {
 38:     try {
 39:       Firebase.app();
 40:     } catch (e) {
 41:       _talker.severe('Firebase not initialized in CardRepository', e);
 42:       throw StateError(
 43:           'Firebase must be initialized before using CardRepository');
 44:     }
 45:   }
 46: 
 47:   Future<void> initialize() async {
 48:     try {
 49:       if (!_hiveService.isInitialized) {
 50:         await _hiveService.initialize();
 51:       }
 52:       _talker.info('Card repository initialized successfully');
 53:     } catch (e, stackTrace) {
 54:       _talker.severe('Failed to initialize card repository', e, stackTrace);
 55:       rethrow;
 56:     }
 57:   }
 58: 
 59:   Future<void> ensureInitialized() async {
 60:     if (!_hiveService.isInitialized) {
 61:       await initialize();
 62:     }
 63:   }    
 64: 
 65:   Future<List<FFTCGCard>> getCardsPage(int page) async {
 66:     await ensureInitialized();
 67: 
 68:     try {
 69:       const pageSize = _batchSize;
 70:       final start = page * pageSize;
 71: 
 72:       // First check local cache
 73:       final localCards = _hiveService.getAllCards();
 74:       if (localCards.isNotEmpty) {
 75:         final end = start + pageSize;
 76:         if (start < localCards.length) {
 77:           final sublist = localCards.sublist(
 78:               start, end > localCards.length ? localCards.length : end);
 79:           _talker.info(
 80:               'Loaded page $page with ${sublist.length} cards from cache');
 81:           return sublist;
 82:         }
 83:       }
 84: 
 85:       // Check connectivity only - removed guest check
 86:       final isConnected = await _connectivityService.hasStableConnection();
 87: 
 88:       if (!isConnected) {
 89:         _talker.info('Using local data only - No connection available');
 90:         // Return any available local cards when offline
 91:         if (start < localCards.length) {
 92:           final end = start + pageSize;
 93:           return localCards.sublist(
 94:               start, end > localCards.length ? localCards.length : end);
 95:         }
 96:         return [];
 97:       }
 98: 
 99:       // Query Firestore with pagination
100:       Query query = _firestore
101:           .collection(_collectionName)
102:           .orderBy('name')
103:           .limit(pageSize);
104: 
105:       if (page > 0) {
106:         final previousPageQuery =
107:             _firestore.collection(_collectionName).orderBy('name').limit(start);
108: 
109:         final previousPageDocs = await _retryOperation(
110:           () => previousPageQuery.get(),
111:         );
112: 
113:         if (previousPageDocs.docs.isNotEmpty) {
114:           query = query.startAfterDocument(previousPageDocs.docs.last);
115:         } else {
116:           _talker.warning('No previous page documents found for page $page');
117:           return [];
118:         }
119:       }
120: 
121:       final snapshot = await _retryOperation(() => query.get());
122:       final cards = snapshot.docs.map((doc) {
123:         final card = FFTCGCard.fromFirestore(doc);
124:         _talker.debug(
125:           'Loaded card ${card.cardNumber} with URLs - Low: ${card.lowResUrl}, High: ${card.highResUrl}',
126:         );
127:         return card;
128:       }).toList();
129: 
130:       // Cache the cards if we got a full page or it's the first page
131:       if (cards.isNotEmpty && (cards.length == pageSize || page == 0)) {
132:         await _hiveService.saveCards(cards);
133:         _talker.info('Cached ${cards.length} cards from page $page');
134:       }
135: 
136:       return cards;
137:     } catch (e, stackTrace) {
138:       if (e is FirebaseException && e.code == 'permission-denied') {
139:         _talker.severe('Permission denied accessing Firestore', e, stackTrace);
140:         rethrow; // Let the app handle the error appropriately
141:       }
142:       _talker.severe('Error getting cards page $page', e, stackTrace);
143:       rethrow;
144:     }
145:   }
146: 
147:   List<FFTCGCard> _getLocalCards({
148:     String? searchQuery,
149:     List<String>? elements,
150:     String? cardType,
151:     String? cost,
152:   }) {
153:     try {
154:       var cards = _hiveService.getAllCards();
155: 
156:       if (searchQuery?.isNotEmpty ?? false) {
157:         cards = cards
158:             .where((card) =>
159:                 card.name.toLowerCase().contains(searchQuery!.toLowerCase()) ||
160:                 (card.cardNumber
161:                         ?.toLowerCase()
162:                         .contains(searchQuery.toLowerCase()) ??
163:                     false))
164:             .toList();
165:       }
166: 
167:       if (elements?.isNotEmpty ?? false) {
168:         cards = cards
169:             .where((card) =>
170:                 elements!.any((element) => card.elements.contains(element)))
171:             .toList();
172:       }
173: 
174:       if (cardType != null) {
175:         cards = cards.where((card) => card.cardType == cardType).toList();
176:       }
177: 
178:       if (cost != null) {
179:         cards = cards.where((card) => card.cost == cost).toList();
180:       }
181: 
182:       return cards;
183:     } catch (e, stackTrace) {
184:       _talker.severe('Error getting local cards', e, stackTrace);
185:       return [];
186:     }
187:   }
188: 
189:   Future<T> _retryOperation<T>(Future<T> Function() operation) async {
190:     int attempts = 0;
191: 
192:     while (attempts < _maxRetries) {
193:       try {
194:         return await operation();
195:       } catch (e) {
196:         attempts++;
197:         if (attempts >= _maxRetries) rethrow;
198: 
199:         _talker.warning(
200:           'Operation failed, attempt $attempts of $_maxRetries. Retrying in ${_retryDelay.inSeconds}s',
201:         );
202:         await Future.delayed(_retryDelay * attempts);
203:       }
204:     }
205: 
206:     throw StateError('Operation failed after $_maxRetries attempts');
207:   }
208: 
209:   Future<void> _updateCacheTimestamp() async {
210:     try {
211:       final prefs = await SharedPreferences.getInstance();
212:       await prefs.setInt(
213:         _lastCacheTimeKey,
214:         DateTime.now().millisecondsSinceEpoch,
215:       );
216:     } catch (e) {
217:       _talker.warning('Error updating cache timestamp: $e');
218:     }
219:   }
220: 
221:   Future<bool> isCacheValid() async {
222:     try {
223:       final prefs = await SharedPreferences.getInstance();
224:       final lastCacheTime = prefs.getInt(_lastCacheTimeKey);
225: 
226:       if (lastCacheTime == null) return false;
227: 
228:       final lastCacheDateTime =
229:           DateTime.fromMillisecondsSinceEpoch(lastCacheTime);
230:       return DateTime.now().difference(lastCacheDateTime) < _cacheExpiration;
231:     } catch (e) {
232:       _talker.warning('Error checking cache validity: $e');
233:       return false;
234:     }
235:   }
236: 
237:   Future<FFTCGCard?> getCardByNumber(String cardNumber) async {
238:     await ensureInitialized();
239: 
240:     try {
241:       // First check local cache
242:       final localCard = _hiveService.getCard(cardNumber);
243:       if (localCard != null) {
244:         return localCard;
245:       }
246: 
247:       final isConnected = await _connectivityService.hasStableConnection();
248: 
249:       if (!isConnected) {
250:         _talker.info(
251:             'Using local data only for card lookup - No connection available');
252:         return null;
253:       }
254: 
255:       final querySnapshot = await _retryOperation(() => _firestore
256:           .collection(_collectionName)
257:           .where('extendedData', arrayContains: {
258:             'name': 'Number',
259:             'value': cardNumber,
260:           })
261:           .limit(1)
262:           .get());
263: 
264:       if (querySnapshot.docs.isEmpty) {
265:         _talker.warning('Card not found: $cardNumber');
266:         return null;
267:       }
268: 
269:       final card = FFTCGCard.fromFirestore(querySnapshot.docs.first);
270:       await _hiveService.saveCard(card);
271:       return card;
272:     } catch (e, stackTrace) {
273:       _talker.severe('Error getting card by number', e, stackTrace);
274:       rethrow;
275:     }
276:   }
277: 
278:   Future<List<String>> getUniqueElements() async {
279:     await ensureInitialized();
280: 
281:     try {
282:       // First check local storage
283:       final localCards = _hiveService.getAllCards();
284:       if (localCards.isNotEmpty) {
285:         return localCards.expand((card) => card.elements).toSet().toList()
286:           ..sort();
287:       }
288: 
289:       final isConnected = await _connectivityService.hasStableConnection();
290: 
291:       if (!isConnected) {
292:         _talker.info(
293:             'Using local data only for element lookup - No connection available');
294:         return [];
295:       }
296: 
297:       final querySnapshot = await _retryOperation(
298:         () => _firestore.collection(_collectionName).get(),
299:       );
300: 
301:       final elements = querySnapshot.docs
302:           .map((doc) => FFTCGCard.fromFirestore(doc))
303:           .expand((card) => card.elements)
304:           .toSet()
305:           .toList()
306:         ..sort();
307: 
308:       return elements;
309:     } catch (e, stackTrace) {
310:       _talker.severe('Error getting unique elements', e, stackTrace);
311:       rethrow;
312:     }
313:   }
314: 
315:   Future<List<String>> getUniqueCardTypes() async {
316:     await ensureInitialized();
317: 
318:     try {
319:       // First check local storage
320:       final localCards = _hiveService.getAllCards();
321:       if (localCards.isNotEmpty) {
322:         return localCards
323:             .map((card) => card.cardType)
324:             .where((type) => type != null)
325:             .toSet()
326:             .cast<String>()
327:             .toList()
328:           ..sort();
329:       }
330: 
331:       final isConnected = await _connectivityService.hasStableConnection();
332: 
333:       if (!isConnected) {
334:         _talker.info(
335:             'Using local data only for card type lookup - No connection available');
336:         return [];
337:       }
338: 
339:       final querySnapshot = await _retryOperation(
340:         () => _firestore.collection(_collectionName).get(),
341:       );
342: 
343:       final cardTypes = querySnapshot.docs
344:           .map((doc) => FFTCGCard.fromFirestore(doc))
345:           .map((card) => card.cardType)
346:           .where((type) => type != null)
347:           .toSet()
348:           .cast<String>()
349:           .toList()
350:         ..sort();
351: 
352:       return cardTypes;
353:     } catch (e, stackTrace) {
354:       _talker.severe('Error getting unique card types', e, stackTrace);
355:       rethrow;
356:     }
357:   }
358: 
359:   Future<List<FFTCGCard>> getAllCards() async {
360:     await ensureInitialized();
361: 
362:     try {
363:       // First check local storage
364:       final localCards = _hiveService.getAllCards();
365:       if (localCards.isNotEmpty) {
366:         return localCards;
367:       }
368: 
369:       final isConnected = await _connectivityService.hasStableConnection();
370: 
371:       if (!isConnected) {
372:         _talker.info(
373:             'Using local data only for full card list - No connection available');
374:         return localCards;
375:       }
376: 
377:       // Fetch in batches to handle large datasets
378:       final List<FFTCGCard> allCards = [];
379:       DocumentSnapshot? lastDocument;
380:       bool hasMoreData = true;
381: 
382:       while (hasMoreData) {
383:         Query query = _firestore
384:             .collection(_collectionName)
385:             .orderBy(FieldPath.documentId)
386:             .limit(_batchSize);
387: 
388:         if (lastDocument != null) {
389:           query = query.startAfterDocument(lastDocument);
390:         }
391: 
392:         final querySnapshot = await _retryOperation(() => query.get());
393: 
394:         if (querySnapshot.docs.isEmpty) {
395:           hasMoreData = false;
396:           continue;
397:         }
398: 
399:         final batchCards = querySnapshot.docs
400:             .map((doc) => FFTCGCard.fromFirestore(doc))
401:             .toList();
402: 
403:         allCards.addAll(batchCards);
404:         lastDocument = querySnapshot.docs.last;
405: 
406:         // Save batch to local storage
407:         await _hiveService.saveCards(batchCards);
408: 
409:         _talker.info('Fetched batch of ${batchCards.length} cards');
410:       }
411: 
412:       await _updateCacheTimestamp();
413:       _talker.info('Retrieved total of ${allCards.length} cards');
414:       return allCards;
415:     } catch (e, stackTrace) {
416:       _talker.severe('Error getting all cards', e, stackTrace);
417:       rethrow;
418:     }
419:   }
420: 
421:   Future<List<FFTCGCard>> searchCards(String query) async {
422:     await ensureInitialized();
423: 
424:     try {
425:       // First search locally
426:       final localResults = _getLocalCards(searchQuery: query);
427:       if (localResults.isNotEmpty) {
428:         return localResults;
429:       }
430: 
431:       final isConnected = await _connectivityService.hasStableConnection();
432: 
433:       if (!isConnected) {
434:         _talker
435:             .info('Using local data only for search - No connection available');
436:         return localResults;
437:       }
438: 
439:       final querySnapshot = await _retryOperation(() => _firestore
440:           .collection(_collectionName)
441:           .where('name', isGreaterThanOrEqualTo: query.toLowerCase())
442:           .where('name', isLessThan: '${query.toLowerCase()}z')
443:           .limit(_batchSize)
444:           .get());
445: 
446:       final cards = querySnapshot.docs
447:           .map((doc) => FFTCGCard.fromFirestore(doc))
448:           .toList();
449: 
450:       // Cache search results
451:       if (cards.isNotEmpty) {
452:         await _hiveService.saveCards(cards);
453:         await _updateCacheTimestamp();
454:       }
455: 
456:       return cards;
457:     } catch (e, stackTrace) {
458:       _talker.severe('Error searching cards', e, stackTrace);
459:       return _getLocalCards(searchQuery: query);
460:     }
461:   }
462: 
463:   Future<void> clearLocalData() async {
464:     try {
465:       await ensureInitialized();
466:       await _hiveService.clearAll();
467:       _talker.info('Local data cleared successfully');
468:     } catch (e, stackTrace) {
469:       _talker.severe('Error clearing local data', e, stackTrace);
470:       rethrow;
471:     }
472:   }
473: 
474:   @override
475:   String toString() {
476:     return 'CardRepository(firestore: $_firestore, hiveService: $_hiveService)';
477:   }
478: }
479: 
480: class CardRepositoryException implements Exception {
481:   final String message;
482:   final String? code;
483:   final dynamic originalError;
484: 
485:   CardRepositoryException(
486:     this.message, {
487:     this.code,
488:     this.originalError,
489:   });
490: 
491:   @override
492:   String toString() =>
493:       'CardRepositoryException: $message${code != null ? ' (Code: $code)' : ''}';
494: }
</file>

<file path="lib/features/cards/services/card_cache_service.dart">
  1: import 'dart:convert';
  2: import 'package:flutter_cache_manager/flutter_cache_manager.dart';
  3: import 'package:path_provider/path_provider.dart';
  4: import 'package:shared_preferences/shared_preferences.dart';
  5: import '../../../core/logging/talker_service.dart';
  6: import '../models/card_filter_options.dart';
  7: import '../models/fftcg_card.dart';
  8: import '../models/price_model.dart';
  9: 
 10: class CardCacheManager extends CacheManager {
 11:   static const key = 'card_cache';
 12:   static const Duration maxAge = Duration(days: 7);
 13:   static final CardCacheManager _instance = CardCacheManager._();
 14: 
 15:   factory CardCacheManager() => _instance;
 16: 
 17:   CardCacheManager._()
 18:       : super(
 19:           Config(
 20:             key,
 21:             stalePeriod: maxAge,
 22:             maxNrOfCacheObjects: 1000,
 23:             repo: JsonCacheInfoRepository(databaseName: key),
 24:             fileSystem: IOFileSystem(key),
 25:             fileService: HttpFileService(),
 26:           ),
 27:         );
 28: 
 29:   static Future<void> initialize() async {
 30:     final directory = await getTemporaryDirectory();
 31:     await directory.create(recursive: true);
 32:   }
 33: 
 34:   bool isExpired(FileInfo fileInfo) {
 35:     return fileInfo.validTill.isBefore(DateTime.now());
 36:   }
 37: 
 38:   Future<FileInfo?> downloadAndStoreFile(String url) async {
 39:     try {
 40:       return await downloadFile(url);
 41:     } catch (e) {
 42:       return null;
 43:     }
 44:   }
 45: 
 46:   @override
 47:   Future<void> emptyCache() async {
 48:     await super.emptyCache();
 49:   }
 50: }
 51: 
 52: /// A wrapper class for cached document data
 53: class CachedDocument {
 54:   final String id;
 55:   final Map<String, dynamic> _data;
 56: 
 57:   CachedDocument({
 58:     required this.id,
 59:     required Map<String, dynamic> data,
 60:   }) : _data = data;
 61: 
 62:   Map<String, dynamic>? data() => _data;
 63: 
 64:   dynamic get(Object field) => _data[field.toString()];
 65: 
 66:   bool get exists => true;
 67: 
 68:   dynamic operator [](Object field) => get(field);
 69: }
 70: 
 71: class CardCacheService {
 72:   final SharedPreferences prefs;
 73:   final TalkerService _talker;
 74:   final CardCacheManager _cacheManager;
 75:   static const String filterOptionsKey = 'card_filter_options';
 76:   static const String recentCardsKey = 'recent_cards';
 77:   static const int maxRecentCards = 50;
 78:   static const String pricePrefix = 'price_';
 79:   static const String cardPrefix = 'card_';
 80:   static const Duration priceCacheExpiration = Duration(hours: 24);
 81: 
 82:   CardCacheService({
 83:     required this.prefs,
 84:     CardCacheManager? cacheManager, // Change type here
 85:     TalkerService? talker,
 86:   })  : _cacheManager = cacheManager ?? CardCacheManager(),
 87:         _talker = talker ?? TalkerService();
 88: 
 89:   // Price caching methods
 90:   Future<PriceModel?> getCachedPrice(String productId) async {
 91:     try {
 92:       final key = '$pricePrefix$productId';
 93:       final data = prefs.getString(key);
 94:       if (data == null) return null;
 95: 
 96:       final map = jsonDecode(data) as Map<String, dynamic>;
 97:       final cachedAt = DateTime.parse(map['cached_at'] as String);
 98: 
 99:       if (DateTime.now().difference(cachedAt) > priceCacheExpiration) {
100:         await prefs.remove(key);
101:         return null;
102:       }
103: 
104:       return PriceModel.fromJson(map, productId);
105:     } catch (e) {
106:       _talker.severe('Error getting cached price', e);
107:       return null;
108:     }
109:   }
110: 
111:   // Card caching methods
112:   Future<void> cacheCard(FFTCGCard card) async {
113:     try {
114:       final key = '$cardPrefix${card.cardNumber}';
115:       await prefs.setString(key, jsonEncode(card.toMap()));
116:       _talker.debug('Card cached: ${card.cardNumber}');
117:     } catch (e) {
118:       _talker.severe('Error caching card', e);
119:     }
120:   }
121: 
122:   Future<FFTCGCard?> getCachedCard(String cardNumber) async {
123:     try {
124:       final key = '$cardPrefix$cardNumber';
125:       final data = prefs.getString(key);
126:       if (data == null) return null;
127: 
128:       final map = jsonDecode(data) as Map<String, dynamic>;
129:       return FFTCGCard.fromJson(map, cardNumber);
130:     } catch (e) {
131:       _talker.severe('Error getting cached card', e);
132:       return null;
133:     }
134:   }
135: 
136:   // Filter options
137:   Future<void> saveFilterOptions(CardFilterOptions options) async {
138:     try {
139:       await prefs.setString(filterOptionsKey, jsonEncode(options.toJson()));
140:       _talker.info('Filter options saved to cache');
141:     } catch (e) {
142:       _talker.severe('Error saving filter options', e);
143:     }
144:   }
145: 
146:   CardFilterOptions? getFilterOptions() {
147:     try {
148:       final data = prefs.getString(filterOptionsKey);
149:       if (data == null) return null;
150:       return CardFilterOptions.fromJson(jsonDecode(data));
151:     } catch (e) {
152:       _talker.severe('Error loading filter options', e);
153:       return null;
154:     }
155:   }
156: 
157:   // Recent cards management
158:   Future<void> addRecentCard(FFTCGCard card) async {
159:     try {
160:       final List<String> recentCards =
161:           prefs.getStringList(recentCardsKey) ?? [];
162:       final String cardNumber = card.cardNumber ?? '';
163: 
164:       if (cardNumber.isNotEmpty) {
165:         recentCards.remove(cardNumber);
166:         recentCards.insert(0, cardNumber);
167: 
168:         if (recentCards.length > maxRecentCards) {
169:           recentCards.removeLast();
170:         }
171: 
172:         await prefs.setStringList(recentCardsKey, recentCards);
173:         await cacheCard(card); // Cache the card data as well
174:         _talker.info('Added card to recent cards: $cardNumber');
175:       }
176:     } catch (e) {
177:       _talker.severe('Error adding recent card', e);
178:     }
179:   }
180: 
181:   List<String> getRecentCards() {
182:     try {
183:       return prefs.getStringList(recentCardsKey) ?? [];
184:     } catch (e) {
185:       _talker.severe('Error getting recent cards', e);
186:       return [];
187:     }
188:   }
189: 
190:   Future<void> clearRecentCards() async {
191:     try {
192:       await prefs.remove(recentCardsKey);
193:       _talker.info('Recent cards cleared');
194:     } catch (e) {
195:       _talker.severe('Error clearing recent cards', e);
196:     }
197:   }
198: 
199:   // Image caching
200:   Future<void> clearImageCache() async {
201:     try {
202:       await _cacheManager.emptyCache();
203:       _talker.info('Image cache cleared');
204:     } catch (e) {
205:       _talker.severe('Error clearing image cache', e);
206:     }
207:   }
208: 
209:   Future<void> preCacheCard(FFTCGCard card) async {
210:     const maxRetries = 3;
211:     int retryCount = 0;
212: 
213:     while (retryCount < maxRetries) {
214:       try {
215:         _talker.info('Pre-caching images for card: ${card.cardNumber}');
216: 
217:         // Pre-cache both resolutions
218:         await Future.wait([
219:           _cacheManager.downloadAndStoreFile(card.effectiveLowResUrl),
220:           _cacheManager.downloadAndStoreFile(card.effectiveHighResUrl),
221:         ]);
222: 
223:         break;
224:       } catch (e) {
225:         retryCount++;
226:         if (retryCount >= maxRetries) {
227:           _talker.warning(
228:             'Failed to pre-cache card after $maxRetries attempts: ${card.cardNumber}. Error: $e',
229:           );
230:         } else {
231:           await Future.delayed(Duration(seconds: retryCount));
232:         }
233:       }
234:     }
235:   }
236: 
237:   Future<void> preCacheCards(List<FFTCGCard> cards) async {
238:     try {
239:       _talker.info('Pre-caching images for ${cards.length} cards');
240: 
241:       const batchSize = 5; // Reduced batch size for better control
242:       for (var i = 0; i < cards.length; i += batchSize) {
243:         final end =
244:             (i + batchSize < cards.length) ? i + batchSize : cards.length;
245:         final batch = cards.sublist(i, end);
246: 
247:         await Future.wait(
248:           batch.map((card) async {
249:             try {
250:               await preCacheCard(card);
251:             } catch (e) {
252:               _talker.warning('Error pre-caching card ${card.cardNumber}: $e');
253:             }
254:           }),
255:         );
256: 
257:         // Add delay between batches to prevent rate limiting
258:         if (end < cards.length) {
259:           await Future.delayed(const Duration(milliseconds: 500));
260:         }
261:       }
262:     } catch (e) {
263:       _talker.warning('Error pre-caching cards: $e');
264:     }
265:   }
266: 
267:   CacheManager get imageCacheManager => _cacheManager;
268: 
269:   @override
270:   String toString() {
271:     final recentCount = getRecentCards().length;
272:     final hasFilters = getFilterOptions() != null;
273:     return 'CardCacheService(recentCards: $recentCount, hasStoredFilters: $hasFilters)';
274:   }
275: }
</file>

<file path="lib/features/cards/services/favorites_service.dart">
 1: // lib/features/cards/services/favorites_service.dart
 2: import 'package:hive_flutter/hive_flutter.dart';
 3: import '../../../core/logging/talker_service.dart';
 4: import '../models/favorite_card.dart';
 5: 
 6: class FavoritesService {
 7:   late Box<FavoriteCard> _favoritesBox;
 8:   final TalkerService _talker;
 9:   static const String boxName = 'favorites';
10: 
11:   FavoritesService({TalkerService? talker})
12:       : _talker = talker ?? TalkerService() {
13:     initBox();
14:   }
15: 
16:   Future<void> initBox() async {
17:     try {
18:       if (!Hive.isBoxOpen(boxName)) {
19:         _favoritesBox = await Hive.openBox<FavoriteCard>(boxName);
20:       } else {
21:         _favoritesBox = Hive.box<FavoriteCard>(boxName);
22:       }
23:       _talker.info('Favorites box initialized');
24:     } catch (e) {
25:       _talker.severe('Error initializing favorites box', e);
26:     }
27:   }
28: 
29:   Future<void> initialize() async {
30:     try {
31:       if (!Hive.isAdapterRegistered(4)) {
32:         Hive.registerAdapter(FavoriteCardAdapter());
33:       }
34:       _favoritesBox = await Hive.openBox<FavoriteCard>(boxName);
35:       _talker.info('FavoritesService initialized');
36:     } catch (e, stackTrace) {
37:       _talker.severe('Error initializing FavoritesService', e, stackTrace);
38:       rethrow;
39:     }
40:   }
41: 
42:   Future<void> addFavorite(String productId) async {
43:     try {
44:       final favorite = FavoriteCard(
45:         productId: productId,
46:         addedAt: DateTime.now(),
47:       );
48:       await _favoritesBox.put(productId, favorite);
49:       _talker.info('Added card to favorites: $productId');
50:     } catch (e, stackTrace) {
51:       _talker.severe('Error adding favorite', e, stackTrace);
52:       rethrow;
53:     }
54:   }
55: 
56:   Future<void> removeFavorite(String productId) async {
57:     try {
58:       await _favoritesBox.delete(productId);
59:       _talker.info('Removed card from favorites: $productId');
60:     } catch (e, stackTrace) {
61:       _talker.severe('Error removing favorite', e, stackTrace);
62:       rethrow;
63:     }
64:   }
65: 
66:   bool isFavorite(String productId) {
67:     try {
68:       return _favoritesBox.containsKey(productId);
69:     } catch (e, stackTrace) {
70:       _talker.severe('Error checking favorite status', e, stackTrace);
71:       return false;
72:     }
73:   }
74: 
75:   List<FavoriteCard> getAllFavorites() {
76:     try {
77:       return _favoritesBox.values.toList();
78:     } catch (e, stackTrace) {
79:       _talker.severe('Error getting all favorites', e, stackTrace);
80:       return [];
81:     }
82:   }
83: 
84:   Future<void> clearFavorites() async {
85:     try {
86:       await _favoritesBox.clear();
87:       _talker.info('Cleared all favorites');
88:     } catch (e, stackTrace) {
89:       _talker.severe('Error clearing favorites', e, stackTrace);
90:       rethrow;
91:     }
92:   }
93: }
</file>

<file path="lib/features/collection/presentation/screens/collection_screen.dart">
 1: import 'package:flutter/material.dart';
 2: 
 3: class CollectionScreen extends StatelessWidget {
 4:   const CollectionScreen({super.key});
 5: 
 6:   @override
 7:   Widget build(BuildContext context) {
 8:     return const Scaffold(      
 9:       body: Center(
10:         child: Text('Collection Screen - Coming Soon'),
11:       ),
12:     );
13:   }
14: }
</file>

<file path="lib/features/decks/presentation/screens/decks_screen.dart">
 1: import 'package:flutter/material.dart';
 2: 
 3: class DecksScreen extends StatelessWidget {
 4:   const DecksScreen({super.key});
 5: 
 6:   @override
 7:   Widget build(BuildContext context) {
 8:     return const Scaffold(      
 9:       body: Center(
10:         child: Text('Decks Screen - Coming Soon'),
11:       ),
12:     );
13:   }
14: }
</file>

<file path="lib/features/profile/models/collection_stats.dart">
 1: import 'package:freezed_annotation/freezed_annotation.dart';
 2: 
 3: part 'collection_stats.freezed.dart';
 4: part 'collection_stats.g.dart';
 5: 
 6: @freezed
 7: class CollectionStats with _$CollectionStats {
 8:   const factory CollectionStats({
 9:     required String cardNumber,
10:     required bool isFoil,
11:     required double value,
12:     DateTime? acquired,
13:   }) = _CollectionStats;
14: 
15:   factory CollectionStats.fromJson(Map<String, dynamic> json) =>
16:       _$CollectionStatsFromJson(json);
17: }
</file>

<file path="lib/features/profile/models/deck_stats.dart">
 1: import 'package:freezed_annotation/freezed_annotation.dart';
 2: 
 3: part 'deck_stats.freezed.dart';
 4: part 'deck_stats.g.dart';
 5: 
 6: @freezed
 7: class DeckStats with _$DeckStats {
 8:   const factory DeckStats({
 9:     required String deckId,
10:     required String name,
11:     required Map<String, int> elementCount,
12:     required DateTime created,
13:     DateTime? lastModified,
14:   }) = _DeckStats;
15: 
16:   factory DeckStats.fromJson(Map<String, dynamic> json) =>
17:       _$DeckStatsFromJson(json);
18: }
</file>

<file path="lib/features/profile/models/user_stats.dart">
 1: import 'package:freezed_annotation/freezed_annotation.dart';
 2: 
 3: part 'user_stats.freezed.dart';
 4: part 'user_stats.g.dart';
 5: 
 6: @freezed
 7: class UserStats with _$UserStats {
 8:   const factory UserStats({
 9:     @Default(0) int totalCards,
10:     @Default(0) int foilCards,
11:     @Default(0) int nonFoilCards,
12:     @Default(0.0) double totalValue,
13:     @Default(0) int totalDecks,
14:     String? mostUsedElement,
15:     @Default({}) Map<String, int> elementUsageStats,
16:     DateTime? lastUpdated,
17:   }) = _UserStats;
18: 
19:   factory UserStats.fromJson(Map<String, dynamic> json) =>
20:       _$UserStatsFromJson(json);
21: }
</file>

<file path="lib/features/profile/presentation/screens/profile_screen.dart">
  1: // lib/features/profile/presentation/screens/profile_screen.dart
  2: 
  3: import 'package:flutter/material.dart';
  4: import 'package:flutter_riverpod/flutter_riverpod.dart';
  5: import 'package:go_router/go_router.dart';
  6: import '../../../../core/logging/talker_service.dart';
  7: import '../../../../core/utils/responsive_utils.dart';
  8: import '../../../../models/user_model.dart';
  9: import '../../models/user_stats.dart';
 10: import '../widgets/profile_header.dart';
 11: import '../widgets/collection_stats.dart';
 12: import '../widgets/deck_stats.dart';
 13: import '../../../auth/providers/auth_providers.dart';
 14: import '../../providers/user_stats_provider.dart';
 15: 
 16: class ProfileScreen extends ConsumerWidget {
 17:   final VoidCallback handleLogout;
 18:   final TalkerService _talker = TalkerService();
 19: 
 20:   ProfileScreen({
 21:     super.key,
 22:     required this.handleLogout,
 23:   });
 24: 
 25:   Future<void> _handleLogout(BuildContext context, WidgetRef ref) async {
 26:     try {
 27:       await ref.read(authNotifierProvider.notifier).signOut();
 28:       if (context.mounted) {
 29:         context.go('/auth/login');
 30:       }
 31:     } catch (e, stackTrace) {
 32:       _talker.severe('Logout failed', e, stackTrace);
 33:       if (context.mounted) {
 34:         ScaffoldMessenger.of(context).showSnackBar(
 35:           SnackBar(content: Text('Failed to logout: $e')),
 36:         );
 37:       }
 38:     }
 39:   }
 40: 
 41:   @override
 42:   Widget build(BuildContext context, WidgetRef ref) {
 43:     final user = ref.watch(currentUserProvider);
 44:     final stats = ref.watch(userStatsProvider);
 45:     final themeColor = Theme.of(context).colorScheme.primary;
 46: 
 47:     return Scaffold(
 48:       body: RefreshIndicator(
 49:         onRefresh: () async {
 50:           ref.invalidate(userStatsProvider);
 51:         },
 52:         child: ResponsiveUtils.buildResponsiveLayout(
 53:           context: context,
 54:           mobile: _buildMobileLayout(context, user, stats, themeColor),
 55:           tablet: _buildTabletLayout(context, user, stats, themeColor),
 56:           desktop: _buildDesktopLayout(context, user, stats, themeColor),
 57:         ),
 58:       ),
 59:     );
 60:   }
 61: 
 62:   Widget _buildMobileLayout(
 63:     BuildContext context,
 64:     UserModel? user,
 65:     UserStats stats,
 66:     Color themeColor,
 67:   ) {
 68:     return SingleChildScrollView(
 69:       padding: ResponsiveUtils.getScreenPadding(context),
 70:       child: Column(
 71:         children: [
 72:           ProfileHeader(
 73:             userName: user?.displayName ?? 'Guest User',
 74:             email: user?.email,
 75:             avatarUrl: user?.photoURL,
 76:             avatarColor: themeColor,
 77:             size: ResponsiveUtils.isPhone(context) ? 80 : 100,
 78:             onLogout: () => _handleLogout(context, WidgetRef as WidgetRef),
 79:           ),
 80:           const Divider(),
 81:           _buildStats(context, stats),
 82:         ],
 83:       ),
 84:     );
 85:   }
 86: 
 87:   Widget _buildTabletLayout(
 88:     BuildContext context,
 89:     UserModel? user,
 90:     UserStats stats,
 91:     Color themeColor,
 92:   ) {
 93:     return SingleChildScrollView(
 94:       padding: ResponsiveUtils.getScreenPadding(context),
 95:       child: ResponsiveUtils.wrapWithMaxWidth(
 96:         Column(
 97:           children: [
 98:             ProfileHeader(
 99:               userName: user?.displayName ?? 'Guest User',
100:               email: user?.email,
101:               avatarUrl: user?.photoURL,
102:               avatarColor: themeColor,
103:               size: 120,
104:               onLogout: () => _handleLogout(context, WidgetRef as WidgetRef),
105:             ),
106:             const Divider(),
107:             Row(
108:               crossAxisAlignment: CrossAxisAlignment.start,
109:               children: [
110:                 Expanded(
111:                   child: CollectionStats(
112:                     totalCards: stats.totalCards,
113:                     foilCards: stats.foilCards,
114:                     nonFoilCards: stats.nonFoilCards,
115:                     collectionValue: stats.totalValue,
116:                   ),
117:                 ),
118:                 const SizedBox(width: 16),
119:                 Expanded(
120:                   child: DeckStats(
121:                     totalDecks: stats.totalDecks,
122:                     favoriteElement: stats.mostUsedElement,
123:                     elementUsage: stats.elementUsageStats,
124:                   ),
125:                 ),
126:               ],
127:             ),
128:           ],
129:         ),
130:         context,
131:       ),
132:     );
133:   }
134: 
135:   Widget _buildDesktopLayout(
136:     BuildContext context,
137:     UserModel? user,
138:     UserStats stats,
139:     Color themeColor,
140:   ) {
141:     return SingleChildScrollView(
142:       padding: ResponsiveUtils.getScreenPadding(context),
143:       child: ResponsiveUtils.wrapWithMaxWidth(
144:         Row(
145:           crossAxisAlignment: CrossAxisAlignment.start,
146:           children: [
147:             Expanded(
148:               flex: 3,
149:               child: Column(
150:                 children: [
151:                   ProfileHeader(
152:                     userName: user?.displayName ?? 'Guest User',
153:                     email: user?.email,
154:                     avatarUrl: user?.photoURL,
155:                     avatarColor: themeColor,
156:                     size: 150,
157:                     onLogout: () => _handleLogout(context, WidgetRef as WidgetRef),
158:                   ),
159:                   const Divider(),
160:                 ],
161:               ),
162:             ),
163:             const SizedBox(width: 32),
164:             Expanded(
165:               flex: 7,
166:               child: Row(
167:                 crossAxisAlignment: CrossAxisAlignment.start,
168:                 children: [
169:                   Expanded(
170:                     child: CollectionStats(
171:                       totalCards: stats.totalCards,
172:                       foilCards: stats.foilCards,
173:                       nonFoilCards: stats.nonFoilCards,
174:                       collectionValue: stats.totalValue,
175:                     ),
176:                   ),
177:                   const SizedBox(width: 24),
178:                   Expanded(
179:                     child: DeckStats(
180:                       totalDecks: stats.totalDecks,
181:                       favoriteElement: stats.mostUsedElement,
182:                       elementUsage: stats.elementUsageStats,
183:                     ),
184:                   ),
185:                 ],
186:               ),
187:             ),
188:           ],
189:         ),
190:         context,
191:       ),
192:     );
193:   }
194: 
195:   Widget _buildStats(BuildContext context, UserStats stats) {
196:     return Column(
197:       crossAxisAlignment: CrossAxisAlignment.start,
198:       children: [
199:         Text(
200:           'Collection Stats',
201:           style: Theme.of(context).textTheme.titleLarge?.copyWith(
202:                 fontSize: ResponsiveUtils.getResponsiveFontSize(context, 24),
203:               ),
204:         ),
205:         const SizedBox(height: 16),
206:         CollectionStats(
207:           totalCards: stats.totalCards,
208:           foilCards: stats.foilCards,
209:           nonFoilCards: stats.nonFoilCards,
210:           collectionValue: stats.totalValue,
211:         ),
212:         const SizedBox(height: 24),
213:         Text(
214:           'Deck Stats',
215:           style: Theme.of(context).textTheme.titleLarge?.copyWith(
216:                 fontSize: ResponsiveUtils.getResponsiveFontSize(context, 24),
217:               ),
218:         ),
219:         const SizedBox(height: 16),
220:         DeckStats(
221:           totalDecks: stats.totalDecks,
222:           favoriteElement: stats.mostUsedElement,
223:           elementUsage: stats.elementUsageStats,
224:         ),
225:       ],
226:     );
227:   }
228: }
</file>

<file path="lib/features/profile/presentation/widgets/collection_stats.dart">
 1: import 'package:flutter/material.dart';
 2: 
 3: class CollectionStats extends StatelessWidget {
 4:   final int totalCards;
 5:   final int foilCards;
 6:   final int nonFoilCards;
 7:   final double collectionValue;
 8: 
 9:   const CollectionStats({
10:     super.key,
11:     required this.totalCards,
12:     required this.foilCards,
13:     required this.nonFoilCards,
14:     required this.collectionValue,
15:   });
16: 
17:   @override
18:   Widget build(BuildContext context) {
19:     return Padding(
20:       padding: const EdgeInsets.symmetric(horizontal: 16.0),
21:       child: Card(
22:         child: Padding(
23:           padding: const EdgeInsets.all(16.0),
24:           child: Column(
25:             children: [
26:               _buildStatRow(
27:                 context,
28:                 'Total Cards',
29:                 totalCards.toString(),
30:               ),
31:               const Divider(),
32:               _buildStatRow(
33:                 context,
34:                 'Foil Cards',
35:                 foilCards.toString(),
36:               ),
37:               const Divider(),
38:               _buildStatRow(
39:                 context,
40:                 'Non-Foil Cards',
41:                 nonFoilCards.toString(),
42:               ),
43:               const Divider(),
44:               _buildStatRow(
45:                 context,
46:                 'Collection Value',
47:                 '\$${collectionValue.toStringAsFixed(2)}',
48:               ),
49:             ],
50:           ),
51:         ),
52:       ),
53:     );
54:   }
55: 
56:   Widget _buildStatRow(BuildContext context, String label, String value) {
57:     return Padding(
58:       padding: const EdgeInsets.symmetric(vertical: 8.0),
59:       child: Row(
60:         mainAxisAlignment: MainAxisAlignment.spaceBetween,
61:         children: [
62:           Text(label),
63:           Text(
64:             value,
65:             style: Theme.of(context).textTheme.titleMedium,
66:           ),
67:         ],
68:       ),
69:     );
70:   }
71: }
</file>

<file path="lib/features/profile/presentation/widgets/deck_stats.dart">
 1: import 'package:flutter/material.dart';
 2: 
 3: class DeckStats extends StatelessWidget {
 4:   final int totalDecks;
 5:   final String? favoriteElement;
 6:   final Map<String, int> elementUsage;
 7: 
 8:   const DeckStats({
 9:     super.key,
10:     required this.totalDecks,
11:     required this.favoriteElement,
12:     required this.elementUsage,
13:   });
14: 
15:   @override
16:   Widget build(BuildContext context) {
17:     return Padding(
18:       padding: const EdgeInsets.symmetric(horizontal: 16.0),
19:       child: Card(
20:         child: Padding(
21:           padding: const EdgeInsets.all(16.0),
22:           child: Column(
23:             children: [
24:               _buildStatRow(
25:                 context,
26:                 'Total Decks',
27:                 totalDecks.toString(),
28:               ),
29:               if (favoriteElement != null) ...[
30:                 const Divider(),
31:                 _buildStatRow(
32:                   context,
33:                   'Favorite Element',
34:                   favoriteElement!,
35:                 ),
36:               ],
37:               const Divider(),
38:               const Text('Element Usage'),
39:               const SizedBox(height: 8),
40:               ...elementUsage.entries.map((entry) {
41:                 return Padding(
42:                   padding: const EdgeInsets.symmetric(vertical: 4.0),
43:                   child: LinearProgressIndicator(
44:                     value: entry.value / totalDecks,
45:                     backgroundColor:
46:                         Theme.of(context).colorScheme.surfaceContainerHighest,
47:                     valueColor: AlwaysStoppedAnimation<Color>(
48:                       Theme.of(context).colorScheme.primary,
49:                     ),
50:                   ),
51:                 );
52:               }),
53:             ],
54:           ),
55:         ),
56:       ),
57:     );
58:   }
59: 
60:   Widget _buildStatRow(BuildContext context, String label, String value) {
61:     return Padding(
62:       padding: const EdgeInsets.symmetric(vertical: 8.0),
63:       child: Row(
64:         mainAxisAlignment: MainAxisAlignment.spaceBetween,
65:         children: [
66:           Text(label),
67:           Text(
68:             value,
69:             style: Theme.of(context).textTheme.titleMedium,
70:           ),
71:         ],
72:       ),
73:     );
74:   }
75: }
</file>

<file path="lib/features/profile/presentation/widgets/profile_header.dart">
 1: // lib/features/profile/presentation/widgets/profile_header.dart
 2: 
 3: import 'package:flutter/material.dart';
 4: 
 5: class ProfileHeader extends StatelessWidget {
 6:   final String userName;
 7:   final String? email;
 8:   final String? avatarUrl;
 9:   final Color avatarColor;
10:   final double size;
11:   final VoidCallback onLogout; // Add this
12: 
13:   const ProfileHeader({
14:     super.key,
15:     required this.userName,
16:     this.email,
17:     this.avatarUrl,
18:     required this.avatarColor,
19:     required this.size,
20:     required this.onLogout, // Add this
21:   });
22: 
23:   @override
24:   Widget build(BuildContext context) {
25:     return Padding(
26:       padding: const EdgeInsets.all(16.0),
27:       child: Row(
28:         children: [
29:           CircleAvatar(
30:             radius: size / 2,
31:             backgroundColor: avatarColor,
32:             backgroundImage:
33:                 avatarUrl != null ? NetworkImage(avatarUrl!) : null,
34:             child: avatarUrl == null
35:                 ? Icon(
36:                     Icons.person,
37:                     size: size / 2,
38:                     color: Colors.white,
39:                   )
40:                 : null,
41:           ),
42:           const SizedBox(width: 16),
43:           Expanded(
44:             child: Column(
45:               crossAxisAlignment: CrossAxisAlignment.start,
46:               children: [
47:                 Text(
48:                   userName,
49:                   style: Theme.of(context).textTheme.headlineSmall,
50:                 ),
51:                 if (email != null)
52:                   Text(
53:                     email!,
54:                     style: Theme.of(context).textTheme.bodyMedium,
55:                   ),
56:               ],
57:             ),
58:           ),
59:         ],
60:       ),
61:     );
62:   }
63: }
</file>

<file path="lib/features/profile/providers/user_stats_provider.dart">
1: import 'package:flutter_riverpod/flutter_riverpod.dart';
2: import '../models/user_stats.dart';
3: 
4: final userStatsProvider = StateProvider<UserStats>((ref) {
5:   return const UserStats();
6: });
</file>

<file path="lib/features/scanner/presentation/screens/scanner_screen.dart">
 1: import 'package:flutter/material.dart';
 2: 
 3: class ScannerScreen extends StatelessWidget {
 4:   const ScannerScreen({super.key});
 5: 
 6:   @override
 7:   Widget build(BuildContext context) {
 8:     return const Scaffold(      
 9:       body: Center(
10:         child: Text('Scanner Screen - Coming Soon'),
11:       ),
12:     );
13:   }
14: }
</file>

<file path="lib/features/settings/presentation/screens/logs_viewer_screen.dart">
 1: import 'package:flutter/material.dart';
 2: import 'package:flutter_riverpod/flutter_riverpod.dart';
 3: import 'package:talker_flutter/talker_flutter.dart';
 4: import '../../../../core/logging/talker_service.dart';
 5: 
 6: class LogsViewerScreen extends ConsumerStatefulWidget {
 7:   const LogsViewerScreen({super.key});
 8: 
 9:   @override
10:   ConsumerState<LogsViewerScreen> createState() => _LogsViewerScreenState();
11: }
12: 
13: class _LogsViewerScreenState extends ConsumerState<LogsViewerScreen> {
14:   late final TalkerService _talkerService;
15: 
16:   @override
17:   void initState() {
18:     super.initState();
19:     _talkerService = ref.read(talkerServiceProvider);
20:   }
21: 
22:   @override
23:   Widget build(BuildContext context) {
24:     return TalkerScreen(
25:       talker: _talkerService.talker,
26:       appBarTitle: 'App Logs',
27:       theme: TalkerScreenTheme(
28:         backgroundColor: Theme.of(context).scaffoldBackgroundColor,
29:         textColor: Theme.of(context).textTheme.bodyLarge?.color ?? Colors.white,
30:         cardColor: Theme.of(context).cardColor,
31:         logColors: {
32:           TalkerLogType.error.key: Theme.of(context).colorScheme.error,
33:           TalkerLogType.warning.key: Colors.orange,
34:           TalkerLogType.info.key: Theme.of(context).colorScheme.primary,
35:           TalkerLogType.debug.key: Colors.grey,
36:           TalkerLogType.verbose.key: Colors.grey[600] ?? Colors.grey,
37:           TalkerLogType.critical.key: Colors.redAccent,
38:         },
39:       ),
40:     );
41:   }
42: }
</file>

<file path="lib/features/settings/presentation/screens/settings_screen.dart">
  1: // lib/features/settings/presentation/screens/settings_screen.dart
  2: 
  3: import 'package:flutter/material.dart';
  4: import 'package:flutter_riverpod/flutter_riverpod.dart';
  5: import 'package:flutter_colorpicker/flutter_colorpicker.dart';
  6: import 'package:go_router/go_router.dart';
  7: import '../../../cards/services/card_cache_service.dart';
  8: import '../../providers/settings_providers.dart';
  9: import '../../../auth/presentation/screens/account_linking_screen.dart';
 10: import '../screens/logs_viewer_screen.dart';
 11: import '../../../../core/logging/talker_service.dart';
 12: import '../../../../core/utils/responsive_utils.dart';
 13: 
 14: 
 15: class SettingsScreen extends ConsumerWidget {
 16:   final VoidCallback handleLogout;
 17: 
 18:   const SettingsScreen({
 19:     super.key,
 20:     required this.handleLogout,
 21:   });
 22: 
 23:   @override
 24:   Widget build(BuildContext context, WidgetRef ref) {
 25:     final settings = ref.watch(settingsNotifierProvider);
 26:     final themeColor = ref.watch(themeColorProvider);
 27:     final size = MediaQuery.of(context).size;
 28:     final isWideScreen = size.width > 900;
 29:     final talker = TalkerService();
 30: 
 31:     return Scaffold(
 32:       body: LayoutBuilder(
 33:         builder: (context, constraints) {
 34:           final content = ListView(
 35:             padding: ResponsiveUtils.getScreenPadding(context),
 36:             children: [
 37:               _buildAppearanceSection(context, ref, settings, themeColor),
 38:               const Divider(),
 39:               _buildDataManagementSection(context, ref, settings),
 40:               const Divider(),
 41:               _buildAccountSection(
 42:                   context, ref, themeColor, talker, handleLogout),
 43:             ],
 44:           );
 45: 
 46:           if (isWideScreen) {
 47:             return Row(
 48:               children: [
 49:                 NavigationRail(
 50:                   selectedIndex: 0,
 51:                   onDestinationSelected: (index) {
 52:                     // Handle navigation if needed
 53:                   },
 54:                   labelType: NavigationRailLabelType.selected,
 55:                   destinations: const [
 56:                     NavigationRailDestination(
 57:                       icon: Icon(Icons.palette_outlined),
 58:                       selectedIcon: Icon(Icons.palette),
 59:                       label: Text('Appearance'),
 60:                     ),
 61:                     NavigationRailDestination(
 62:                       icon: Icon(Icons.storage_outlined),
 63:                       selectedIcon: Icon(Icons.storage),
 64:                       label: Text('Data'),
 65:                     ),
 66:                     NavigationRailDestination(
 67:                       icon: Icon(Icons.person_outline),
 68:                       selectedIcon: Icon(Icons.person),
 69:                       label: Text('Account'),
 70:                     ),
 71:                   ],
 72:                 ),
 73:                 const VerticalDivider(thickness: 1, width: 1),
 74:                 Expanded(
 75:                   child: ResponsiveUtils.wrapWithMaxWidth(
 76:                     content,
 77:                     context,
 78:                   ),
 79:                 ),
 80:               ],
 81:             );
 82:           }
 83: 
 84:           return ResponsiveUtils.wrapWithMaxWidth(content, context);
 85:         },
 86:       ),
 87:     );
 88:   }
 89: 
 90:   Widget _buildAppearanceSection(
 91:     BuildContext context,
 92:     WidgetRef ref,
 93:     SettingsState settings,
 94:     Color themeColor,
 95:   ) {
 96:     return Column(
 97:       crossAxisAlignment: CrossAxisAlignment.start,
 98:       children: [
 99:         Padding(
100:           padding: const EdgeInsets.symmetric(vertical: 16),
101:           child: Text(
102:             'Appearance',
103:             style: Theme.of(context).textTheme.titleLarge,
104:           ),
105:         ),
106:         ListTile(
107:           title: const Text('Theme Mode'),
108:           trailing: DropdownButton<ThemeMode>(
109:             value: settings.themeMode,
110:             onChanged: (ThemeMode? newMode) {
111:               if (newMode != null) {
112:                 ref
113:                     .read(settingsNotifierProvider.notifier)
114:                     .setThemeMode(newMode);
115:               }
116:             },
117:             items: ThemeMode.values.map((mode) {
118:               return DropdownMenuItem(
119:                 value: mode,
120:                 child: Text(mode.name.capitalize()),
121:               );
122:             }).toList(),
123:           ),
124:         ),
125:         ListTile(
126:           title: const Text('Theme Color'),
127:           trailing: IconButton(
128:             icon: Icon(Icons.circle, color: themeColor),
129:             onPressed: () => _showColorPicker(context, ref),
130:           ),
131:         ),
132:       ],
133:     );
134:   }
135: 
136:   Widget _buildDataManagementSection(
137:     BuildContext context,
138:     WidgetRef ref,
139:     SettingsState settings,
140:   ) {
141:     return Column(
142:       crossAxisAlignment: CrossAxisAlignment.start,
143:       children: [
144:         Padding(
145:           padding: const EdgeInsets.symmetric(vertical: 16),
146:           child: Text(
147:             'Data Management',
148:             style: Theme.of(context).textTheme.titleLarge,
149:           ),
150:         ),
151:         SwitchListTile(
152:           title: const Text('Persist Filters'),
153:           subtitle: const Text('Save filter settings between sessions'),
154:           value: settings.persistFilters,
155:           onChanged: (bool value) {
156:             ref
157:                 .read(settingsNotifierProvider.notifier)
158:                 .setPersistFilters(value);
159:           },
160:         ),
161:         SwitchListTile(
162:           title: const Text('Persist Sort'),
163:           subtitle: const Text('Save sort settings between sessions'),
164:           value: settings.persistSort,
165:           onChanged: (bool value) {
166:             ref.read(settingsNotifierProvider.notifier).setPersistSort(value);
167:           },
168:         ),
169:         ListTile(
170:           leading: Icon(Icons.cleaning_services,
171:               color: Theme.of(context).colorScheme.primary),
172:           title: const Text('Clear Image Cache'),
173:           subtitle: const Text('Free up space used by cached images'),
174:           onTap: () async {
175:             try {
176:               final cacheManager = CardCacheManager();
177:               await cacheManager.emptyCache();
178:               if (context.mounted) {
179:                 ScaffoldMessenger.of(context).showSnackBar(
180:                   const SnackBar(content: Text('Image cache cleared')),
181:                 );
182:               }
183:             } catch (e) {
184:               if (context.mounted) {
185:                 ScaffoldMessenger.of(context).showSnackBar(
186:                   SnackBar(content: Text('Failed to clear cache: $e')),
187:                 );
188:               }
189:             }
190:           },
191:         ),
192:       ],
193:     );
194:   }
195: 
196:   Widget _buildAccountSection(
197:     BuildContext context,
198:     WidgetRef ref,
199:     Color themeColor,
200:     TalkerService talker,
201:     VoidCallback handleLogout,
202:   ) {
203:     return Column(
204:       crossAxisAlignment: CrossAxisAlignment.start,
205:       children: [
206:         Padding(
207:           padding: const EdgeInsets.symmetric(vertical: 16),
208:           child: Text(
209:             'Account',
210:             style: Theme.of(context).textTheme.titleLarge,
211:           ),
212:         ),
213:         ListTile(
214:           leading: Icon(Icons.link, color: themeColor),
215:           title: const Text('Link Account'),
216:           subtitle: const Text('Connect with another sign-in method'),
217:           onTap: () {
218:             Navigator.of(context).push(
219:               MaterialPageRoute(
220:                 builder: (context) => const AccountLinkingScreen(),
221:               ),
222:             );
223:           },
224:         ),
225:         ListTile(
226:           leading: Icon(Icons.bug_report, color: themeColor),
227:           title: const Text('View Logs'),
228:           subtitle: const Text('View application logs and diagnostics'),
229:           onTap: () {
230:             Navigator.of(context).push(
231:               MaterialPageRoute(
232:                 builder: (context) => const LogsViewerScreen(),
233:               ),
234:             );
235:           },
236:         ),
237:         ListTile(
238:           leading: Icon(Icons.logout, color: themeColor),
239:           title: const Text('Logout'),
240:           onTap: () => _handleLogoutTap(context, ref, talker, handleLogout),
241:         ),
242:       ],
243:     );
244:   }
245: 
246:   Future<void> _handleLogoutTap(
247:     BuildContext context,
248:     WidgetRef ref,
249:     TalkerService talker,
250:     VoidCallback handleLogout,
251:   ) async {
252:     final confirmed = await showDialog<bool>(
253:       context: context,
254:       builder: (context) => AlertDialog(
255:         title: const Text('Confirm Logout'),
256:         content: const Text('Are you sure you want to log out?'),
257:         actions: [
258:           TextButton(
259:             onPressed: () => Navigator.pop(context, false),
260:             child: const Text('Cancel'),
261:           ),
262:           TextButton(
263:             onPressed: () => Navigator.pop(context, true),
264:             style: TextButton.styleFrom(
265:               foregroundColor: Theme.of(context).colorScheme.error,
266:             ),
267:             child: const Text('Logout'),
268:           ),
269:         ],
270:       ),
271:     );
272: 
273:     if (confirmed == true && context.mounted) {
274:       try {
275:         await ref.read(settingsNotifierProvider.notifier).logout();
276:         if (!context.mounted) return;
277: 
278:         context.go('/auth/login');
279:         handleLogout();
280:       } catch (e) {
281:         talker.severe('Logout failed', e);
282:         if (context.mounted) {
283:           ScaffoldMessenger.of(context).showSnackBar(
284:             SnackBar(content: Text('Failed to logout: $e')),
285:           );
286:         }
287:       }
288:     }
289:   }
290: 
291:   void _showColorPicker(BuildContext context, WidgetRef ref) {
292:     showDialog(
293:       context: context,
294:       builder: (context) => Dialog(
295:         child: ConstrainedBox(
296:           constraints: BoxConstraints(
297:             maxWidth: ResponsiveUtils.getDialogWidth(context),
298:             maxHeight: MediaQuery.of(context).size.height * 0.8,
299:           ),
300:           child: Padding(
301:             padding: const EdgeInsets.all(16.0),
302:             child: Column(
303:               mainAxisSize: MainAxisSize.min,
304:               children: [
305:                 Text(
306:                   'Pick a color',
307:                   style: Theme.of(context).textTheme.titleLarge,
308:                 ),
309:                 const SizedBox(height: 16),
310:                 Flexible(
311:                   child: SingleChildScrollView(
312:                     child: BlockPicker(
313:                       pickerColor: ref.watch(themeColorProvider),
314:                       onColorChanged: (color) {
315:                         ref
316:                             .read(settingsNotifierProvider.notifier)
317:                             .setThemeColor(color);
318:                         Navigator.of(context).pop();
319:                       },
320:                     ),
321:                   ),
322:                 ),
323:               ],
324:             ),
325:           ),
326:         ),
327:       ),
328:     );
329:   }
330: }
331: 
332: extension StringExtension on String {
333:   String capitalize() {
334:     return "${this[0].toUpperCase()}${substring(1).toLowerCase()}";
335:   }
336: }
</file>

<file path="lib/features/settings/presentation/widgets/color_picker.dart">
 1: import 'package:flutter/material.dart';
 2: import 'package:flutter_riverpod/flutter_riverpod.dart';
 3: import '../../providers/settings_providers.dart';
 4: 
 5: class ColorPicker extends ConsumerWidget {
 6:   const ColorPicker({super.key});
 7: 
 8:   static const List<Color> _colors = [
 9:     Colors.purple,
10:     Colors.blue,
11:     Colors.green,
12:     Colors.orange,
13:     Colors.red,
14:     Colors.pink,
15:   ];
16: 
17:   @override
18:   Widget build(BuildContext context, WidgetRef ref) {
19:     final selectedColor = ref.watch(themeColorProvider);
20: 
21:     return ListTile(
22:       title: const Text('Theme Color'),
23:       subtitle: const Text('Choose your accent color'),
24:       trailing: Wrap(
25:         children: _colors.map((color) {
26:           return Padding(
27:             padding: const EdgeInsets.all(4.0),
28:             child: GestureDetector(
29:               onTap: () {
30:                 ref
31:                     .read(settingsNotifierProvider.notifier)
32:                     .setThemeColor(color);
33:               },
34:               child: Container(
35:                 width: 32,
36:                 height: 32,
37:                 decoration: BoxDecoration(
38:                   color: color,
39:                   shape: BoxShape.circle,
40:                   border: selectedColor == color
41:                       ? Border.all(color: Colors.white, width: 2)
42:                       : null,
43:                 ),
44:               ),
45:             ),
46:           );
47:         }).toList(),
48:       ),
49:     );
50:   }
51: }
</file>

<file path="lib/features/settings/presentation/widgets/settings_switch_tile.dart">
 1: import 'package:flutter/material.dart';
 2: 
 3: class SettingsSwitchTile extends StatelessWidget {
 4:   final String title;
 5:   final String subtitle;
 6:   final bool value;
 7:   final ValueChanged<bool> onChanged;
 8: 
 9:   const SettingsSwitchTile({
10:     super.key,
11:     required this.title,
12:     required this.subtitle,
13:     required this.value,
14:     required this.onChanged,
15:   });
16: 
17:   @override
18:   Widget build(BuildContext context) {
19:     return SwitchListTile(
20:       title: Text(title),
21:       subtitle: Text(subtitle),
22:       value: value,
23:       onChanged: onChanged,
24:     );
25:   }
26: }
</file>

<file path="lib/features/settings/presentation/widgets/theme_selector.dart">
 1: import 'package:flutter/material.dart';
 2: import 'package:flutter_riverpod/flutter_riverpod.dart';
 3: import '../../providers/settings_providers.dart';
 4: 
 5: class ThemeSelector extends ConsumerWidget {
 6:   const ThemeSelector({super.key});
 7: 
 8:   @override
 9:   Widget build(BuildContext context, WidgetRef ref) {
10:     final themeMode = ref.watch(themeModeProvider);
11: 
12:     return ListTile(
13:       title: const Text('Theme Mode'),
14:       subtitle: const Text('Choose your preferred theme'),
15:       trailing: DropdownButton<ThemeMode>(
16:         value: themeMode,
17:         onChanged: (ThemeMode? newMode) {
18:           if (newMode != null) {
19:             ref.read(settingsNotifierProvider.notifier).setThemeMode(newMode);
20:           }
21:         },
22:         items: const [
23:           DropdownMenuItem(
24:             value: ThemeMode.system,
25:             child: Text('System'),
26:           ),
27:           DropdownMenuItem(
28:             value: ThemeMode.light,
29:             child: Text('Light'),
30:           ),
31:           DropdownMenuItem(
32:             value: ThemeMode.dark,
33:             child: Text('Dark'),
34:           ),
35:         ],
36:       ),
37:     );
38:   }
39: }
</file>

<file path="lib/features/settings/providers/settings_providers.dart">
  1: // lib/features/settings/providers/settings_providers.dart
  2: 
  3: // ignore_for_file: deprecated_member_use
  4: 
  5: import 'package:flutter/foundation.dart';
  6: import 'package:flutter/material.dart';
  7: import 'package:flutter_riverpod/flutter_riverpod.dart';
  8: import 'package:firebase_auth/firebase_auth.dart';
  9: import 'package:shared_preferences/shared_preferences.dart';
 10: import 'dart:convert';
 11: import '../../../core/logging/talker_service.dart';
 12: import '../../cards/providers/card_providers.dart';
 13: 
 14: // Constants for SharedPreferences keys
 15: const String _themeModeKey = 'theme_mode';
 16: const String _themeColorKey = 'theme_color';
 17: const String _persistFiltersKey = 'persist_filters';
 18: const String _persistSortKey = 'persist_sort';
 19: const String _logsKey = 'app_logs';
 20: 
 21: // Log entry class
 22: class LogEntry {
 23:   final String message;
 24:   final DateTime timestamp;
 25:   final String? userId;
 26: 
 27:   LogEntry({
 28:     required this.message,
 29:     required this.timestamp,
 30:     this.userId,
 31:   });
 32: 
 33:   Map<String, dynamic> toJson() => {
 34:         'message': message,
 35:         'timestamp': timestamp.toIso8601String(),
 36:         'userId': userId,
 37:       };
 38: 
 39:   factory LogEntry.fromJson(Map<String, dynamic> json) => LogEntry(
 40:         message: json['message'],
 41:         timestamp: DateTime.parse(json['timestamp']),
 42:         userId: json['userId'],
 43:       );
 44: }
 45: 
 46: // Theme mode provider
 47: final themeModeProvider = StateProvider<ThemeMode>((ref) {
 48:   final prefs = ref.watch(sharedPreferencesProvider);
 49:   final themeValue = prefs.getInt(_themeModeKey) ?? ThemeMode.system.index;
 50:   return ThemeMode.values[themeValue];
 51: });
 52: 
 53: // Theme color provider
 54: final themeColorProvider = StateProvider<Color>((ref) {
 55:   final prefs = ref.watch(sharedPreferencesProvider);
 56:   final colorValue = prefs.getInt(_themeColorKey) ?? Colors.purple.value;
 57:   return Color(colorValue);
 58: });
 59: 
 60: // Persist filters provider
 61: final persistFiltersProvider = StateProvider<bool>((ref) {
 62:   final prefs = ref.watch(sharedPreferencesProvider);
 63:   return prefs.getBool(_persistFiltersKey) ?? true;
 64: });
 65: 
 66: // Persist sort provider
 67: final persistSortProvider = StateProvider<bool>((ref) {
 68:   final prefs = ref.watch(sharedPreferencesProvider);
 69:   return prefs.getBool(_persistSortKey) ?? true;
 70: });
 71: 
 72: // App logs provider
 73: final logsProvider = StateNotifierProvider<LogsNotifier, List<LogEntry>>((ref) {
 74:   return LogsNotifier(ref);
 75: });
 76: 
 77: // Logs stream provider
 78: final logsStreamProvider = StreamProvider<String>((ref) async* {
 79:   final talker = TalkerService();
 80:   while (true) {
 81:     yield talker.history.map((log) => log.generateTextMessage()).join('\n');
 82:     await Future.delayed(const Duration(seconds: 1));
 83:   }
 84: });
 85: 
 86: // Logs notifier
 87: class LogsNotifier extends StateNotifier<List<LogEntry>> {
 88:   final Ref _ref;
 89:   final TalkerService _talker = TalkerService();
 90:   static const int _maxLogEntries = 1000;
 91: 
 92:   LogsNotifier(this._ref) : super([]) {
 93:     _loadLogs();
 94:   }
 95: 
 96:   Future<void> _loadLogs() async {
 97:     try {
 98:       final prefs = _ref.read(sharedPreferencesProvider);
 99:       final logsJson = prefs.getStringList(_logsKey) ?? [];
100:       state = logsJson
101:           .map((json) =>
102:               LogEntry.fromJson(Map<String, dynamic>.from(jsonDecode(json))))
103:           .toList();
104: 
105:       // Trim old logs if exceeding max entries
106:       if (state.length > _maxLogEntries) {
107:         state = state.sublist(state.length - _maxLogEntries);
108:         _saveLogs(); // Save the trimmed state
109:       }
110:     } catch (e) {
111:       // If there's an error loading logs, start fresh
112:       state = [];
113:       clearLogs(); // Clear corrupted logs
114:     }
115:   }
116: 
117:   Future<void> addLog(String message) async {
118:     try {
119:       final user = FirebaseAuth.instance.currentUser;
120:       final entry = LogEntry(
121:         message: message,
122:         timestamp: DateTime.now(),
123:         userId: user?.uid,
124:       );
125: 
126:       // Add new log and trim if necessary
127:       final newState = [...state, entry];
128:       if (newState.length > _maxLogEntries) {
129:         newState.removeAt(0); // Remove oldest entry
130:       }
131:       state = newState;
132: 
133:       await _saveLogs();
134:     } catch (e) {
135:       _talker.severe('Error adding log', e); // Changed from print
136:     }
137:   }
138: 
139:   Future<void> _saveLogs() async {
140:     try {
141:       final prefs = await SharedPreferences.getInstance();
142:       await prefs.setStringList(
143:         _logsKey,
144:         state.map((log) => jsonEncode(log.toJson())).toList(),
145:       );
146:     } catch (e) {
147:       _talker.severe('Error saving logs', e); // Changed from print
148:     }
149:   }
150: 
151:   Future<void> clearLogs() async {
152:     state = [];
153:     final prefs = await SharedPreferences.getInstance();
154:     await prefs.remove(_logsKey);
155:   }
156: 
157:   // Add method to get recent logs only
158:   List<LogEntry> getRecentLogs([int count = 100]) {
159:     return state.length <= count ? state : state.sublist(state.length - count);
160:   }
161: }
162: 
163: // Settings state class
164: class SettingsState {
165:   final ThemeMode themeMode;
166:   final Color themeColor;
167:   final bool persistFilters;
168:   final bool persistSort;
169: 
170:   SettingsState({
171:     this.themeMode = ThemeMode.system,
172:     this.themeColor = Colors.purple,
173:     this.persistFilters = true,
174:     this.persistSort = true,
175:   });
176: 
177:   SettingsState copyWith({
178:     ThemeMode? themeMode,
179:     Color? themeColor,
180:     bool? persistFilters,
181:     bool? persistSort,
182:   }) {
183:     return SettingsState(
184:       themeMode: themeMode ?? this.themeMode,
185:       themeColor: themeColor ?? this.themeColor,
186:       persistFilters: persistFilters ?? this.persistFilters,
187:       persistSort: persistSort ?? this.persistSort,
188:     );
189:   }
190: }
191: 
192: // Settings notifier provider
193: final settingsNotifierProvider =
194:     StateNotifierProvider<SettingsNotifier, SettingsState>((ref) {
195:   return SettingsNotifier(ref);
196: });
197: 
198: // Settings notifier class
199: class SettingsNotifier extends StateNotifier<SettingsState> {
200:   final Ref _ref;
201: 
202:   SettingsNotifier(this._ref) : super(SettingsState()) {
203:     _loadSettings();
204:   }
205: 
206:   Future<void> _loadSettings() async {
207:     final prefs = _ref.read(sharedPreferencesProvider);
208: 
209:     final themeModeIndex =
210:         prefs.getInt(_themeModeKey) ?? ThemeMode.system.index;
211:     final themeColorValue = prefs.getInt(_themeColorKey) ?? Colors.purple.value;
212:     final persistFilters = prefs.getBool(_persistFiltersKey) ?? true;
213:     final persistSort = prefs.getBool(_persistSortKey) ?? true;
214: 
215:     state = SettingsState(
216:       themeMode: ThemeMode.values[themeModeIndex],
217:       themeColor: Color(themeColorValue),
218:       persistFilters: persistFilters,
219:       persistSort: persistSort,
220:     );
221:   }
222: 
223:   Future<void> setThemeMode(ThemeMode mode) async {
224:     final prefs = _ref.read(sharedPreferencesProvider);
225:     await prefs.setInt(_themeModeKey, mode.index);
226: 
227:     state = state.copyWith(themeMode: mode);
228:     _ref.read(themeModeProvider.notifier).state = mode;
229:     _ref
230:         .read(logsProvider.notifier)
231:         .addLog('Theme mode changed to: ${mode.name}');
232:   }
233: 
234:   Future<void> setThemeColor(Color color) async {
235:     final prefs = _ref.read(sharedPreferencesProvider);
236:     await prefs.setInt(_themeColorKey, color.value);
237: 
238:     state = state.copyWith(themeColor: color);
239:     _ref.read(themeColorProvider.notifier).state = color;
240:     _ref.read(logsProvider.notifier).addLog('Theme color updated');
241:   }
242: 
243:   Future<void> setPersistFilters(bool value) async {
244:     final prefs = _ref.read(sharedPreferencesProvider);
245:     await prefs.setBool(_persistFiltersKey, value);
246: 
247:     state = state.copyWith(persistFilters: value);
248:     _ref.read(persistFiltersProvider.notifier).state = value;
249:   }
250: 
251:   Future<void> setPersistSort(bool value) async {
252:     final prefs = _ref.read(sharedPreferencesProvider);
253:     await prefs.setBool(_persistSortKey, value);
254: 
255:     state = state.copyWith(persistSort: value);
256:     _ref.read(persistSortProvider.notifier).state = value;
257:   }
258: 
259:   Future<void> logout() async {
260:     try {
261:       await FirebaseAuth.instance.signOut();
262:       _ref.read(logsProvider.notifier).addLog('User logged out');
263:       // Additional cleanup if needed
264:     } catch (e) {
265:       _ref.read(logsProvider.notifier).addLog('Logout failed: $e');
266:       rethrow;
267:     }
268:   }
269: 
270:   Future<void> resetSettings() async {
271:     final prefs = _ref.read(sharedPreferencesProvider);
272:     await Future.wait([
273:       prefs.remove(_themeModeKey),
274:       prefs.remove(_themeColorKey),
275:       prefs.remove(_persistFiltersKey),
276:       prefs.remove(_persistSortKey),
277:     ]);
278: 
279:     state = SettingsState();
280:     _ref.read(themeModeProvider.notifier).state = ThemeMode.system;
281:     _ref.read(themeColorProvider.notifier).state = Colors.purple;
282:     _ref.read(persistFiltersProvider.notifier).state = true;
283:     _ref.read(persistSortProvider.notifier).state = true;
284:     _ref.read(logsProvider.notifier).addLog('Settings reset to defaults');
285:   }
286: }
287: 
288: // Convenience providers for accessing individual settings
289: final isDarkModeProvider = Provider<bool>((ref) {
290:   final themeMode = ref.watch(themeModeProvider);
291:   if (themeMode == ThemeMode.system) {
292:     final platformDispatcher = PlatformDispatcher.instance;
293:     return platformDispatcher.platformBrightness == Brightness.dark;
294:   }
295:   return themeMode == ThemeMode.dark;
296: });
297: 
298: final currentThemeProvider = Provider<ThemeData>((ref) {
299:   final isDark = ref.watch(isDarkModeProvider);
300:   final themeColor = ref.watch(themeColorProvider);
301: 
302:   return isDark
303:       ? ThemeData.dark().copyWith(
304:           colorScheme:
305:               ColorScheme.dark(primary: themeColor, secondary: themeColor))
306:       : ThemeData.light().copyWith(
307:           colorScheme:
308:               ColorScheme.light(primary: themeColor, secondary: themeColor));
309: });
</file>

<file path="lib/main.dart">
  1: // lib/main.dart
  2: 
  3: import 'dart:async';
  4: import 'package:fftcg_companion_app/services/image_url_service.dart';
  5: import 'package:firebase_core/firebase_core.dart';
  6: import 'package:flutter/material.dart';
  7: import 'package:flutter/foundation.dart';
  8: import 'package:flutter/services.dart';
  9: import 'package:flutter_riverpod/flutter_riverpod.dart';
 10: import 'package:shared_preferences/shared_preferences.dart';
 11: import 'dart:io' show Platform;
 12: import 'core/services/hive_service.dart';
 13: import 'core/theme/app_theme.dart';
 14: import 'features/cards/providers/card_providers.dart';
 15: import 'features/cards/services/card_cache_service.dart';
 16: import 'firebase_options.dart';
 17: import 'features/settings/providers/settings_providers.dart';
 18: import 'services/app_check_service.dart';
 19: import 'core/routing/app_router.dart';
 20: import 'core/logging/talker_service.dart';
 21: import 'features/auth/providers/auth_providers.dart';
 22: import 'features/cards/services/favorites_service.dart';
 23: 
 24: Future<void> main() async {
 25:   await runZonedGuarded(() async {
 26:     WidgetsFlutterBinding.ensureInitialized();
 27: 
 28:     final talker = TalkerService();
 29: 
 30:     try {
 31:       // Initialize Hive and FavoritesService
 32:       final hiveService = HiveService();
 33:       await hiveService.initialize();
 34: 
 35:       final favoritesService = FavoritesService();
 36:       await favoritesService.initialize();
 37: 
 38:       // Initialize Firebase
 39:       await Firebase.initializeApp(
 40:         options: DefaultFirebaseOptions.currentPlatform,
 41:       );
 42: 
 43:       // Initialize App Check
 44:       final appCheckService = AppCheckService();
 45:       await appCheckService.initialize();
 46: 
 47:       // Initialize cache manager
 48:       await CardCacheManager.initialize();
 49: 
 50:       // Initialize SharedPreferences
 51:       final prefs = await SharedPreferences.getInstance();
 52: 
 53:       // Create the container
 54:       final container = ProviderContainer(
 55:         overrides: [
 56:           imageUrlServiceProvider.overrideWithValue(ImageUrlService()),
 57:           sharedPreferencesProvider.overrideWithValue(prefs),
 58:         ],
 59:         observers: [
 60:           talker.riverpodObserver,
 61:           if (kDebugMode) _ProviderLogger(),
 62:         ],
 63:       );
 64: 
 65:       // Platform-specific optimizations
 66:       if (Platform.isAndroid) {
 67:         await SystemChrome.setEnabledSystemUIMode(
 68:           SystemUiMode.edgeToEdge,
 69:           overlays: [SystemUiOverlay.top, SystemUiOverlay.bottom],
 70:         );
 71: 
 72:         SystemChrome.setSystemUIOverlayStyle(
 73:           const SystemUiOverlayStyle(
 74:             statusBarColor: Colors.transparent,
 75:             systemNavigationBarColor: Colors.transparent,
 76:             systemNavigationBarDividerColor: Colors.transparent,
 77:             systemNavigationBarIconBrightness: Brightness.light,
 78:             statusBarIconBrightness: Brightness.dark,
 79:           ),
 80:         );
 81:       }
 82: 
 83:       await SystemChrome.setPreferredOrientations([
 84:         DeviceOrientation.portraitUp,
 85:         DeviceOrientation.portraitDown,
 86:       ]);
 87: 
 88:       // Set up error handlers
 89:       FlutterError.onError = (FlutterErrorDetails details) {
 90:         FlutterError.presentError(details);
 91:         talker.severe('Flutter Error', details.exception, details.stack);
 92:       };
 93: 
 94:       PlatformDispatcher.instance.onError = (error, stack) {
 95:         talker.severe('Platform Error', error, stack);
 96:         return true;
 97:       };
 98: 
 99:       ErrorWidget.builder = (FlutterErrorDetails details) {
100:         talker.severe('Widget Error', details.exception, details.stack);
101:         return MaterialApp(
102:           home: Scaffold(
103:             body: SafeArea(
104:               child: Center(
105:                 child: Padding(
106:                   padding: const EdgeInsets.all(16.0),
107:                   child: Text(
108:                     'An error occurred: ${details.exception}',
109:                     style: const TextStyle(color: Colors.red),
110:                     textAlign: TextAlign.center,
111:                   ),
112:                 ),
113:               ),
114:             ),
115:           ),
116:         );
117:       };
118: 
119:       // Initialize auth state
120:       container.read(authNotifierProvider);
121: 
122:       runApp(
123:         UncontrolledProviderScope(
124:           container: container,
125:           child: const FFTCGCompanionApp(),
126:         ),
127:       );
128:     } catch (e, stackTrace) {
129:       talker.severe('Initialization error', e, stackTrace);
130:       runApp(
131:         MaterialApp(
132:           home: ErrorScreen(
133:             error: e.toString(),
134:             onRetry: () => main(),
135:           ),
136:         ),
137:       );
138:     }
139:   }, (error, stack) {
140:     TalkerService().severe('Unhandled error', error, stack);
141:   });
142: }
143: 
144: class _ProviderLogger extends ProviderObserver {
145:   @override
146:   void didUpdateProvider(
147:     ProviderBase<Object?> provider,
148:     Object? previousValue,
149:     Object? newValue,
150:     ProviderContainer container,
151:   ) {
152:     final talker = TalkerService();
153:     talker.debug('''
154: Provider Update:
155:   provider: ${provider.name ?? provider.runtimeType}
156:   previousValue: $previousValue
157:   newValue: $newValue
158: ''');
159:   }
160: 
161:   @override
162:   void didAddProvider(
163:     ProviderBase<Object?> provider,
164:     Object? value,
165:     ProviderContainer container,
166:   ) {
167:     final talker = TalkerService();
168:     talker.debug('''
169: Provider Added:
170:   provider: ${provider.name ?? provider.runtimeType}
171:   initialValue: $value
172: ''');
173:   }
174: 
175:   @override
176:   void didDisposeProvider(
177:     ProviderBase<Object?> provider,
178:     ProviderContainer container,
179:   ) {
180:     final talker = TalkerService();
181:     talker.debug('''
182: Provider Disposed:
183:   provider: ${provider.name ?? provider.runtimeType}
184: ''');
185:   }
186: }
187: 
188: class FFTCGCompanionApp extends ConsumerWidget {
189:   const FFTCGCompanionApp({super.key});
190: 
191:   @override
192:   Widget build(BuildContext context, WidgetRef ref) {
193:     final themeMode = ref.watch(themeModeProvider);
194:     final themeColor = ref.watch(themeColorProvider);
195:     final router = ref.watch(routerProvider);
196: 
197:     return MaterialApp.router(
198:       title: 'FFTCG Companion',
199:       theme: AppTheme.lightTheme.copyWith(
200:         colorScheme: AppTheme.lightTheme.colorScheme.copyWith(
201:           primary: themeColor,
202:           secondary: themeColor,
203:         ),
204:       ),
205:       darkTheme: AppTheme.darkTheme.copyWith(
206:         colorScheme: AppTheme.darkTheme.colorScheme.copyWith(
207:           primary: themeColor,
208:           secondary: themeColor,
209:         ),
210:       ),
211:       themeMode: themeMode,
212:       routerConfig: router,
213:       debugShowCheckedModeBanner: false,
214:       builder: (context, child) {
215:         return MediaQuery(
216:           data: MediaQuery.of(context)
217:               .copyWith(textScaler: const TextScaler.linear(1.0)),
218:           child: child!,
219:         );
220:       },
221:     );
222:   }
223: }
224: 
225: class ErrorScreen extends StatelessWidget {
226:   final String error;
227:   final VoidCallback onRetry;
228: 
229:   const ErrorScreen({
230:     super.key,
231:     required this.error,
232:     required this.onRetry,
233:   });
234: 
235:   @override
236:   Widget build(BuildContext context) {
237:     return Scaffold(
238:       body: SafeArea(
239:         child: Center(
240:           child: Padding(
241:             padding: const EdgeInsets.all(16.0),
242:             child: Column(
243:               mainAxisAlignment: MainAxisAlignment.center,
244:               children: [
245:                 const Icon(
246:                   Icons.error_outline,
247:                   color: Colors.red,
248:                   size: 48,
249:                 ),
250:                 const SizedBox(height: 16),
251:                 Text(
252:                   'Error',
253:                   style: Theme.of(context).textTheme.headlineMedium,
254:                 ),
255:                 const SizedBox(height: 8),
256:                 Text(
257:                   error,
258:                   textAlign: TextAlign.center,
259:                 ),
260:                 const SizedBox(height: 16),
261:                 ElevatedButton.icon(
262:                   onPressed: onRetry,
263:                   icon: const Icon(Icons.refresh),
264:                   label: const Text('Retry'),
265:                 ),
266:               ],
267:             ),
268:           ),
269:         ),
270:       ),
271:     );
272:   }
273: }
</file>

<file path="lib/models/card_model.dart">
 1: import 'package:cloud_firestore/cloud_firestore.dart';
 2: 
 3: class CardModel {
 4:   final String productId;
 5:   final String name;
 6:   final String cleanName;
 7:   final int groupId;
 8:   final String highResUrl;
 9:   final String lowResUrl;
10:   final bool isNonCard;
11:   final DateTime lastUpdated;
12:   final List<String> cardNumbers;
13:   final String primaryCardNumber;
14:   Map<String, dynamic>? extendedData;
15:   Map<String, dynamic>? imageMetadata;
16: 
17:   CardModel({
18:     required this.productId,
19:     required this.name,
20:     required this.cleanName,
21:     required this.groupId,
22:     required this.highResUrl,
23:     required this.lowResUrl,
24:     required this.isNonCard,
25:     required this.lastUpdated,
26:     required this.cardNumbers,
27:     required this.primaryCardNumber,
28:     this.extendedData,
29:     this.imageMetadata,
30:   });
31: 
32:   factory CardModel.fromFirestore(DocumentSnapshot<Map<String, dynamic>> doc) {
33:     final data = doc.data()!;
34:     return CardModel(
35:       productId: doc.id,
36:       name: data['name'] ?? '',
37:       cleanName: data['cleanName'] ?? '',
38:       groupId: data['groupId'] ?? 0,
39:       highResUrl: data['highResUrl'] ?? '',
40:       lowResUrl: data['lowResUrl'] ?? '',
41:       isNonCard: data['isNonCard'] ?? false,
42:       lastUpdated: data['lastUpdated'] != null
43:           ? (data['lastUpdated'] as Timestamp).toDate()
44:           : DateTime.now(),
45:       cardNumbers: List<String>.from(data['cardNumbers'] ?? []),
46:       primaryCardNumber: data['primaryCardNumber'] ?? '',
47:       extendedData: data['extendedData'],
48:       imageMetadata: data['imageMetadata'],
49:     );
50:   }
51: 
52:   Map<String, dynamic> toMap() {
53:     return {
54:       'name': name,
55:       'cleanName': cleanName,
56:       'groupId': groupId,
57:       'highResUrl': highResUrl,
58:       'lowResUrl': lowResUrl,
59:       'isNonCard': isNonCard,
60:       'lastUpdated': Timestamp.fromDate(lastUpdated),
61:       'cardNumbers': cardNumbers,
62:       'primaryCardNumber': primaryCardNumber,
63:       if (extendedData != null) 'extendedData': extendedData,
64:       if (imageMetadata != null) 'imageMetadata': imageMetadata,
65:     };
66:   }
67: }
</file>

<file path="lib/models/user_model.dart">
 1: import 'package:cloud_firestore/cloud_firestore.dart';
 2: import 'dart:convert';
 3: 
 4: class UserModel {
 5:   final String id;
 6:   final String? email;
 7:   final String? displayName;
 8:   final String? photoURL;
 9:   final bool isGuest;
10:   final bool isEmailVerified;
11:   final DateTime createdAt;
12:   final DateTime lastLoginAt;
13: 
14:   UserModel({
15:     required this.id,
16:     this.email,
17:     this.displayName,
18:     this.photoURL,
19:     this.isGuest = false,
20:     this.isEmailVerified = false,
21:     DateTime? createdAt,
22:     DateTime? lastLoginAt,
23:   })  : createdAt = createdAt ?? DateTime.now(),
24:         lastLoginAt = lastLoginAt ?? DateTime.now();
25: 
26:   factory UserModel.fromFirestore(DocumentSnapshot doc) {
27:     final data = doc.data() as Map<String, dynamic>;
28:     return UserModel(
29:       id: doc.id,
30:       email: data['email'],
31:       displayName: data['displayName'],
32:       photoURL: data['photoURL'],
33:       isGuest: data['isGuest'] ?? false,
34:       isEmailVerified: data['isEmailVerified'] ?? false,
35:       createdAt: data['createdAt'] is Timestamp
36:           ? (data['createdAt'] as Timestamp).toDate()
37:           : data['createdAt'] is String
38:               ? DateTime.parse(data['createdAt'])
39:               : DateTime.now(),
40:       lastLoginAt: data['lastLoginAt'] is Timestamp
41:           ? (data['lastLoginAt'] as Timestamp).toDate()
42:           : data['lastLoginAt'] is String
43:               ? DateTime.parse(data['lastLoginAt'])
44:               : DateTime.now(),
45:     );
46:   }
47: 
48:   Map<String, dynamic> toMap() {
49:     return {
50:       'id': id,
51:       'email': email,
52:       'displayName': displayName,
53:       'photoURL': photoURL,
54:       'isGuest': isGuest,
55:       'isEmailVerified': isEmailVerified,
56:       'createdAt': Timestamp.fromDate(createdAt),
57:       'lastLoginAt': Timestamp.fromDate(lastLoginAt),
58:     };
59:   }
60: 
61:   factory UserModel.fromJson(String jsonString) {
62:     final Map<String, dynamic> data = json.decode(jsonString);
63:     return UserModel(
64:       id: data['id'],
65:       email: data['email'],
66:       displayName: data['displayName'],
67:       photoURL: data['photoURL'],
68:       isGuest: data['isGuest'] ?? false,
69:       isEmailVerified: data['isEmailVerified'] ?? false,
70:       createdAt: data['createdAt'] != null
71:           ? DateTime.parse(data['createdAt'])
72:           : DateTime.now(),
73:       lastLoginAt: data['lastLoginAt'] != null
74:           ? DateTime.parse(data['lastLoginAt'])
75:           : DateTime.now(),
76:     );
77:   }
78: 
79:   Map<String, dynamic> toJson() {
80:     return {
81:       'id': id,
82:       'email': email,
83:       'displayName': displayName,
84:       'photoURL': photoURL,
85:       'isGuest': isGuest,
86:       'isEmailVerified': isEmailVerified,
87:       'createdAt': createdAt.toIso8601String(),
88:       'lastLoginAt': lastLoginAt.toIso8601String(),
89:     };
90:   }
91: }
</file>

<file path="lib/services/app_check_service.dart">
  1: import 'package:firebase_app_check/firebase_app_check.dart';
  2: import 'package:flutter/foundation.dart';
  3: import 'package:flutter_riverpod/flutter_riverpod.dart';
  4: import 'package:shared_preferences/shared_preferences.dart';
  5: import 'dart:async';
  6: 
  7: import '../core/logging/talker_service.dart';
  8: 
  9: class AppCheckService {
 10:   static final AppCheckService _instance = AppCheckService._internal();
 11:   final TalkerService _talker = TalkerService();
 12:   StreamSubscription<String?>? _tokenSubscription;
 13:   static const String _tokenTimestampKey = 'app_check_token_timestamp';
 14:   static const Duration _tokenRefreshBuffer = Duration(minutes: 30);
 15: 
 16:   factory AppCheckService() {
 17:     return _instance;
 18:   }
 19: 
 20:   AppCheckService._internal();
 21: 
 22:   Future<void> initialize() async {
 23:     try {
 24:       // Initialize App Check with appropriate provider based on build mode
 25:       if (kDebugMode) {
 26:         _talker.info('Initializing App Check in debug mode');
 27:         await FirebaseAppCheck.instance.activate(
 28:           androidProvider: AndroidProvider.debug,
 29:         );
 30: 
 31:         _tokenSubscription = FirebaseAppCheck.instance.onTokenChange.listen(
 32:           _handleTokenRefresh,
 33:           onError: (error) {
 34:             _talker.warning('App Check token refresh error: $error');
 35:           },
 36:         );
 37:       } else {
 38:         await FirebaseAppCheck.instance.activate(
 39:           androidProvider: AndroidProvider.playIntegrity,
 40:         );
 41:       }
 42: 
 43:       _talker.info('App Check service initialized successfully');
 44:     } catch (e) {
 45:       _talker.severe('Failed to initialize App Check service', e);
 46:       if (!kDebugMode) rethrow;
 47:     }
 48:   }
 49: 
 50:   Future<void> _handleTokenRefresh(String? token) async {
 51:     if (token != null) {
 52:       await _updateTokenTimestamp();
 53:       _talker.info('App Check token refreshed automatically');
 54:     }
 55:   }
 56: 
 57:   Future<void> _updateTokenTimestamp() async {
 58:     try {
 59:       final prefs = await SharedPreferences.getInstance();
 60:       await prefs.setInt(
 61:         _tokenTimestampKey,
 62:         DateTime.now().millisecondsSinceEpoch,
 63:       );
 64:     } catch (e) {
 65:       _talker.warning('Failed to update token timestamp: $e');
 66:     }
 67:   }
 68: 
 69:   Future<bool> validateToken() async {
 70:     try {
 71:       final needsRefresh = await _needsTokenRefresh();
 72: 
 73:       if (needsRefresh) {
 74:         _talker.info('Token refresh needed, requesting new token');
 75:         final token = await FirebaseAppCheck.instance.getToken(true);
 76:         if (token != null) {
 77:           await _updateTokenTimestamp();
 78:           return true;
 79:         }
 80:         return false;
 81:       }
 82: 
 83:       final token = await FirebaseAppCheck.instance.getToken();
 84:       return token != null;
 85:     } catch (e) {
 86:       _talker.severe('Token validation failed: $e');
 87:       return false;
 88:     }
 89:   }
 90: 
 91:   Future<bool> _needsTokenRefresh() async {
 92:     try {
 93:       final prefs = await SharedPreferences.getInstance();
 94:       final lastRefresh = prefs.getInt(_tokenTimestampKey);
 95: 
 96:       if (lastRefresh == null) return true;
 97: 
 98:       final lastRefreshTime = DateTime.fromMillisecondsSinceEpoch(lastRefresh);
 99:       final timeSinceRefresh = DateTime.now().difference(lastRefreshTime);
100: 
101:       return timeSinceRefresh > _tokenRefreshBuffer;
102:     } catch (e) {
103:       _talker.warning('Error checking token refresh need: $e');
104:       return true;
105:     }
106:   }
107: 
108:   void dispose() {
109:     _tokenSubscription?.cancel();
110:     _tokenSubscription = null;
111:     _talker.info('App Check service disposed');
112:   }
113: }
114: 
115: final appCheckServiceProvider = Provider<AppCheckService>((ref) {
116:   final service = AppCheckService();
117:   ref.onDispose(() => service.dispose());
118:   return service;
119: });
</file>

<file path="lib/services/firebase_service.dart">
 1: // lib/services/firebase_service.dart
 2: 
 3: import 'package:cloud_firestore/cloud_firestore.dart';
 4: import 'package:flutter_riverpod/flutter_riverpod.dart';
 5: import '../core/logging/talker_service.dart';
 6: 
 7: final firebaseServiceProvider = Provider((ref) => FirebaseService());
 8: 
 9: class FirebaseService {
10:   final FirebaseFirestore _firestore = FirebaseFirestore.instance;
11:   final _talker = TalkerService();
12: 
13:   // Collection names as static constants
14:   static const String cardsCollection = 'cards';
15:   static const String pricesCollection = 'prices';
16:   static const String syncMetadataCollection = 'syncMetadata';
17:   static const String logsCollection = 'logs';
18:   static const String priceHashesCollection = 'priceHashes';
19:   static const String historicalPricesCollection = 'historicalPrices';
20:   static const String cardDeltasCollection = 'cardDeltas';
21:   static const String priceDeltasCollection = 'priceDatas';
22: 
23:   FirebaseService() {
24:     _talker.debug('FirebaseService initialized');
25:   }
26: 
27:   // Collection references
28:   CollectionReference get cards => _firestore.collection(cardsCollection);
29:   CollectionReference get prices => _firestore.collection(pricesCollection);
30:   CollectionReference get historicalPrices =>
31:       _firestore.collection(historicalPricesCollection);
32: 
33:   // Test query to verify connection
34:   Future<bool> testConnection() async {
35:     try {
36:       final snapshot = await cards.limit(1).get();
37:       return snapshot.docs.isNotEmpty;
38:     } catch (e, stackTrace) {
39:       _talker.severe('Firebase connection error', e, stackTrace);
40:       return false;
41:     }
42:   }
43: 
44:   // Get card by ID
45:   Future<DocumentSnapshot?> getCard(String cardId) async {
46:     try {
47:       return await cards.doc(cardId).get();
48:     } catch (e, stackTrace) {
49:       _talker.severe('Error getting card', e, stackTrace);
50:       return null;
51:     }
52:   }
53: 
54:   // Get paginated cards
55:   Future<QuerySnapshot> getCards({
56:     DocumentSnapshot? startAfter,
57:     int limit = 20,
58:   }) async {
59:     try {
60:       Query query = cards.orderBy('name').limit(limit);
61: 
62:       if (startAfter != null) {
63:         query = query.startAfterDocument(startAfter);
64:       }
65: 
66:       return await query.get();
67:     } catch (e, stackTrace) {
68:       _talker.severe('Error getting cards', e, stackTrace);
69:       rethrow;
70:     }
71:   }
72: 
73:   // Get price history for a card
74:   Future<QuerySnapshot> getPriceHistory(String productId,
75:       {int days = 30}) async {
76:     try {
77:       final cutoffDate = DateTime.now().subtract(Duration(days: days));
78: 
79:       return await historicalPrices
80:           .where('productId', isEqualTo: productId)
81:           .where('date', isGreaterThanOrEqualTo: cutoffDate)
82:           .orderBy('date', descending: true)
83:           .get();
84:     } catch (e, stackTrace) {
85:       _talker.severe('Error getting price history', e, stackTrace);
86:       rethrow;
87:     }
88:   }
89: 
90:   // Get current price for a card
91:   Future<DocumentSnapshot?> getCurrentPrice(String productId) async {
92:     try {
93:       return await prices.doc(productId).get();
94:     } catch (e, stackTrace) {
95:       _talker.severe('Error getting current price', e, stackTrace);
96:       return null;
97:     }
98:   }
99: }
</file>

<file path="lib/services/firestore_service.dart">
  1: import 'package:cloud_firestore/cloud_firestore.dart';
  2: import 'package:flutter_riverpod/flutter_riverpod.dart';
  3: import '../features/cards/models/price_model.dart';
  4: import '../features/cards/models/fftcg_card.dart';
  5: import '../utils/result.dart';
  6: import '../utils/retry.dart';
  7: import '../core/logging/talker_service.dart';
  8: 
  9: class FirestoreService {
 10:   final FirebaseFirestore _firestore;
 11:   final TalkerService _talker;
 12:   static const String _cardsCollection = 'cards';
 13:   static const String _pricesCollection = 'prices';
 14:   static const String _historicalPricesCollection = 'historicalPrices';
 15: 
 16:   FirestoreService({
 17:     FirebaseFirestore? firestore,
 18:     TalkerService? talker,
 19:   })  : _firestore = firestore ?? FirebaseFirestore.instance,
 20:         _talker = talker ?? TalkerService();
 21: 
 22:   Future<Result<FFTCGCard?>> getCard(String productId) async {
 23:     try {
 24:       final result = await retry(
 25:         () => _firestore.collection(_cardsCollection).doc(productId).get(),
 26:         config: const RetryConfig(),
 27:       );
 28: 
 29:       if (!result.exists) {
 30:         return Result.success(null);
 31:       }
 32: 
 33:       return Result.success(FFTCGCard.fromFirestore(result));
 34:     } catch (e) {
 35:       _talker.severe('Error fetching card', e);
 36:       return Result.failure('Error fetching card: $e');
 37:     }
 38:   }
 39: 
 40:   Future<Result<List<FFTCGCard>>> getCardsByGroup(int groupId) async {
 41:     try {
 42:       final result = await _firestore
 43:           .collection(_cardsCollection)
 44:           .where('groupId', isEqualTo: groupId)
 45:           .get();
 46: 
 47:       final cards =
 48:           result.docs.map((doc) => FFTCGCard.fromFirestore(doc)).toList();
 49:       return Result.success(cards);
 50:     } catch (e) {
 51:       _talker.severe('Error fetching cards by group', e);
 52:       return Result.failure('Error fetching cards: $e');
 53:     }
 54:   }
 55: 
 56:   Future<Result<PriceModel?>> getCurrentPrice(String productId) async {
 57:     try {
 58:       final doc =
 59:           await _firestore.collection(_pricesCollection).doc(productId).get();
 60: 
 61:       if (!doc.exists) {
 62:         return Result.success(null);
 63:       }
 64: 
 65:       return Result.success(PriceModel.fromFirestore(doc));
 66:     } catch (e) {
 67:       _talker.severe('Error getting current price', e);
 68:       return Result.failure('Error fetching price: $e');
 69:     }
 70:   }
 71: 
 72:   Future<Result<List<PriceModel>>> getPriceHistory(
 73:     String productId, {
 74:     int days = 30,
 75:   }) async {
 76:     try {
 77:       final today = DateTime.now();
 78:       final startDate = today.subtract(Duration(days: days));
 79: 
 80:       final result = await _firestore
 81:           .collection(_historicalPricesCollection)
 82:           .where('productId', isEqualTo: int.parse(productId))
 83:           .where('date', isGreaterThanOrEqualTo: startDate)
 84:           .orderBy('date', descending: true)
 85:           .get();
 86: 
 87:       return Result.success(
 88:         result.docs.map((doc) => PriceModel.fromFirestore(doc)).toList(),
 89:       );
 90:     } catch (e) {
 91:       _talker.severe('Error fetching price history', e);
 92:       return Result.failure('Error fetching price history: $e');
 93:     }
 94:   }
 95: 
 96:   Future<Result<Map<String, dynamic>>> getImageMetadata(
 97:       String productId) async {
 98:     try {
 99:       final doc = await _firestore
100:           .collection(_cardsCollection)
101:           .doc(productId)
102:           .collection('metadata')
103:           .doc('image')
104:           .get();
105: 
106:       if (!doc.exists) {
107:         return Result.failure('Image metadata not found');
108:       }
109: 
110:       return Result.success(doc.data()!);
111:     } catch (e) {
112:       _talker.severe('Error fetching image metadata', e);
113:       return Result.failure('Error fetching image metadata: $e');
114:     }
115:   }
116: 
117:   Future<Result<List<FFTCGCard>>> searchCards(String searchTerm) async {
118:     try {
119:       final result = await _firestore
120:           .collection(_cardsCollection)
121:           .where('cleanName', isGreaterThanOrEqualTo: searchTerm.toLowerCase())
122:           .where('cleanName', isLessThan: '${searchTerm.toLowerCase()}z')
123:           .limit(20)
124:           .get();
125: 
126:       final cards =
127:           result.docs.map((doc) => FFTCGCard.fromFirestore(doc)).toList();
128:       return Result.success(cards);
129:     } catch (e) {
130:       _talker.severe('Error searching cards', e);
131:       return Result.failure('Error searching cards: $e');
132:     }
133:   }
134: }
135: 
136: final firestoreServiceProvider = Provider<FirestoreService>((ref) {
137:   return FirestoreService();
138: });
</file>

<file path="lib/services/image_url_service.dart">
 1: // lib/services/image_url_service.dart
 2: import 'package:flutter_riverpod/flutter_riverpod.dart';
 3: 
 4: class ImageUrlService {
 5:   static const String _cdnDomain = 'https://fftcgcompanion.com/card-images';
 6: 
 7:   String getImageUrl(String url) {
 8:     if (url.contains('firebasestorage.googleapis.com')) {
 9:       // Extract just the filename from the Firebase URL
10:       final uri = Uri.parse(url);
11:       final filename = uri.pathSegments.last;
12:       // Convert to CDN URL
13:       return '$_cdnDomain/$filename';
14:     }
15:     return url;
16:   }
17: 
18:   bool isValidImageUrl(String? url) {
19:     if (url == null || url.isEmpty) return false;
20:     return url.startsWith('http');
21:   }
22: }
23: 
24: final imageUrlServiceProvider = Provider<ImageUrlService>((ref) {
25:   return ImageUrlService();
26: });
</file>

<file path="lib/utils/result.dart">
 1: class Result<T> {
 2:   final T? data;
 3:   final String? error;
 4:   final bool isSuccess;
 5: 
 6:   Result._({this.data, this.error, required this.isSuccess});
 7: 
 8:   factory Result.success(T? data) => Result._(data: data, isSuccess: true);
 9:   factory Result.failure(String error) =>
10:       Result._(error: error, isSuccess: false);
11: }
</file>

<file path="lib/utils/retry.dart">
 1: typedef RetryCondition = bool Function(Exception e);
 2: 
 3: class RetryConfig {
 4:   final int maxAttempts;
 5:   final Duration delay;
 6: 
 7:   const RetryConfig({
 8:     this.maxAttempts = 3,
 9:     this.delay = const Duration(seconds: 1),
10:   });
11: }
12: 
13: Future<T> retry<T>(
14:   Future<T> Function() operation, {
15:   RetryConfig? config,
16:   RetryCondition? shouldRetry,
17: }) async {
18:   config ??= const RetryConfig();
19:   int attempts = 0;
20: 
21:   while (true) {
22:     try {
23:       attempts++;
24:       return await operation();
25:     } catch (e) {
26:       if (attempts >= config.maxAttempts ||
27:           (shouldRetry != null && !shouldRetry(e as Exception))) {
28:         rethrow;
29:       }
30:       await Future.delayed(config.delay * attempts);
31:     }
32:   }
33: }
</file>

<file path="pubspec.yaml">
 1: name: fftcg_companion_app
 2: description: A companion app for Final Fantasy Trading Card Game
 3: publish_to: 'none'
 4: version: 1.0.0+1
 5: 
 6: environment:
 7:   sdk: '>=3.2.0 <4.0.0'
 8: 
 9: dependencies:
10:   flutter:
11:     sdk: flutter
12:   firebase_core: ^3.8.1
13:   cloud_firestore: ^5.5.1
14:   cached_network_image: ^3.3.0
15:   flutter_cache_manager: ^3.4.1
16:   hive: ^2.2.3
17:   hive_flutter: ^1.1.0
18:   flutter_riverpod: ^2.4.9
19:   go_router: ^14.6.2
20:   workmanager: ^0.5.1
21:   flutter_staggered_grid_view: ^0.7.0
22:   json_annotation: ^4.8.1
23:   freezed_annotation: ^2.4.4
24:   logging: ^1.2.0    
25:   path_provider: ^2.1.1
26:   share_plus: ^10.1.3
27:   shared_preferences: ^2.3.4
28:   firebase_app_check: 0.3.1+7
29:   connectivity_plus: ^6.1.0
30:   flutter_launcher_icons: ^0.14.2
31:   internet_connection_checker: ^1.0.0+1
32:   firebase_crashlytics: ^4.2.0
33:   device_info_plus: ^9.1.1
34:   google_api_availability: 5.0.0
35:   google_sign_in: ^6.2.2
36:   firebase_auth: ^5.3.4
37:   shared_preferences_android: 2.3.4
38:   flutter_colorpicker: ^1.1.0
39:   talker: ^4.5.4
40:   talker_flutter: ^4.5.4
41:   talker_dio_logger: ^4.5.4    # For your HTTP logging
42:   talker_riverpod_logger: ^4.5.4  # For Riverpod integration
43:   fl_chart: ^0.70.0
44:   
45: dev_dependencies:
46:   flutter_test:
47:     sdk: flutter
48:   flutter_lints: ^3.0.1
49:   build_runner: ^2.4.14
50:   json_serializable: ^6.7.1
51:   freezed: ^2.5.7
52:   hive_generator: ^2.0.1
53:   
54: 
55: flutter:
56:   uses-material-design: true
57: 
58: 
59: flutter_launcher_icons:
60:   image_path: "fftcg_card_icon.png"
61:   android: true
62:   ios: true
</file>

</repository_files>
